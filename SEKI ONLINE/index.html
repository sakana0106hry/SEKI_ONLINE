<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SEKI Online</title>
    <style>
    /* ベース設定：フォントをモダンに、背景をリッチに */
    @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap');

    body { 
        font-family: "M PLUS Rounded 1c", sans-serif; 
        
        /* 背景を固定（スクロールしても付いてくるように） */
        background: radial-gradient(circle, #2e7d32 0%, #1b5e20 60%, #003300 100%);
        background-attachment: fixed; /* ★重要 */
        
        color: white; 
        margin: 0; 
        text-align: center; 
        user-select: none; 
        -webkit-tap-highlight-color: transparent;
        
        min-height: 100dvh;       /* スマホ対応 */

        /* ★ここでスクロールさせる（ブラウザの右端に出る） */
        overflow-y: auto; 
        overflow-x: hidden;

        display: flex;        /* Flexbox化 */
        flex-direction: column;
    }

    /* 共通レイアウト */
    #game-screen { 
        padding: 0;           /* パディングは内部で調整 */
        margin: 0 auto;
        width: 100%;
        max-width: 800px;     /* 横幅制限 */
        
        /* 高さは中身に合わせて伸びる */
        height: auto;
        min-height: 100vh;

        display: flex;
        flex-direction: column;
        overflow: visible;     /* ここもスクロール禁止 */
    }
    #header-info {
        flex: 0 0 40px;       /* 高さ40px固定 */
        padding: 10px;        /* 余白 */
    }
    .hidden { display: none !important; }
    
    /* --- ゴージャス・ログイン画面用CSS --- */

    /* ▼▼▼ ここから #login-screen 関連の完全版コード ▼▼▼ */

    /* 1. ログイン画面本体（枠線を表示） */
    /* ログイン画面（画面中央） */
    #login-screen {
        /* --- 既存の設定 --- */
        width: 90%;
        max-width: 420px;
        margin: auto;
        padding: 50px 30px;
        background: rgba(0, 0, 0, 0.65);
        backdrop-filter: blur(15px);
        border-radius: 20px;
        
        /* --- ▼ 変更点 ▼ --- */
        /* position: relative; を追加（必須） */
        position: relative;
        /* 枠線を豪華な二重線に変更 */
        border: 4px double rgba(255, 223, 80, 0.7); 
        
        /* 既存の影設定 */
        box-shadow: 
            0 20px 50px rgba(0, 0, 0, 0.8),
            0 0 20px rgba(255, 215, 0, 0.1),
            inset 0 0 30px rgba(255, 215, 0, 0.05);
        
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        animation: fadeInUp 1s ease-out;
        /* --- ▲ 変更点ここまで ▲ --- */
    }

    /* --- ▼▼▼ ここから新規追加（四隅の豪華装飾） ▼▼▼ --- */

    
    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }

    /* タイトルロゴ画像 */
    #title-logo {
        width: 100%;            /* 親要素に合わせてリサイズ */
        max-width: 320px;       /* 最大幅 */
        height: auto;           /* 比率を維持 */
        object-fit: contain;
        
        /* ★ロゴを光らせる（金色の影） */
        filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.7));
        
        /* ふわふわ浮遊させるアニメーション */
        animation: floatLogo 3s ease-in-out infinite alternate;
        margin-bottom: 5px;
    }

    @keyframes floatLogo {
        0% { transform: translateY(0); filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5)); }
        100% { transform: translateY(-8px); filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.9)); }
    }

    /* バージョン表記 */
    .version-text {
        font-family: "M PLUS Rounded 1c", "Rounded Mplus 1c", sans-serif, Arial, sans-serif;
        font-size: 13px;
        color: #ffd700;         /* ゴールド文字 */
        letter-spacing: 2px;    /* 文字間隔を広げて高級感 */
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        opacity: 0.9;
        margin-top: -10px;      /* ロゴに近づける */
        margin-bottom: 10px;
    }

    /* 入力フォーム（リッチ版） */
    input { 
        padding: 15px; 
        font-size: 16px; 
        margin: 5px 0; 
        border-radius: 30px;    /* 完全な丸み（ピル型） */
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1); /* 背景を少し透けさせる */
        color: white;           /* 入力文字を白に */
        width: 85%;
        text-align: center;
        transition: 0.3s;
        box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
    }
    input::placeholder { color: rgba(255,255,255,0.5); }
    input:focus {
        outline: none;
        background: rgba(255, 255, 255, 0.2);
        border-color: #ffd700;  /* フォーカス時に金色 */
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }

    /* ボタン（さらに輝きを増す） */
    #btn-join { 
        padding: 14px 40px; 
        font-size: 18px; 
        margin-top: 10px;
        cursor: pointer; 
        /* プレミアムなゴールドグラデーション */
        background: linear-gradient(135deg, #fff176 0%, #fbc02d 50%, #f57f17 100%);
        border: 1px solid #fff;
        border-radius: 30px; 
        font-weight: 800; 
        color: #3e2723; 
        box-shadow: 0 5px 15px rgba(0,0,0,0.5), 0 0 10px rgba(255,235,59,0.5);
        transition: transform 0.2s, box-shadow 0.2s, filter 0.2s;
        width: 70%;
    }
    #btn-join:hover { 
        filter: brightness(1.2); 
        transform: translateY(-2px) scale(1.02); 
        box-shadow: 0 8px 25px rgba(255, 215, 0, 0.6); 
    }
    #btn-join:active { transform: translateY(1px); }

    button { 
        padding: 12px 24px; 
        font-size: 16px; 
        cursor: pointer; 
        background: linear-gradient(135deg, #fdd835, #fbc02d); /* 金色の立体感 */
        border: none; 
        border-radius: 25px; 
        font-weight: bold; 
        color: #3e2723; 
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        transition: transform 0.1s, box-shadow 0.1s;
    }
    button:hover { filter: brightness(1.1); transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.4); }
    button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    button:disabled { background: #bdbdbd; color: #757575; cursor: not-allowed; transform: none; box-shadow: none; }

    /* エリアごとのパネル化（グラスモーフィズム） */
    #my-area {
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(5px);
        border-radius: 16px;
        border: 1px solid rgba(255,255,255,0.1);
        padding: 15px;
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        margin-top: 10px;
    }

    /* カード・盤面デザイン */
    .pile { 
        width: 60px; height: 90px; 
        border: 2px dashed rgba(255,255,255,0.5); 
        border-radius: 8px;
        margin: auto; display:flex; align-items:center; justify-content:center; 
        background: rgba(0,0,0,0.2); 
        cursor: pointer; transition: 0.2s; 
    }
    .pile:hover { background: rgba(255,255,255,0.1); border-color: #ffeb3b; transform: scale(1.05); }

    .card { 
        width: 54px; height: 86px; 
        background-color: #fafafa; color: #333; 
        border-radius: 6px; 
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.3); /* カードの影 */
        display: inline-flex; align-items: center; justify-content: center; 
        font-weight: bold; margin: 3px; font-size: 22px; 
        cursor: pointer; position: relative; 
        transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* バネのような動き */
        vertical-align: bottom;
        background-size: cover; background-position: center; background-repeat: no-repeat;
    }
    /* カードの動き */
    .card:not(.selected):hover { transform: translateY(-8px) rotate(2deg); z-index: 5; }
    
    .card.num { color: #1565c0; font-family: 'Arial Black', sans-serif; }
    .card.sym { color: #c62828; font-size: 11px; text-align:center; line-height:1.1; letter-spacing: -0.5px;}
    /*.card[data-val="0"] { border: 2px solid #ab47bc; color: #8e24aa; background: #f3e5f5; }*/

    /* 選択状態：光るエフェクト */
    .selected { 
        transform: translateY(-20px) scale(1.1) !important; 
        border: 2px solid #ffeb3b; 
        box-shadow: 0 0 15px #ffeb3b, 0 10px 20px rgba(0,0,0,0.5); 
        z-index: 100; 
    }
    .card.has-img { color: transparent !important; font-size: 0; border: 2px solid #fff; }

    /* 他プレイヤー表示 */
    /* --- 円卓レイアウト用CSS --- */
    /* --- アニメーション定義 (光る演出用) --- */
    @keyframes pulse-yellow {
        0% { box-shadow: 0 0 5px #ffeb3b; }
        50% { box-shadow: 0 0 15px #ffeb3b, 0 0 5px rgba(255,235,59,0.5) inset; }
        100% { box-shadow: 0 0 5px #ffeb3b; }
    }
    @keyframes blink-red {
        0% { border-color: #ff1744; background-color: rgba(255, 23, 68, 0.1); }
        50% { border-color: #b71c1c; background-color: rgba(255, 23, 68, 0.3); }
        100% { border-color: #ff1744; background-color: rgba(255, 23, 68, 0.1); }
    }
    @keyframes blink-orange {
        0% { border-color: #ff9800; }
        50% { border-color: #ffe0b2; }
        100% { border-color: #ff9800; }
    }
    @keyframes pulse-badge { from{transform:scale(1);} to{transform:scale(1.3);} }

    /* --- 円卓レイアウト用 (画面分割) --- */
    #game-table {
        /* 残りの高さを全部使う */
        flex: 1;
        
        display: flex;
        flex-direction: column;
        width: 100%;
        position: relative;
        
        /* ★ここが重要：入り切らない場合はここだけスクロールさせる */
        overflow-y: visible; 
        
        /* ★ログバー(35px)と被らないよう、底上げする */
        padding-bottom: 80px !important; 
        
        /* 横のパディング */
        padding-left: 10px;
        padding-right: 10px;
        box-sizing: border-box;
        
        /* 高さ指定（calc）は削除して auto に */
        height: auto !important; 
    }

    /* エリア定義 */
    #area-top {
        height: 15%; /* 画面上部 */
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: 10px;
        padding-bottom: 5px;
    }

    #area-middle {
        flex: 1; /* 残りのスペース */
        display: flex;
        align-items: center;
        /* justify-content: space-between;  ← これを削除して */
        justify-content: center;         /* ← これに変更！ */
        gap: 5px;                        /* ← 間隔を少し空ける */
        width: 100%;
        position: relative;
    }
    /* ↓↓↓ 追加: 自分の手番のときの強調表示 ↓↓↓ */
    #my-area.current-turn {
        border: 2px solid #ffeb3b !important;       /* 黄色い枠線 */
        box-shadow: 0 0 30px rgba(255, 235, 59, 0.5); /* ぼんやり光る */
        background: rgba(60, 60, 0, 0.5);           /* 背景も少し黄色く */
        transform: translateY(-2px);                /* ほんの少し浮き上がる */
        transition: all 0.3s ease;
    }

    /* サイドバー (左右のプレイヤー) */
    /* --- プレイヤーエリアの枠組み --- */
    /* サイドバーの幅を少し広げて、プレイヤーボックスが入るようにする */
    /* --- 1. エリア定義の調整 (ボックス拡大に合わせて広げる) --- */
    
    /* 左右のサイドバー：幅を広げる */
    .player-zone.col {
        width: 150px; /* 80px -> 110px -> 130px に拡大 */
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 10px;
        z-index: 10; /* 中央フィールドより手前に表示 */
    }

    /* 上部エリア：高さを確保 */
    #area-top {
        height: auto;
        min-height: 130px; /* ボックスがしっかり入る高さ */
        display: flex;
        justify-content: center;
        align-items: flex-end; /* 下揃え */
        gap: 12px; /* 横並び時の隙間 */
        padding-bottom: 5px;
        z-index: 10;
    }
    /* ↓↓↓ 追加: 自分のネームプレート（ヘッダー風） ↓↓↓ */
    .my-name-plate {
        background: rgba(0, 0, 0, 0.4);       /* 少し暗くして文字を目立たせる */
        border-bottom: 1px solid rgba(255,255,255,0.15);
        padding: 8px 15px;
        margin: -15px -15px 10px -15px;       /* 親のpadding(15px)を相殺して上端に密着 */
        border-radius: 16px 16px 0 0;         /* 親の角丸に合わせて丸める */
        
        font-weight: bold;
        font-size: 14px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 6px;
        color: #fff;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    /* --- 2. プレイヤープレート本体 (サイズアップ) --- */
    .p-box-new {
        width: 140px;            /* 横幅 */
        height: 110px;           /* ★高さを数値で強制固定！ */
        
        display: flex;
        flex-direction: column;  /* 縦並び */
        justify-content: space-between; /* 上・中・下をきっちり配置 */
        
        background: rgba(30, 40, 50, 0.9);
        border: 1px solid rgba(255,255,255,0.4);
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.6);
        transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
        overflow: visible !important;        /* ★はみ出した分はカット（これで伸びない） */
    }

    /* 手番のときの強調 */
    .p-box-new.current {
        border: 2px solid #ffeb3b;
        box-shadow: 0 0 20px rgba(255, 235, 59, 0.7);
        background: rgba(70, 70, 10, 0.9);
        z-index: 100;
        /* currentで拡大させるとレイアウトが崩れることがあるので、
           scaleではなく translate や shadow だけで目立たせるのが安全ですが、
           一旦 scale(1.05) はそのままでいきます */
        transform: scale(1.05);
    }

    /* --- 3. 内部パーツ (文字サイズ拡大) --- */

    /* ヘッダー（名前） */
    .p-header {
        height: 26px;            /* ★高さ固定 */
        line-height: 26px;       /* 垂直中央 */
        padding: 0 4px;
        background: rgba(255,255,255,0.15);
        border-bottom: 1px solid rgba(255,255,255,0.1);
        font-size: 13px;
        font-weight: bold;
        color: #fff;
        white-space: nowrap;     /* 改行させない */
        overflow: hidden;
        text-overflow: ellipsis; /* 長すぎたら...にする */
    }

    .p-host-mark { color: #ffd700; margin-right: 4px; font-size: 13px; }

    /* --- 3段固定レイアウト用の修正 --- */

    /* 中段：手札数とステータスを横並びに */
    .p-body {
        flex: 1;                 /* ★余った高さを全部使う */
        display: flex;
        flex-direction: row;     /* 横並び */
        justify-content: space-between;
        align-items: center;
        padding: 0 8px;
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    /* 左側：手札枚数（フォントサイズはそのまま維持） */
    .p-hand-count {
        flex-shrink: 0 !important;      /* 横幅が足りなくても、絶対に縮めない！ */
        white-space: nowrap !important; /* 勝手に改行させない！ */
        font-size: 24px;         /* ★そのまま！ */
        font-weight: 800;
        color: #fff;
        display: flex; 
        align-items: center; 
        gap: 2px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }
    .p-hand-icon { font-size: 16px; opacity: 0.8; margin-right: 2px; } 

    /* 右側：ステータス表示エリア */
    .p-status-area {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        justify-content: center;
    }
    
    /* ステータス文字のスタイル定義 */
    .status-text { font-size: 10px; font-weight: bold; letter-spacing: 1px; }
    
    .status-normal { color: #546e7a; } /* NORMAL: 目立たないグレー */
    
    .status-reset { 
        color: #ffeb3b; 
        animation: pulse-yellow 2s infinite; 
        border: 1px solid #ffeb3b;
        padding: 0 4px;
        border-radius: 4px;
        background: rgba(0,0,0,0.3);
    }
    
    .status-rank {
        color: #ffd700;
        font-size: 14px; /* 順位は少し大きく */
        text-shadow: 0 0 5px #ff9800;
    }

    /* 下段：役職エリア（高さ固定） */
    .p-role-row {
        height: 30px;            /* ★高さ固定 */
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0,0,0,0.2);
        padding: 0 4px;
    }

    /* --- 役職バッジ（視認性アップ版） --- */
    .role-badge-pill {
        font-size: 13px;       /* 12px -> 13px (少し大きく) */
        font-weight: 800;      /* 太文字にしてクッキリさせる */
        
        padding: 2px 0;        /* 上下は詰めて文字スペース確保 */
        width: 95%;            /* 横幅いっぱいに広げる */
        
        /* 明るく目立つグラデーションに変更 */
        background: linear-gradient(135deg, #e040fb, #7b1fa2); 
        border: 1px solid #fff; /* 白い枠線で囲んで強調 */
        
        /* ほんのり発光させて目立たせる */
        box-shadow: 0 0 8px rgba(224, 64, 251, 0.6);
        
        color: #fff;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        
        /* 中央揃え */
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 12px;
        letter-spacing: 1px;
    }

    /* 正体不明のとき（ROLE: ???）も見やすく */
    .role-unknown {
        font-size: 11px;
        /* 暗いグレーではなく、半透明の白にして読みやすくする */
        color: rgba(255, 255, 255, 0.6); 
        font-weight: bold;
        letter-spacing: 2px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    /* 修正: 役職の補足情報（手品師のスキル名など）を横並びにする */
    .role-sub { 
        font-size: 10px; 
        display: inline;      /* 横に並べる */
        opacity: 0.9; 
        margin-left: 4px;
    }
    /* --- 4. 公開カード (ミニカードも拡大) --- */
    .p-revealed-container {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 3px;
        margin-top: 6px;
        width: 140px; /* ボックス幅に合わせる */
    }
    .mini-card {
        width: 24px; height: 36px; /* 18x26 -> 24x36 に拡大 */
        border-radius: 4px;
        background: #fff;
        color: #333;
        font-size: 14px; /* 数字も読みやすく */
        font-weight: bold;
        line-height: 36px;
        text-align: center;
        border: 1px solid #999;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }
    /* 0のカード */
    /*.mini-card[data-val="0"] { border: 1px solid #ab47bc; color: #8e24aa; background: #f3e5f5; }*/

    /* --- その他微調整 --- */
    /* 自分エリアが隠れないようにマージン確保 */
    /* 中央フィールド（ゾーン分けレイアウト修正） */
    #field-center {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between; /* 上下に要素を分散 */
        
        background: rgba(0,0,0,0.2);
        border-radius: 20px;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        
        padding: 5px;
        margin: 0 5px;
        z-index: 1;
    }
    /* --- ゾーン分けデザイン --- */
    
    /* インジケーター（少し小さく） */
    /* インジケーター（画像を大きく強調） */
    #indicator { 
        width: auto;           /* 横幅いっぱいに広げる */
        height: auto;         /* 高さは自動で合わせる */
        max-height: 60px;     /* 大きくなりすぎないように制限 */
        object-fit: contain;  /* 画像全体が収まるように */
        
        border-radius: 8px;   /* 角を丸く */
        
        /* 立体感を出す影と、少しの発光 */
        box-shadow: 0 5px 15px rgba(0,0,0,0.6);
        filter: drop-shadow(0 0 2px rgba(255,255,255,0.3));
        
        margin-bottom: 10px;  /* 下との隙間を確保 */
        display: block;       /* ブロック要素にして中央寄せ */
        margin-left: auto;
        margin-right: auto;
    }

    /* 左右のゾーンをまとめるコンテナ */
    .field-zone-container {
        display: flex;
        justify-content: center;
        gap: 8px; /* ゾーン間の隙間 */
        width: 100%;
        flex: 1; /* 高さいっぱいに広げる */
    }

    /* 個別ゾーンの枠 */
    .field-zone {
        flex: 1; /* 左右均等 */
        border-radius: 12px;
        padding: 5px 2px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        border: 1px solid rgba(255,255,255,0.15);
        position: relative;
    }

    /* 数字ゾーン (青系) */
    .zone-num {
        background: rgba(33, 150, 243, 0.1); 
        border-color: rgba(33, 150, 243, 0.3);
    }
    /* 記号ゾーン (赤系) */
    .zone-sym {
        background: rgba(244, 67, 54, 0.1); 
        border-color: rgba(244, 67, 54, 0.3);
    }

    /* ラベル (NUMBER / SYMBOL) */
    .zone-label {
        font-size: 12px;
        font-weight: bold;
        letter-spacing: 1px;
        margin-bottom: 2px;
        opacity: 0.6;
    }

    /* 墓地スロット (少し縮小) */
    .grave-slot {
        transform: scale(0.9); 
        margin-bottom: auto; /* 山札を下に押しやる */
    }

    /* 山札エリア (アイコン化) */
    .deck-slot {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        background: rgba(0,0,0,0.25);
        padding: 4px 10px;
        border-radius: 15px;
        margin-bottom: 5px;
        cursor: default;
    }

    /* 山札アイコン (CSSでカード裏面を表現) */
    .deck-icon {
        width: 12px; height: 18px;
        border-radius: 2px;
        border: 1px solid #fff;
    }
    .deck-icon.num { background: repeating-linear-gradient(45deg, #1565c0, #1565c0 2px, #0d47a1 2px, #0d47a1 4px); }
    .deck-icon.sym { background: repeating-linear-gradient(45deg, #c62828, #c62828 2px, #b71c1c 2px, #b71c1c 4px); }

    /* 山札の数字 */
    .deck-count {
        font-size: 16px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 1px 2px #000;
    }

    /* 除外エリア (ゴミ箱) */
    #exclusion-area {
        margin-top: 2px;
        font-size: 11px;
        opacity: 0.8;
        cursor: pointer;
        background: rgba(0,0,0,0.3);
        padding: 3px 12px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        gap: 5px;
        transition: 0.2s;
    }
    #exclusion-area:hover { opacity: 1; background: rgba(0,0,0,0.5); }

    /* 残り枚数バッジも大きく */
    .p-count-badge {
        width: 24px; height: 24px;
        line-height: 24px;
        font-size: 14px;
        top: -10px; left: -10px;
    }

    /* フィールド調整 */
    #graveyard-container { display: flex; gap: 15px; align-items: center; }
    .grave-box { text-align: center; cursor: pointer; transition: transform 0.1s; }
    .grave-box:active { transform: scale(0.95); }
    .grave-label { font-size: 10px; color: #ccc; }

    /* ログエリア */
    #game-log-bar { 
        position: fixed; bottom: 0; left: 0; width: 100%; height: 35px; 
        background: rgba(33, 33, 33, 0.95); font-size: 13px; line-height: 35px; 
        text-align: left; padding-left: 15px; overflow: hidden; white-space: nowrap; 
        z-index: 50; cursor: pointer; border-top: 1px solid #555; box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
    }
    
    /* 通知アニメーション */
    @keyframes flash-notify {
        0% { background-color: #ff9800; transform: scale(1); }
        50% { background-color: #f57c00; transform: scale(1.1); }
        100% { background-color: #ff9800; transform: scale(1); }
    }
    .notify-active { animation: flash-notify 1s infinite; border: 2px solid #fff !important; }
    .notify-bar { background-color: #ff9800 !important; color: white !important; font-weight: bold; }

    /* モーダル */
    #modal-overlay {
        position: fixed; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.6); z-index: 999;
        backdrop-filter: blur(3px); /* 背景をぼかす */
        display: flex; justify-content: center; align-items: center;
        animation: fadeIn 0.2s ease;
        transition: background 0.2s, backdrop-filter 0.2s;
    }
    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }

    #modal-overlay.board-visible {
        background: rgba(0,0,0,0.05);
        backdrop-filter: none;
    }

    #modal-box {
        background: #fff; color: #333; padding: 25px; border-radius: 12px;
        max-width: 90%; max-height: 80%; width: 400px;
        overflow-y: auto; text-align: center; display:flex; flex-direction:column;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        border: 2px solid transparent;
        transition: background 0.2s, opacity 0.2s, box-shadow 0.2s, border-color 0.2s;
    }
    #modal-overlay.board-visible #modal-box {
        background: rgba(255,255,255,0.2);
        border-color: rgba(255,255,255,0.95);
        box-shadow: 0 4px 14px rgba(0,0,0,0.25);
        opacity: 0.4;
    }
    #modal-content { margin-bottom: 20px; flex: 1; overflow-y: auto; }
    .modal-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .modal-btn { margin: 5px; padding: 10px 20px; background: #e0e0e0; border:none; border-radius: 5px; cursor: pointer; font-size:14px; transition:0.2s; }
    .modal-btn:hover { background: #d5d5d5; }
    .modal-btn.primary { background: #fdd835; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .modal-btn.danger { background: #ef5350; color: white; font-weight: bold; }

    /* ログスタイル */
    .log-entry { text-align: left; padding: 8px; border-bottom: 1px solid #eee; font-size: 13px; display: flex; align-items: flex-start; }
    .log-time { color: #888; margin-right: 10px; font-size: 11px; min-width: 45px; }
    .log-text { word-break: break-all; line-height: 1.4; }
    .log-private .log-text { color: #d32f2f; font-weight: bold; background: #ffebee; padding: 2px 5px; border-radius: 4px;}
    .log-chat { background: #f1f8e9; }
    
    /* チャット入力 */
    #chat-input-container { display: flex; gap: 8px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #ccc; }
    #chat-input {color: black; flex: 1; padding: 10px; border-radius: 20px; border: 1px solid #ccc; outline:none; }
    #chat-send-btn { background: #43a047; color: white; border-radius: 20px; padding: 0 20px; }

    .host-settings { margin-bottom: 15px; font-size: 14px; text-align: left; background: rgba(0,0,0,0.1); padding: 10px; border-radius: 8px; }
    .host-settings label { margin-right: 15px; cursor: pointer; display: inline-block; padding: 5px; }
/* --- 追加修正: 墓地カードのはみ出し防止 --- */
    
    /* 墓地（pile）の中にあるカードは余白と影をなくす */
    .pile .card {
        margin: 0; 
        box-shadow: none; /* 埋まっている感じにするため影も消す */
        width: 100%; /* 枠いっぱいに広げる */
        height: 100%;
        border: none; /* 枠線もpile側に任せて消す */
        border-radius: 6px; /* 角丸を合わせる */
    }
    
    /* 墓地のカードはホバーしても浮き上がらないようにする */
    .pile:hover .card {
        transform: none; 
    }

    /* --- 役職パネルのデザイン --- */
    #my-role-panel {
        margin: 10px 0;
        display: flex;
        justify-content: center;
    }

    .role-card {
        background: linear-gradient(135deg, #6a1b9a, #4a148c); /* 紫系の高貴な色 */
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        border: 1px solid #e1bee7;
        box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        text-align: center;
        width: 100%;
        max-width: 300px;
        position: relative;
        overflow: hidden;
    }
    
    /* 背景にうっすら装飾 */
    .role-card::before {
        content: 'ROLE';
        position: absolute;
        top: -10px; right: -10px;
        font-size: 50px;
        color: rgba(255,255,255,0.05);
        font-weight: bold;
        transform: rotate(15deg);
    }

    .role-name {
        font-family: 'Arial Black', sans-serif;
        font-size: 16px;
        letter-spacing: 1px;
        color: #dc94e9;
        text-transform: uppercase;
    }
    
    .role-jp {
        font-size: 20px;
        font-weight: bold;
        margin: 2px 0;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .role-desc {
        font-size: 11px;
        color: #c0a4ef;
        border-top: 1px solid rgba(255,255,255,0.3);
        margin-top: 5px;
        padding-top: 4px;
    }
    /* --- カットインアニメーション用CSS --- */
    #cut-in-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7); /* 背景を少し暗くする */
        z-index: 9999; /* 最前面に表示 */
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: none; /* アニメーション中も裏の操作を阻害しないならnone、邪魔するならauto */
        opacity: 0; /* 初期状態は透明 */
        transition: opacity 0.3s;
    }

    /* JavaScriptで hidden が外れたら表示（opacityはanimate-cut-inで制御してもよいが、ベースを表示にする） */
    #cut-in-overlay:not(.hidden) {
        opacity: 1;
    }

    #cut-in-content {
        text-align: center;
        color: #ffeb3b;
        font-family: 'Arial Black', sans-serif;
        text-shadow: 0 0 10px #ff9800;
        transform: scale(0); /* 最初は小さく */
    }

    /* アニメーションクラスが付与されたときの動作 */
    .animate-cut-in #cut-in-content {
        animation: cutInZoom 2.5s ease-out forwards;
    }

    /* 動きの定義 */
    @keyframes cutInZoom {
        0% { transform: scale(0) rotate(-10deg); opacity: 0; }
        20% { transform: scale(1.2) rotate(0deg); opacity: 1; }
        30% { transform: scale(1.0); }
        80% { transform: scale(1.0); opacity: 1; }
        100% { transform: scale(1.5); opacity: 0; }
    }
    
    /* 役職名：ゴールドのグラデーションで高級感を出す */
    #cut-in-role { 
        font-size: 50px; 
        font-weight: 900;
        margin-bottom: 5px; 
        
        /* 金色のグラデーション文字 */
        background: linear-gradient(to bottom, #fff 0%, #ffd700 50%, #bf953f 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        
        /* 影をつけて浮き上がらせる */
        filter: drop-shadow(0 4px 0px rgba(0,0,0,0.5));
        
        /* 少し斜体にしてスピード感を出す */
        font-style: italic;
        letter-spacing: 2px;
    }
    /* プレイヤー名：白文字でシンプルに */
    #cut-in-player { 
        font-size: 20px; 
        color: #ddd; 
        margin-bottom: 15px;
        letter-spacing: 1px;
        font-weight: bold;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }

    /* ▼▼▼ クッキリ・読みやすい版 ▼▼▼ */
    #cut-in-text { 
        font-family: 'Impact', 'Arial Black', sans-serif;
        font-weight: 900;
        font-size: 60px; /* 少し大きくして視認性UP */
        
        font-style: italic;
        letter-spacing: 0.1em;
        transform: skewX(-15deg);

        /* グラデーション：白を多めにして明るくクッキリさせる */
        background: linear-gradient(to bottom, #ffffff 45%, #cfd8dc 50%, #78909c 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;

        /* ★ここがポイント：filterではなく「線」で縁取りする */
        /* これにより文字の輪郭がバシッと決まります */
        -webkit-text-stroke: 2px #000;

        /* 影：ぼかし(px)を0にして、パキッとした影を落とす */
        filter: drop-shadow(4px 4px 0px rgba(0, 0, 0, 0.8));
            
        margin-top: 10px;
        white-space: nowrap;
        
        /* 隠し味：少しだけ光らせたい場合は以下をコメントアウト解除 */
        /* text-shadow: 0 0 10px rgba(255,255,255,0.5); */
    }
    

    /* ▼▼▼ 追加：皇帝パネル用の輝きアニメーション ▼▼▼ */
    @keyframes goldShine {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    @keyframes goldPulse {
        0% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
        100% { box-shadow: 0 0 30px rgba(255, 215, 0, 1.0), 0 0 10px #fff; }
    }
    
    /* --- Hacked Corner (旧スタイルは削除または無視) --- */
    /* 代わりに以下を追加 */

    /* ロックされたカードのデザイン */
    .card.locked {
        /* 通常カードと同じサイズ・配置 */
        filter: grayscale(0.9) brightness(0.6); /* モノクロにして暗くする */
        border: 2px dashed #ff1744 !important;   /* 赤枠で危険を示す */
        cursor: not-allowed;
        position: relative;
    }

    /* 右下に鍵アイコンを表示（カードの絵柄を隠さない）⇐削除済み

    /* ホバーしても浮き上がらせない */
    .card.locked:hover {
        transform: none !important;
        box-shadow: none !important;
    }

    /* 警察による公開カードのデザイン */
    .card.revealed {
        /* 青色の枠線で「警察」感を出す */
        border: 3px solid #fdd835 !important;
        box-shadow: 0 0 10px rgba(246, 246, 41, 0.6); 
        position: relative; /* 帯の配置用 */
        overflow: hidden;   /* 帯がはみ出さないように */
    }

    /* 右上の「OPEN」帯 */
    .card.revealed::after {
        content: "OPEN";
        position: absolute;
        top: 5px;
        right: -22px;
        width: 80px;
        height: 18px;
        background: #fdd835; /* 警告色（黄色） */
        color: #000;
        font-size: 10px;
        font-weight: bold;
        text-align: center;
        line-height: 18px;
        transform: rotate(45deg); /* 斜めに配置 */
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        z-index: 20;
        pointer-events: none; /* クリックの邪魔をしない */
        font-family: 'Arial Black', sans-serif;
    }

    /* --- スマホ・細い画面用のスリムレイアウト --- */
    @media (max-width: 600px) {
        /* 1. 左右のカラム幅を詰める */
        .player-zone.col {
            width: 105px !important; /* ボックス幅に合わせて最小限に */
            z-index: 20;
        }

        /* 2. ボックスをスリム化 */
        .player-zone.col .p-box-new {
            width: 100px !important; /* 140px -> 100px に細くする */
            height: auto !important;    /* 固定をやめて自動に */
            min-height: 180px;          /* 最低でもこの高さを確保 */
            padding-bottom: 5px;        /* 下端の余白 */ 
        }

        /* 3. 中段（手札数とステータス）を縦積みに */
        .player-zone.col .p-box-new .p-body {
            flex-direction: column; /* 縦並び */
            justify-content: center;
            gap: 8px; /* 詰める */
            padding: 5px 0;
            flex: 1;         /* 余ったスペースを埋める */
        }
        
        /* ステータス表示の位置調整 */
        .player-zone.col .p-box-new .p-status-area {
            align-items: center; /* 中央揃え */
            width: 100%;
        }

        /* 4. 下段（役職）のエリア高さを自動調整 */
        .player-zone.col .p-box-new .p-role-row {
            height: auto !important; /* 固定高さを解除 */
            min-height: 40px;        /* 最低限の高さ確保 */
            padding: 5px 0;
            display: flex;
            align-items: center;     /* 上下中央寄せ */
            justify-content: center;
            margin-top: auto; /* 一番下に押し下げる */
        }

        /* 役職バッジの中身を折り返し（縦積み）にする */
        .player-zone.col .p-box-new .role-badge-pill {
            flex-direction: column; /* 縦並び */
            width: 96%;             /* 幅いっぱい */
            padding: 4px 0;
            line-height: 1.2;
            border-radius: 8px;     /* 角丸を少し緩める */
        }
        
        /* 役職の補足（REVERSEなど）のデザイン調整 */
        .player-zone.col .p-box-new .role-sub {
            display: block;        /* 改行させる */
            margin-left: 0;
            margin-top: 3px;
            font-size: 9px;        /* 少し小さく */
            opacity: 0.9;
        }

        /* 公開カード置き場も幅を合わせる */
        .player-zone.col .p-revealed-container {
            width: 100px !important;
        }
        
        /* 中央フィールドとの隙間を詰める */
        #field-center {
            margin: 0 !important;
        }
        #area-middle {
            gap: 2px !important; /* 左右ボックスとの隙間を最小限に */
        }

    }

    /* --- 追加: 公開カード情報（テキスト表示用） --- */
        .p-revealed-info {
            font-size: 11px;
            margin-top: 5px;     /* ステータスとの隙間 */
            white-space: nowrap; /* 折り返しなし */
            line-height: 1.2;
            /* ★ここが重要: ゲーム全体のフォント(M PLUS Rounded 1c)を強制する */
            font-family: "M PLUS Rounded 1c", "Rounded Mplus 1c", sans-serif !important;
        }

        /* 何も公開されていない時 (NORMAL表示と同じような色に) */
        .revealed-none {
            color: #546e7a;      /* 薄いグレー */
            font-weight: bold;
        }

        /* 公開されている時 (目立たせる) */
        .revealed-active {
            color: #ffeb3b;      /* 黄色 */
            font-weight: bold;
        }
        
        /* 元々の画像表示エリアは完全に非表示にする */
        .p-revealed-container {
            display: none !important;
        }
        
        /* スマホ表示の微調整 */
        @media (max-width: 600px) {
            .p-revealed-info {
                font-size: 10px;
            }
        }

        /* --- 点滅アニメーション定義 --- */
        @keyframes blink-text {
            0% { opacity: 1.0; transform: scale(1.0); }
            50% { opacity: 0.5; transform: scale(1.05); } /* 半透明になりつつ少し大きくなる */
            100% { opacity: 1.0; transform: scale(1.0); }
        }
        /* --- チャット吹き出し (Chat Bubble) --- */
    .chat-bubble {
        position: absolute;
        background: #fff;
        color: #000;
        font-size: 11px;
        font-weight: bold;
        padding: 6px 10px;
        border-radius: 12px;
        max-width: 240px;       /* 長文は省略 */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        opacity: 0;             /* 最初は隠す */
        pointer-events: none;   /* クリックの邪魔をしない */
        z-index: 500;           /* カードより手前 */
        transition: opacity 0.2s;
    }

    /* 吹き出しのしっぽ (共通) */
    .chat-bubble::after {
        content: "";
        position: absolute;
        border-style: solid;
        display: block;
    }

    /* アニメーションクラス */
    .chat-bubble.active {
        animation: bubble-pop 4s ease-out forwards;
    }

    @keyframes bubble-pop {
        0% { opacity: 0; transform: scale(0.5); }
        10% { opacity: 1; transform: scale(1); }
        85% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0.8); }
    }

    /* --- 位置別のスタイル (画面内側に向くように配置) --- */

    /* 1. 自分 (下部配置) -> 吹き出しは「上」に出す */
    .bubble-pos-bottom {
        bottom: 110%; /* 箱の上に */
        left: 50%;
        transform: translateX(-50%);
    }
    .bubble-pos-bottom::after {
        bottom: -6px; left: 50%; margin-left: -6px;
        border-width: 6px 6px 0;
        border-color: #fff transparent;
    }

    /* 2. 上の人 (上部配置) -> 吹き出しは「下」に出す */
    .bubble-pos-top {
        top: 100%;    /* 箱の下に */
        left: 0;
        margin-top: 10px;
        transform: none;
    }
    .bubble-pos-top::after {
        top: -6px; left: 50%; margin-left: -6px;
        border-width: 0 6px 6px;
        border-color: #fff transparent;
    }

    /* 3. 左の人 -> 吹き出しは「右」に出す */
    .bubble-pos-left {
        top: auto;
        bottom: 100%; /* ボックスの上に */
        
        /* 左端をボックスに合わせる */
        left: 0;
        right: auto;
        
        /* 隙間調整 */
        margin-bottom: 10px; 
        margin-left: 0;
        margin-right: 0;
        
        transform: none;
    }
    .bubble-pos-left::after {
        top: 50%; right: 100%; margin-top: -6px;
        border-width: 6px 6px 6px 0;
        border-color: transparent #fff;
    }

    /* 4. 右の人 -> 吹き出しは「左」に出す */
    .bubble-pos-right {
        /* 上に出す設定(bottom)を解除し、下(top: 100%)に出す */
        top: 100%;
        bottom: auto;
        
        /* 左端をボックスに合わせる */
        left: auto;
        right: 0;
        
        /* 隙間調整 (上側にマージンを入れる) */
        margin-top: 10px; 
        margin-bottom: 0;
        margin-left: 0;
        margin-right: 0;
        
        transform: none;
    }
    .bubble-pos-right::after {
        top: 50%; left: 100%; margin-top: -6px;
        border-width: 6px 0 6px 6px;
        border-color: transparent #fff;
    }

    /* スマホ調整: 左右の人が画面端すぎる場合、少し内側に寄せる微調整 */
    @media (max-width: 600px) {
        .chat-bubble { max-width: 90px; font-size: 10px; }
    }



</style>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
</head>
<body>

    <div id="login-screen">
        <img src="./images/logo.png" alt="SEKI Online" id="title-logo">
        <p class="version-text">Ver 23.00 カウンティングに行こう！</p>
        <input type="text" id="roomName" placeholder="合言葉 (例: seki123)">
        <br>
        <input type="text" id="playerName" placeholder="あなたの名前">
        <br><br>
        <button id="btn-join" onclick="joinGame()">部屋に入る / 作る</button>
    </div>

    <div id="game-screen" class="hidden">
        <div id="header-info" style="display:flex; justify-content:space-between; align-items:center; padding:0 10px; font-size:12px; height:40px;">
            <div id="room-display"></div>
            <div style="display:flex; gap:10px; align-items:center;">
                <button id="btn-host-settings" class="hidden" onclick="openHostSettings()" 
                    style="padding:5px 12px; font-size:15px; background:#1565c0; color:white; border:1px solid rgba(255,255,255,0.3); border-radius:20px; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.3); display:flex; align-items:center;">
                    ⚙️
                </button>
                <button onclick="showScoreboard()" style="padding:2px 8px; font-size:15px; background:#fbc02d; color:#3e2723; border-radius:15px; border:1px solid rgba(255,255,255,0.3); margin-right:2px;">🏆</button>
                <button onclick="showRoleList()" style="padding:2px 8px; font-size:15px; background:#6a1b9a; color:white; border-radius:15px; border:1px solid rgba(255,255,255,0.3);">役職</button>
                <button onclick="showRule()" style="padding:2px 8px; font-size:15px; ">ルール</button>
                <button id="btn-bgm-toggle" onclick="toggleBgmMute()" style="padding:2px 8px; font-size:15px;">🔊</button>
                <button onclick="leaveRoom()" style="padding:2px 8px; font-size:15px;">🚪</button>
            </div>
        </div>

        <div id="game-table">
            
            <div id="area-top" class="player-zone row"></div>

            <div id="area-middle">
                <div id="area-left" class="player-zone col"></div>

                <div id="field-center">
                    <img id="indicator" src="./images/reverse_blue.jpg" alt="順行/逆行">
                    
                    <div class="field-zone-container">
                        
                        <div class="field-zone zone-num">
                            <div class="zone-label">数字墓地</div>
                            
                            <div class="grave-slot" onclick="viewGrave('num')">
                                <div id="graveNum" class="pile"></div>
                            </div>
                            
                            <div class="deck-slot">
                                <div class="deck-icon num"></div>
                                <div id="deckNumCount" class="deck-count">-</div>
                            </div>
                        </div>

                        <div class="field-zone zone-sym">
                            <div class="zone-label">記号墓地</div>
                            
                            <div class="grave-slot" onclick="viewGrave('sym')">
                                <div id="graveSym" class="pile"></div>
                            </div>
                            
                            <div class="deck-slot">
                                <div class="deck-icon sym"></div>
                                <div id="deckSymCount" class="deck-count">-</div>
                            </div>
                        </div>
                    </div>

                    <div id="exclusion-area" onclick="viewGrave('excl')">
                        <span>🗑️除外：</span>
                        <span id="exclusion-count">0</span>
                    </div>
                    
                    <div id="msg" style="margin-top:2px; color:#ffeb3b; font-weight:bold; font-size:12px; height:18px; line-height:18px; white-space:nowrap;">待機中...</div>
                </div>

                <div id="area-right" class="player-zone col"></div>
            </div>

            <div id="my-area">
                <div id="my-name-bar" class="my-name-plate"></div>
            
                <div id="my-hand"></div>
                <div id="controls" style="margin-top:5px;">
                    <button id="btn-play" onclick="playCard()">決定</button>
                    <button id="btn-pass" onclick="passTurn()" style="background:#546e7a; color:white;">パス</button>
                </div>

                <div id="my-role-panel"></div>

            </div>
        </div>
    </div>

    <div id="game-log-bar" onclick="showLogHistory()">ログを読み込み中...</div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-box">
            <h3 id="modal-title">タイトル</h3>
            <div id="modal-content">内容</div>
            <div id="modal-footer">
                <button onclick="closeModal()" style="background:#90a4ae">閉じる</button>
            </div>
        </div>
    </div>

    <div id="cut-in-overlay" class="hidden">
        <div id="cut-in-bg"></div>
        <div id="cut-in-content">
            <div id="cut-in-role">ROLE NAME</div>
            <div id="cut-in-player">Player Name</div>
            <div id="cut-in-text">SKILL ACTIVATED!</div>
        </div>
    </div>

    <div id="visual-overlay" style="
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 9999;
    display: none; flex-direction: column; justify-content: center; align-items: center;
    color: white; font-family: 'Arial Black', sans-serif; pointer-events: none;
">
    <div id="squeeze-guess" style="
        position: absolute; top: 10%; 
        font-size: 24px; color: #ffeb3b; text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
    "></div>

    <div style="position: relative; width: 200px; height: 300px; border: 4px solid #fff; border-radius: 10px; overflow: hidden; background: #fff;">
        
        <div id="squeeze-content" style="
            width: 100%; height: 100%; 
            display: flex; justify-content: center; align-items: center;
            font-size: 150px; color: #333; font-weight: bold;
        ">?</div>

        <div id="squeeze-cover" style="
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(45deg, #1a237e, #1a237e 10px, #283593 10px, #283593 20px);
            transition: top 5s ease-in-out; /* 5秒かけてじわじわ動く */
        ">
            <div style="color:rgba(255,255,255,0.2); font-size:50px; text-align:center; padding-top:100px;">SEKI</div>
        </div>
    </div>

    <div id="squeeze-result" style="
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
        font-size: 80px; font-weight: bold; text-shadow: 2px 2px 0 #000;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        opacity: 0;
    "></div>
</div>

    <script>
        // エラー抑制
        window.onerror = function(msg) { 
            // execPassResetのエラー無視行を削除しました
            showInfoModal("システムエラー", msg); 
        };

        const CARD_IMAGES = {
            "TRADE": "./images/trade.png",
            "DIG UP": "./images/dig up.png",
            "DISCARD": "./images/discard.png",
            "REVERSE": "./images/reverse.png",
        };

        // 役職画像の定義（ここに追加していく）
        const ROLE_IMAGES = {
        "ANGLER": "./images/angler.png",
        "FORTUNE TELLER": "./images/fortuneteller.png",
        "THIEF": "./images/thief.png",
        "HUNTER": "./images/hunter.png",
        "GAMBLER": "./images/gambler.png",
        "CROWN": "./images/crown.png",
        "MILLIONAIRE": "./images/millionaire.png",
        "EMPEROR": "./images/emperor.png",
        "HACKER": "./images/hacker.png",
        "POLICE OFFICER": "./images/policeofficer.png",
        "ALCHEMIST": "./images/alchemist.png",
        "NECROMANCER": "./images/necromancer.png",
        "AGENT": "./images/agent.png",
        //他もあれば追加
        };

        /* --- 音声ファイルの登録 --- */
        const SOUND_FILES = {
            // 賭博師用
            'DRUM': './sounds/drum.mp3',         // ドラムロール
            'WIN_NORMAL': './sounds/win.mp3',    // 普通の当たり
            'WIN_BIG': './sounds/win_big.mp3',   // 大当たり！
            'LOSE': './sounds/lose.mp3',          // 負け...
            // BGM
            'BGM_LOBBY': './sounds/bgm_lobby.mp3',
            'BGM_BATTLE': './sounds/bgm_battle.mp3',
            // システム通知
            'turn':    './sounds/turn.mp3',  // 自分の番
            'chat':    './sounds/chat.mp3',  // チャット受信
            'WARNING': './sounds/warning.mp3', // トレードの被害
            'DOS': './sounds/dos.mp3',
            'UNO': './sounds/uno.mp3',
            // 順位決定音
            'RANK_1':     './sounds/winner.mp3',  // 1位
            'RANK_2_3':   './sounds/normal.mp3',  // 2位・3位
            'RANK_4':     './sounds/loser.mp3',  // 4位（最下位）

            // カードアクション
            'PUT':     './sounds/put.mp3',
            'REVERSE': './sounds/reverse.mp3',
            'TRADE':   './sounds/trade.mp3',
            'DIG UP':  './sounds/digup.mp3',
            'DISCARD': './sounds/discard.mp3',
            // 役職発動音
            'SKILL': './sounds/skill_default.mp3',
            'SKILL_ANGLER': "./sounds/skill_angler.mp3",
            'SKILL_FORTUNE TELLER': "./sounds/skill_fortuneteller.mp3",
            'SKILL_THIEF': "./sounds/skill_thief.mp3",
            'SKILL_HUNTER': "./sounds/skill_hunter.mp3",
            'SKILL_GAMBLER': "./sounds/skill_gambler.mp3",
            'SKILL_CROWN': "./sounds/skill_crown.mp3",
            'SKILL_MILLIONAIRE': "./sounds/skill_millionaire.mp3",
            'SKILL_EMPEROR': "./sounds/skill_emperor.mp3",
            'SKILL_HACKER': "./sounds/skill_hacker.mp3",
            'SKILL_POLICE OFFICER': "./sounds/skill_policeofficer.mp3",
            'SKILL_ALCHEMIST': "./sounds/skill_alchemist.mp3",
            'SKILL_NECROMANCER': "./sounds/skill_necromancer.mp3",
            'SKILL_AGENT': "./sounds/skill_agent.mp3",
        };
        
        /* ===============================================
           iPhone対応版 音声システム (Web Audio API)
           =============================================== */
        
        // 1. オーディオシステムの本体
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // 2. 読み込んだ音声データを貯めておく場所
        const audioBuffers = {};

        // 3. BGM管理用
        let bgmSource = null;
        let bgmGainNode = null;
        let isBgmMuted = false;
        let currentBgmType = null;

        // 音声ファイルをロードしてデコードする関数
        async function loadSound(key) {
            // すでに読み込み済みなら何もしない
            if (audioBuffers[key]) return audioBuffers[key];

            const url = SOUND_FILES[key];
            if (!url) return null;

            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const decodedBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                audioBuffers[key] = decodedBuffer;
                return decodedBuffer;
            } catch (e) {
                console.warn(`音声読み込み失敗: ${key}`, e);
                return null;
            }
        }

        /* --- 修正: 定義されているすべての音をプリロードする --- */
        // SOUND_FILES にあるキーをすべて取得して、順番に読み込みを開始する
        Object.keys(SOUND_FILES).forEach(key => {
            loadSound(key);
        });

        /* --- 再生関数 (効果音用) --- */
        async function playSoundEffect(type) {
            // 1. コンテキストが無効なら再開を試みる
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // 2. データを取得 (なければ今ロードする)
            let buffer = audioBuffers[type];
            if (!buffer) {
                buffer = await loadSound(type);
                if (!buffer) return;
            }

            // 3. 音源作成
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;

            // 4. 音量調整 (iPhoneでも効きます)
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.6; // 効果音の音量 (0.0〜1.0)

            // 5. 接続: Source -> Gain -> Speaker
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // 6. 再生
            source.start(0);
        }

        /* --- BGM再生関数 (音量調整対応) --- */
        async function playBgm(type) {
            // 同じ曲なら何もしない
            if (currentBgmType === type && bgmSource) return;

            // 前の曲を止める
            stopBgm();

            if (isBgmMuted) {
                currentBgmType = type; // タイプだけ覚えておく（ミュート解除時に再生するため）
                return; 
            }

            // データを準備
            let buffer = audioBuffers[type];
            if (!buffer) {
                buffer = await loadSound(type);
                if (!buffer) return;
            }

            // BGM用ソース作成
            bgmSource = audioCtx.createBufferSource();
            bgmSource.buffer = buffer;
            bgmSource.loop = true;

            // BGM用音量ノード
            bgmGainNode = audioCtx.createGain();
            // ★ここが重要: iPhone用にBGMをかなり小さく設定 (0.05くらいが丁度いいことが多い)
            bgmGainNode.gain.value = 0.05; 

            // 接続
            bgmSource.connect(bgmGainNode);
            bgmGainNode.connect(audioCtx.destination);

            // 再生
            bgmSource.start(0);
            currentBgmType = type;
        }

        function stopBgm() {
            if (bgmSource) {
                try { bgmSource.stop(); } catch(e){}
                bgmSource = null;
            }
            bgmGainNode = null;
            currentBgmType = null;
        }

        function toggleBgmMute() {
            isBgmMuted = !isBgmMuted;
            const btn = document.getElementById('btn-bgm-toggle');
            
            if (isBgmMuted) {
                btn.innerText = "🔇";
                stopBgm(); // 停止
                // タイプは保持しておかないと再開できないので、stopBgmで消えた分を戻す工夫が必要ですが、
                // 簡易的に「今の状態(gameState)」を見て再判定するのが確実です。
            } else {
                btn.innerText = "🔊";
                // 再開処理
                if (gameState && gameState.status === 'playing') playBgm('BGM_BATTLE');
                else playBgm('BGM_LOBBY');
            }
        }

        /* --- iPhone用のロック解除 (サイレント版) --- */
        function unlockAudioContext() {
            // 1. システムが停止中なら再開
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            // 2. 「無音」のバッファを一瞬再生して、再生権限を獲得する
            // (実際の音声ファイルは使いません)
            const emptyBuffer = audioCtx.createBuffer(1, 1, 22050);
            const source = audioCtx.createBufferSource();
            source.buffer = emptyBuffer;
            source.connect(audioCtx.destination);
            source.start(0);

        }
                
        const firebaseConfig = {
            apiKey: "AIzaSyBvdLTIWWv_7UCucT_i0Xiy7CgbGoBWUyo",
            authDomain: "seki-online.firebaseapp.com",
            projectId: "seki-online",
            storageBucket: "seki-online.firebasestorage.app",
            messagingSenderId: "196888255072",
            appId: "1:196888255072:web:0aad0ac1ec1d82485d8105",
            measurementId: "G-NV0Q9LB87B"
        };
        
        let db;
        try {
            if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
            db = firebase.database();
        } catch(e) { alert("Firebase読込エラー: " + e.message); }

        const NUMBERS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        const SYMBOLS = ["REVERSE", "TRADE", "DIG UP", "DISCARD"];
        const SYMBOL_COUNTS = {"REVERSE":4, "TRADE":4, "DIG UP":4, "DISCARD":1};
        // 【修正】Ver 2.0準拠の役職定義
        const ROLES = [
            "ALCHEMIST", "ANGLER", "EMPEROR", "FORTUNE TELLER", 
            "GAMBLER", "HACKER", "HUNTER", "CROWN",
            "MILLIONAIRE", "POLICE OFFICER", "THIEF", "NECROMANCER", "AGENT"
        ];

        // 【追加】役職の日本語名と簡易説明（表示用）
        // 【修正】役職情報（簡易説明 + 詳細説明）
        const ROLE_INFO = {
            "ALCHEMIST": { 
                jp: "錬金術師", 
                summary: "数字山札を引き、手札と四則演算して出す",
                desc: `<ol>
<li>数字山札から、1枚カードを引く。</li>
<li>そのカードと、手札の好きな<span style="color: #3598db;"><strong>数字カード</strong></span>で、いずれかの四則演算をする。</li>
<li>その和差積商の下一桁を、数字墓地に出せるとき、出すことができる。</li>
<li>もし出せない場合は、引いたカードが手札に加わる（デメリット）。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: circle;">
<li>割り算では、大きい方&divide;小さい方になり、0除算は不可能</li>
<li>差が負の数の場合は絶対値を取る</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "ANGLER": { 
                jp: "釣り人",   
                summary: "手札1枚を除外、墓地から1枚回収",
                desc: `<ol>
<li>自分の手札から好きな<strong>カード</strong>1枚を除外する。</li>
<li>数字墓地もしくは記号墓地から、好きな<strong>カード</strong>1枚を手札に加える。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "EMPEROR": { 
                jp: "皇帝",     
                summary: "全員の手札を回収し、好きな1枚奪って残りを再配布",
                desc: `<ul style="list-style-type: square;">
<li>ゲーム開始時に自分が「皇帝」であることが他プレイヤー全員に通知される。</li>
</ul>
<ol>
<li>他プレイヤー全員の手札を回収し、見ることができる。</li>
<li>回収した手札から好きな<strong>カード</strong>を1枚選ぶ。</li>
<li>余ったカードが皇帝を含む全員に再配布される（手札の枚数は変わらない）。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "FORTUNE TELLER": { 
                jp: "占い師",   
                summary: "全員の手札と役職を見る",
                desc: `<ol>
<li>他プレイヤー全員の手札および役職を自分だけ確認することができる。</li>
<li>このとき確認した結果はログに記録され、いつでも確認することができる。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "GAMBLER": { 
                jp: "賭博師",   
                summary: "山札の数字を予想し、当たりで手札破棄、外れで手札増加",
                desc: `<ol>
<li>数字山札の一番上のカードについて，A: 小さい【1, 2, 3, 4】，B: 大きい【6, 7, 8, 9】，C: 命知らず【0, 5】の3つの組から予想する。</li>
<li>演出が入り、数字山札の1番上のカードが明らかになる。</li>
<li>結果により、手札の好きな<strong>カード</strong>を1枚or2枚捨てる、もしくは<strong><span style="color: #3598db;">数字カード</span></strong>を1枚or2枚手札に加える。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>AおよびBを予想した場合、当たったとき自分の手札から好きな<strong>カード</strong>を<strong>1枚</strong>捨て、外れたときは数字山札の一番上のカードを手札に加える。</li>
<li>Cを予想した場合， 当たったときは自分の手札から好きな<strong>カード</strong>を<strong>2枚</strong>捨て，外れたときは数字山札の一番上のカードとその下のカードを手札に加える。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "HACKER": { 
                jp: "ハッカー", 
                summary: "全員のカードを1枚だけロックする",
                desc: `<ol>
<li>ハッカーを除く他プレイヤー全員に対し、手札の<strong>カード</strong>1枚を完全にロックする。</li>
<li>自分のターンを行う。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>ロックされたカードは、<span style="color: #e03e2d;"><strong>記号カード</strong></span>や<span style="color: #843fa1;"><strong>役職能力</strong></span>などあらゆる効果の対象にならない。</li>
<li>次のハッカーのターンが来たとき、ロックの効果は解除される。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "HUNTER": { 
                jp: "狩人",     
                summary: "記号山札を見て、手札と交換する",
                desc: `<ol>
<li>記号山札を見ることができる。</li>
<li>望むなら、自分の手札から好きな<span style="color: #e03e2d;"><strong>記号カード</strong></span>を、好きな枚数だけ、記号山札から同じ枚数を交換する。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>　どのような交換を行ったかは、他のプレイヤーからは見えない。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "CROWN": {
                jp: "ピエロ",
                summary: "DISCARD以外の記号カードの効果を即座に使用",
                desc: `<ol>
<li>DISCARD以外の<span style="color: #e03e2d;"><strong>記号カード</strong></span>の効果を1つだけ即座に使用する。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "MILLIONAIRE": {
                jp: "富豪",
                summary: "数字カードを除外し、記号カードを引く",
                desc: `<ol>
<li>自分の手札の好きな<span style="color: #3598db;"><strong>数字カード</strong></span>を1枚除外する。</li>
<li>記号山札の一番上の<strong><span style="color: #e03e2d;">記号カード</span></strong>を手札に加える。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "POLICE OFFICER": { 
                jp: "警察官",   
                summary: "全員の手札を1枚公開し、望むならトレード",
                desc: `<ol>
<li>他のプレイヤー全員に対し、手札の1枚を選んで永続的に表にする。</li>
<li>望むなら、<span style="color: #e03e2d;"><strong>記号カード</strong></span>のTRADEと同じトレードを行うことができる。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>プレイヤーの手札間を移動したときも表のまま。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "THIEF": { 
                jp: "盗賊",     
                summary: "トレードを2回まで行う",
                desc: `<ol>
<li><strong><span style="color: #e03e2d;">記号カード</span></strong>のTRADEと同じトレードを2回まで行うことができる（1回で終了しても良い）。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>同じ相手を対象に行っても良い。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "NECROMANCER": {
                jp: "死霊使い",
                summary: "数字墓地の一番上を除外",
                desc: `<ol>
<li>数字墓地の一番上のカードを除外する。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "AGENT": {
                jp: "工作員",
                summary: "任意の2人の手札をランダムに1枚交換",
                desc: `<ol>
<li>自分を含む任意のプレイヤー2人を選ぶ。</li>
<li>選ばれた2人の手札から、ランダムに1枚ずつ交換する。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            }
        };

        let myId = localStorage.getItem("seki_uid_v2");
        if (!myId) {
            myId = Date.now().toString() + "_" + Math.random().toString(36).substr(2, 5);
            localStorage.setItem("seki_uid_v2", myId);
        }
        
        let prevHandCounts = {}; // 手札枚数の記録用（SE再生に使用）
        const audioCache = {};
        // ★追加: ホスト設定の前回値を覚えておく変数
        let lastHostHandMode = 6;

        let currentRoom = null;
        let myName = "";
        let selectedIdx = -1;
        let gameState = null;
        let drawnCardTemp = null;
        let wasMyTurn = false;
        let hasFinished = false;
        let joined = false;
        let lastReadLogTime = 0; // チャット既読用
        let prevActivatedList = {}; // 前回の発動状況を記録する
        let prevRevealedRoles = {}; // カミングアウト状況を記録する
    
        let prevSoundId = 0;
        let lastGraveNumCount = -1; // 前回の数字墓地の枚数
        let lastGraveSymCount = -1; // 前回の記号墓地の枚数
        // ★追加: ハッカー解除制御用の変数
        let lastCleanupTurnIdx = -1;
        let myRankPlayed = false; // ★追加: 順位決定音が再生済みかどうかのフラグ
        let lastChatTimeProcessed = 0; // ★追加: チャット吹き出し用
        

        const els = {
            login: document.getElementById("login-screen"),
            game: document.getElementById("game-screen"),
            roomName: document.getElementById("roomName"),
            playerName: document.getElementById("playerName"),
            hand: document.getElementById("my-hand"),
            indicator: document.getElementById("indicator"),
            graveNum: document.getElementById("graveNum"),
            graveSym: document.getElementById("graveSym"),
            others: document.getElementById("other-players"),
            msg: document.getElementById("msg"),
            hostCtrl: document.getElementById("host-controls"),
            log: document.getElementById("game-log-bar"),
            modal: document.getElementById("modal-overlay"),
            mTitle: document.getElementById("modal-title"),
            mContent: document.getElementById("modal-content"),
            deckNum: document.getElementById("deckNumCount"),
            deckSym: document.getElementById("deckSymCount"),
            mFooter: document.getElementById("modal-footer"),
            btnJoin: document.getElementById("btn-join"),
            btnChat: document.getElementById("btn-chat-icon")
        };

        // --- モーダル関数 ---
        function openModal(title, html) {
            els.mTitle.innerText = title;
            els.mContent.innerHTML = html;
            els.mFooter.innerHTML = '<button onclick="closeModal()" class="modal-btn">閉じる</button>';
            els.modal.classList.remove("hidden");

            // ★追加: 毎回デフォルト幅(400px)に戻す
            // これがないと、一度広げた後に他のモーダルを開いても広いままになってしまいます
            const mBox = document.getElementById("modal-box");
            if(mBox) {
                mBox.style.width = "400px";
                mBox.style.maxWidth = "90%";
            }
        }
        function showInfoModal(title, msg) {
            els.mTitle.innerText = title;
            els.mContent.innerHTML = `<p>${msg}</p>`;
            els.mFooter.innerHTML = '<button onclick="closeModal()" class="modal-btn primary">OK</button>';
            els.modal.classList.remove("hidden");
        }
        function showConfirmModal(title, msg, yesCallbackStr) {
            els.mTitle.innerText = title;
            els.mContent.innerHTML = `<p>${msg}</p>`;
            els.mFooter.innerHTML = `
                <button onclick="${yesCallbackStr}; closeModal()" class="modal-btn primary">はい</button>
                <button onclick="closeModal()" class="modal-btn">いいえ</button>
            `;
            els.modal.classList.remove("hidden");
        }
        function closeModal() { els.modal.classList.add("hidden"); }

        function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); }
        function sortCards(hand) {
            if(!hand) return [];
            hand.sort((a,b) => {
                if(a.type !== b.type) return a.type === 'num' ? -1 : 1;
                if(a.type === 'num') return a.val - b.val;
                const sOrder = ["REVERSE", "TRADE", "DIG UP", "DISCARD"];
                return sOrder.indexOf(a.val) - sOrder.indexOf(b.val);
            });
            return hand;
        }

        // --- ログシステム & 色生成 ---
        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 70%, 40%)`;
        }

        async function pushLog(text, type='public', targetId=null) {
            if(!currentRoom) return;
            const logEntry = { text: text, type: type, targetId: targetId, timestamp: Date.now() };
            let logs = (gameState && gameState.logs) ? [...gameState.logs] : [];
            logs.push(logEntry);
            if(logs.length > 50) logs.shift(); 
            await db.ref(`rooms/${currentRoom}/logs`).set(logs);
        }

        function renderLogs(logs) {
            if(!logs || logs.length === 0) { els.log.innerText = "ログなし"; return; }
            let lastLog = logs[logs.length-1];
            
            // 最新ログ表示
            let display = "";
            for(let i=logs.length-1; i>=0; i--) {
                let l = logs[i];
                if(l.type === 'public' || l.targetId === myId || l.type === 'chat') {
                    let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit'});
                    display = `${time} ${l.text}`;
                    break;
                }
            }
            els.log.innerText = display + " (タップで履歴＆チャット)";

            // ▼▼▼ 修正箇所: チャット吹き出し表示処理 ▼▼▼
            const now = Date.now(); // 現在時刻を取得

            // ▼▼▼ 追加: チャット吹き出し表示処理 ▼▼▼
            // 今回のレンダリングでまだ処理していない、かつ新しいチャットのみ対象
            logs.forEach(l => {
                if (l.type === 'chat') {
                    // 1. 吹き出し表示ロジック (4秒以内の発言なら表示し続ける)
                    // これにより、画面が再描画されても吹き出しが維持されます
                    if (now - l.timestamp < 4000) {
                        if (l.targetId) {
                            // ★修正: 第三引数に timestamp を渡す
                            showChatBubble(l.targetId, l.text, l.timestamp);
                        }
                    }
                }
            });
            
            // 最新のタイムスタンプを記録
            if (lastLog) {
                lastChatTimeProcessed = Math.max(lastChatTimeProcessed, lastLog.timestamp);
            }
            // ▲▲▲ 追加ここまで ▲▲▲

            // ★チャット通知
            if (lastLog.type === 'chat' && lastLog.targetId !== myId) {
                const match = lastLog.text.match(/^\[(.*?)\]/);
                const senderName = match ? match[1] : "";
                
                if (senderName !== myName && lastLog.timestamp > lastReadLogTime) {
                    // els.btnChat.classList.add("notify-active");
                    if (Date.now() - lastLog.timestamp < 2000) { // 2秒以内の新着なら鳴らす
                         playSoundEffect('chat');
                    }
                }
            }
        }

        // ▼▼▼ 新規関数: 吹き出し表示 ▼▼▼
        function showChatBubble(pid, text, timestamp) {
            const bubble = document.getElementById(`bubble-${pid}`);
            if (!bubble) return;

            // 名前部分 "[Name] " を除去してメッセージだけにする
            const match = text.match(/^\[.*?\] (.*)$/);
            const msg = match ? match[1] : text;

            bubble.innerText = msg;

            // ★追加: 経過時間を計算して、アニメーションを「途中から」開始させる
            // これにより、画面が書き換わっても見た目上のアニメーションは継続しているように見えます
            const elapsed = Date.now() - timestamp;
            
            // アニメーションリセット（連続投稿対応）
            bubble.classList.remove("active");
            void bubble.offsetWidth; // リフロー強制

            // ★重要: 経過時間分だけアニメーションを「巻き戻して」セットする
            // (例: 1秒経過していたら、最初から1秒進んだ状態から表示される)
            bubble.style.animationDelay = `-${elapsed}ms`;

            bubble.classList.add("active");
        }

        function showLogHistory() {
            if(!gameState) return;
            let logs = gameState.logs || [];
            
            // ★既読処理
            lastReadLogTime = Date.now();
            // els.btnChat.classList.remove("notify-active");
            //els.log.classList.remove("notify-bar");

            let html = `
                <div id="chat-input-container">
                    <input type="text" id="chat-input" placeholder="メッセージを入力..." onkeydown="if(event.key==='Enter' && !event.isComposing){sendChat();}">
                    <button id="chat-send-btn" onclick="sendChat()">送信</button>
                </div>
                <div id="log-list-container">
            `;
            
            [...logs].reverse().forEach(l => {
                if(l.type === 'private' && l.targetId !== myId) return;
                let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit', second:'2-digit'});
                let styleClass = '';
                let content = l.text;

                if(l.type === 'private') {
                    styleClass = 'log-private';
                } else if(l.type === 'chat') {
                    styleClass = 'log-chat';
                    const match = content.match(/^\[(.*?)\] (.*)$/);
                    if (match) {
                        const name = match[1];
                        const msg = match[2];
                        const color = stringToColor(name);
                        content = `<span style="color:${color}; font-weight:bold;">[${name}]</span> ${msg}`;
                    }
                }
                html += `<div class="log-entry ${styleClass}"><span class="log-time">${time}</span><span class="log-text">${content}</span></div>`;
            });
            html += `</div>`;
            openModal("チャット & ログ", html);
        }

        async function sendChat() {
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if(!msg) return;

            await pushLog(`[${myName}] ${msg}`, 'chat', myId);

            input.value = "";
            lastReadLogTime = Date.now();
            showLogHistory(); 
        }
        
        // プレイヤーを入室順（joinedAtが早い順）に並べる関数
        function getSortedPlayerIds(players) {
            return Object.keys(players).sort((a, b) => {
                const tA = players[a].joinedAt || 0;
                const tB = players[b].joinedAt || 0;
                // 時間が同じならID順、あれば時間順
                if (tA === tB) return a.localeCompare(b);
                return tA - tB;
            });
        }

        async function leaveRoom() {
            if (!currentRoom || !myId) {
                location.reload();
                return;
            }

            if (window.confirm("部屋を抜けてタイトルに戻りますか？")) {
                try {
                    // 1. Firebaseから自分のプレイヤーデータを削除
                    await db.ref(`rooms/${currentRoom}/players/${myId}`).remove();
                    
                    // 2. ページをリロードして初期状態に戻る
                    location.reload();
                } catch (e) {
                    console.error("退室エラー:", e);
                    location.reload(); // エラーが起きても強制的にタイトルへ
                }
            }
        }

        async function joinGame() {
            unlockAudioContext();
            if(currentRoom) return; 
            els.btnJoin.disabled = true; 
            
            lastReadLogTime = Date.now();

            try {
                const room = els.roomName.value.trim();
                const name = els.playerName.value.trim();
                if (!room || !name) {
                    els.btnJoin.disabled = false;
                    return showInfoModal("入力エラー", "部屋名と名前を入力してください");
                }

                // ▼▼▼▼▼ ここから追加・修正 ▼▼▼▼▼
                
                // 1. まず部屋のデータを取得して確認する
                const checkRef = db.ref(`rooms/${room}`);
                const snapshot = await checkRef.get();

                if (snapshot.exists()) {
                    const data = snapshot.val();
                    const players = data.players || {};
                    const playerCount = Object.keys(players).length;
                    
                    // 「自分がまだリストにいない」かつ「既に5人以上いる」ならエラー
                    // (リロードして戻ってきた人は入れるように !players[myId] で判定します)
                    if (!players[myId] && playerCount >= 5) {
                        els.btnJoin.disabled = false;
                        return showInfoModal("満員", "この部屋は定員(5名)に達しています。<br>別の部屋名を使ってください。");
                    }

                    // ★追加: 名前重複チェック
                    // IDが違うのに、同じ名前の人がいたらエラーにする
                    const isNameDuplicate = Object.keys(players).some(pid => {
                        // 自分自身は除外
                        if (pid === myId) return false;
                        // 名前が一致するかチェック
                        return players[pid].name === name;
                    });

                    if (isNameDuplicate) {
                         els.btnJoin.disabled = false;
                         return showInfoModal("名前重複", "その名前は既に使用されています。<br>別の名前を使ってください。");
                    }

                }
                

                myName = name;
                currentRoom = room;

                const updates = {};
                updates[`rooms/${room}/players/${myId}/name`] = name;
                updates[`rooms/${room}/players/${myId}/online`] = true;
                //★変更：サーバーの正確な時間を使って「入室時刻」を記録する
                updates[`rooms/${room}/players/${myId}/joinedAt`] = firebase.database.ServerValue.TIMESTAMP;


                await db.ref().update(updates);
                joined = true;

                setupEffectListener();
                playBgm('BGM_LOBBY');

                const roomRef = db.ref(`rooms/${room}`);
                roomRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        gameState = data;
                        render(data);
                    } else {
                        if (joined && gameState && gameState.playerOrder) {
                            showInfoModal("終了", "部屋が解散（削除）されました。");
                            setTimeout(() => location.reload(), 2000);
                        } else {
                            gameState = { players: { [myId]: { name, online: true } }, logs: [] };
                            render(gameState);
                        }
                    }
                });



                els.login.classList.add("hidden");
                els.game.classList.remove("hidden");
                document.getElementById("room-display").innerText = `部屋: ${room}`;
            } catch(e) { 
                showInfoModal("通信エラー", e.message); 
                els.btnJoin.disabled = false;
            }
        }

        function confirmCloseRoom() {
            showConfirmModal("解散確認", "本当に部屋を解散しますか？", "execCloseRoom()");
        }
        async function execCloseRoom() {
            try { await db.ref(`rooms/${currentRoom}`).remove(); location.reload(); } 
            catch(e) { showInfoModal("エラー", "削除失敗: " + e.message); }
        }

        /* --- 修正版 confirmInitGame --- */
        function confirmInitGame() {
            // showConfirmModalを使うと、ボタンを押した瞬間に強制的に閉じてしまい、
            // エラーメッセージまで消してしまうので、手動でボタンを作ります。
            
            els.mTitle.innerText = "開始確認";
            els.mContent.innerHTML = "<p>ゲームを開始（リセット）しますか？</p>";
            els.mFooter.innerHTML = `
                <button onclick="closeModal(); execInitGame()" class="modal-btn primary">はい</button>
                <button onclick="closeModal()" class="modal-btn">いいえ</button>
            `;
            els.modal.classList.remove("hidden");
        }
        async function execInitGame(fixedNumCount) {
            try {
                const players = gameState.players || {};

                // 1. 入室順リスト取得
                let playerIds = getSortedPlayerIds(players);

                // 2. 最下位を先頭へ
                if (gameState.rankings) {
                    let loserId = Object.keys(gameState.rankings).reduce((a, b) => 
                        gameState.rankings[a] > gameState.rankings[b] ? a : b
                    , null);

                    if (loserId && playerIds.includes(loserId)) {
                        playerIds = playerIds.filter(pid => pid !== loserId);
                        playerIds.unshift(loserId);
                    }
                }

                if(playerIds.length < 2) return showInfoModal("エラー", "最低2人のプレイヤーが必要です！");

                // ★修正: 引数で枚数を受け取る（なければデフォルト6）
                // (モーダル内の要素を探す処理は削除しました)
                let numCount = fixedNumCount || 6;

                let deckNum = [];
                NUMBERS.forEach(n => { for(let i=0; i<4; i++) deckNum.push({type:'num', val:n}); });
                let deckSym = [];
                SYMBOLS.forEach(s => { for(let i=0; i<SYMBOL_COUNTS[s]; i++) deckSym.push({type:'sym', val:s}); });
                
                shuffle(deckNum);
                shuffle(deckSym);

                /* --- execInitGame関数内 --- */
                
                let hands = {};
                let roles = {};
                
                // 役職シャッフル（重複なしで配るため）
                let availRoles = [...ROLES];
                shuffle(availRoles);
                
      
                playerIds.forEach((pid, i) => {
                    let h = [];
                    // ★枚数選択反映
                    for(let k=0; k<numCount; k++) h.push(deckNum.pop());
                    for(let k=0; k<2; k++) h.push(deckSym.pop());
                    h = sortCards(h);
                    hands[pid] = h;
                    roles[pid] = availRoles.pop();
                });

                // ★追加: 皇帝のカミングアウト判定
                let revealedRoles = {};
                let coLogs = [];
                
                playerIds.forEach(pid => {
                    const r = roles[pid];
                    if (r === "EMPEROR") {
                        revealedRoles[pid] = true; // 最初から公開状態にする
                        let rNameJP = (ROLE_INFO[r]) ? ROLE_INFO[r].jp : r;
                        coLogs.push({
                            text: `${players[pid].name} は [${rNameJP}] であることをカミングアウトしました！`,
                            type: 'public',
                            timestamp: Date.now()
                        });
                        
                        // 皇帝ならカットイン演出も予約（initDataのログに入れておく）
                        if (r === "EMPEROR") {
                             // ここで直接カットインは出せないので、ログを見て検知させるか、
                             // シンプルにログ通知だけで済ませるのが安全です。
                        }
                    }
                });
                
                // ▲▲▲ ここまで挿入 ▲▲▲

                const initData = {
                    status: "playing",
                    deckNum,
                    deckSym,
                    graveNum: [],
                    graveSym: [],
                    exclusion: [],
                    isReverse: false,
                    turnIdx: 0,
                    playerOrder: playerIds,
                    passCount: 0,
                    hands, roles, players, rankings: {}, 
                    // 【追加】能力使用済みフラグ（初期値は空）
                    activatedList: {},
                    revealedRoles: revealedRoles,

                    // ★追加: ハッキングされたカードの隔離所
                    hackedHands: null,

                    // ▼▼▼ 修正: ここに lastSound: null を追加して、前の音を消す ▼▼▼
                    lastSound: null,
                    // ▲▲▲ 追加ここまで ▲▲▲

                    // ログにカミングアウト情報を追加
                    logs: [
                        {text: `ゲーム開始！(数字${numCount}枚モード)`, type: "public", timestamp: Date.now()},
                        ...coLogs 
                    ]
                };

                wasMyTurn = false;
                hasFinished = false;
                await db.ref(`rooms/${currentRoom}`).update(initData);
            } catch(e) { showInfoModal("エラー", "開始エラー: " + e.message); }
        }

        // ★共通関数: リセット権の継承判定ロジック
        function checkInheritedResetLogic(data, myId) {
            if (!data) return false;
            
            let top = (data.graveNum && data.graveNum.length > 0) ? data.graveNum[data.graveNum.length-1] : null;
            
            // 1. 基本条件: 墓地にカードがあり、その持ち主が前回の勝者であり、かつその勝者が今回のランキングに存在すること
            if (!top || !data.lastWinnerId || data.lastWinnerId !== top.owner) return false;
            if (!data.rankings || !data.rankings[data.lastWinnerId]) return false;

            // 2. 生存人数計算 (あがっていない人)
            let activePIds = (data.playerOrder || []).filter(pid => !data.rankings || !data.rankings[pid]);
            let activeCount = activePIds.length;
            
            // 3. ログ解析: 勝った時間より後のログを確認
            let winTime = data.lastWinnerTime || 0;
            let logs = data.logs || [];
            let actedNames = new Set();
            let recentLogs = logs.filter(l => l.timestamp > winTime && l.type === 'public');

            recentLogs.forEach(l => {
                let match = l.text.match(/^(.+?)が/);
                if (match) actedNames.add(match[1]);
            });

            // 4. 除外処理 (勝者本人と、判定者自身を除外)
            if (data.players && data.players[data.lastWinnerId]) {
                actedNames.delete(data.players[data.lastWinnerId].name);
            }

            // 6. 判定
            return actedNames.size >= activeCount;
        }

       function render(data) {
            // 1. 要素の取得
            let turnIndicator = document.getElementById("turn-indicator");
            let graveContainer = document.getElementById("grave-container");
            let handContainer = document.getElementById("my-hand");
            let hackedContainer = document.getElementById("hacked-area");
           
            // 2. クリア
            if(handContainer) handContainer.innerHTML = "";
            if(hackedContainer) hackedContainer.innerHTML = "";

            // 3. データ準備
            const players = data.players || {};
            const hands = data.hands || {};
            const roles = data.roles || {};
            const hackedHands = data.hackedHands || {};
            const currentAct = data.activatedList || {};
            const currentRev = data.revealedRoles || {};

            // ★追加: 墓地トップとリセット権所有者の計算（位置を上に移動）
            let top = (data.graveNum && data.graveNum.length > 0) ? data.graveNum[data.graveNum.length-1] : null;
            let resetHolder = top ? top.owner : null;

           // ★修正: 共通関数を使ってリセット権の継承判定を行う
            let isInheritedReset = checkInheritedResetLogic(data, myId);

            // ★決定: 最終的なリセット権を持つプレイヤーID
            // 継承が起きているなら「現在の手番プレイヤー」、そうでなければ「カードの持ち主」
            let effectiveResetHolder = resetHolder;
            if (isInheritedReset && data.playerOrder) {
                effectiveResetHolder = data.playerOrder[data.turnIdx];
            }

            // ★追加: 実質的なホスト（権限者）を決定する
            // 通常は先頭の人だが、ゲーム終了時は「最下位の人」に権限を移す
            let pIdsForHost = getSortedPlayerIds(players);
            if (data.playerOrder) pIdsForHost = data.playerOrder;
            
            let effectiveHostId = (pIdsForHost.length > 0) ? pIdsForHost[0] : null;

            if (data.status === "finished" && data.rankings) {
                let loserId = Object.keys(data.rankings).reduce((a, b) => 
                    data.rankings[a] > data.rankings[b] ? a : b
                , null);
                
                if (loserId && players[loserId]) {
                    effectiveHostId = loserId;
                }
            }

            // ↓↓↓ 修正: "山札: xx枚" という文字を消し、数字だけ入れる ↓↓↓
            if (data.deckNum && els.deckNum) els.deckNum.innerText = data.deckNum.length;
            if (data.deckSym && els.deckSym) els.deckSym.innerText = data.deckSym.length;
            
            // -----------------------------------------------------
            // A. ゲーム進行中の描画
            // -----------------------------------------------------
            if (data.status === "playing" || data.status === "finished") {
                
                // --- 1. 手札の描画 (統合版・安全対策済み) ---
                if (handContainer) {
                    handContainer.innerHTML = ""; // クリア

                    let rawHand = hands[myId];
                    let myHand = rawHand ? sortCards(deepCopy(rawHand)) : [];
                    let myLockedHand = hackedHands[myId] || [];
                    
                    const fragment = document.createDocumentFragment();

                    // 【対策A】 「通常の手札」
                    myHand.forEach((c, i) => {
                        let div = document.createElement("div");
                        let cssClass = `card ${c.type}`;
                        if (c.isOpen) cssClass += " revealed";

                        div.className = cssClass;
                        // if(c.val === 0) div.setAttribute("data-val", "0");
                        if(i === selectedIdx) div.classList.add("selected");
                        
                        let valNode = document.createTextNode(c.val);
                        div.appendChild(valNode);
                        
                        let imgUrl = CARD_IMAGES[c.val];
                        if (imgUrl) {
                            div.style.backgroundImage = `url('${imgUrl}')`;
                            div.classList.add('has-img');
                        }

                        if (data.status === "playing" && !data.rankings?.[myId]) {
                            div.onclick = () => {
                                selectedIdx = (selectedIdx === i) ? -1 : i;
                                render(data);
                            };
                        }
                        fragment.appendChild(div);
                    });

                    // 【対策B】 「隔離カード」
                    myLockedHand.forEach(c => {
                        let div = document.createElement("div");
                        div.className = `card ${c.type} locked`; 
                        
                        let imgUrl = CARD_IMAGES[c.val];
                        if (imgUrl) {
                            div.style.backgroundImage = `url('${imgUrl}')`;
                            div.classList.add('has-img');
                        }
                        
                        let valNode = document.createTextNode(c.val);
                        div.appendChild(valNode);
                        // if(c.val === 0) div.setAttribute("data-val", "0");

                        div.onclick = () => showInfoModal("ロック中", "このカードは機能停止しています。");
                        fragment.appendChild(div);
                    });

                    handContainer.appendChild(fragment);
                }

                // --- 3. 役職パネルの描画 ---
                const myRole = roles[myId];
                const rInfo = (typeof ROLE_INFO !== 'undefined') ? ROLE_INFO[myRole] : null;
                
                let roleArea = document.getElementById("my-role-panel");
                if(!roleArea && document.getElementById("my-area")) {
                    roleArea = document.createElement("div");
                    roleArea.id = "my-role-panel";
                    let controls = document.getElementById("controls");
                    if(controls) document.getElementById("my-area").insertBefore(roleArea, controls);
                }

                if (roleArea && myRole && rInfo) {
                    let actBtnHtml = "";
                    let isActivated = currentAct[myId];
                    
                    if (isMyTurn() && !isActivated && data.status === "playing") {
                        let funcName = "";
                        // 各役職の発動関数マッピング
                        if (myRole === "ANGLER") funcName = "activateAngler()";
                        else if (myRole === "FORTUNE TELLER") funcName = "activateFortuneTeller()";
                        else if (myRole === "THIEF") funcName = "activateThief(1)";
                        else if (myRole === "HUNTER") funcName = "activateHunter()";
                        else if (myRole === "GAMBLER") funcName = "activateGambler()";
                        else if (myRole === "CROWN") funcName = "activateMagician()";
                        else if (myRole === "MILLIONAIRE") funcName = "activateMillionaire()";
                        else if (myRole === "EMPEROR") funcName = "activateEmperor()";
                        else if (myRole === "POLICE OFFICER") funcName = "activatePoliceOfficer()";
                        else if (myRole === "HACKER") funcName = "activateHacker()";
                        else if (myRole === "ALCHEMIST") funcName = "activateAlchemist()";
                        else if (myRole === "NECROMANCER") funcName = "activateNecromancer()";
                        else if (myRole === "AGENT") funcName = "activateAgent()";

                        if (funcName) {
                            actBtnHtml = `<button onclick="${funcName}" style="margin-top:8px; padding:6px 12px; font-size:12px; background:#fff; color:#4a148c; border:none; border-radius:15px; font-weight:bold; cursor:pointer; box-shadow:0 2px 4px rgba(0,0,0,0.2);">スキル発動</button>`;
                        }
                    } else if (isActivated) {
                        let statusText = "(発動済み)";
                        
                        // ▼▼▼ 修正: ピエロの場合、中身を表示 ▼▼▼
                        if (myRole === "CROWN" && typeof isActivated === 'string') {
                            // 役職IDなら日本語に変換、そうでなければそのまま表示(REVERSE等)
                            let val = isActivated;
                            if (ROLE_INFO[val]) val = ROLE_INFO[val].jp;
                            
                            statusText = `使用: ${val}`;
                        }
                        // ▲▲▲ 修正ここまで ▲▲▲
                        
                        actBtnHtml = `<div style="font-size:11px; color:#ffeb3b; margin-top:5px; font-weight:bold;">${statusText}</div>`;
                    }

                    // 背景スタイル
                    let style = isActivated ? 'filter:grayscale(1); opacity:0.6;' : '';
                    const bgUrl = (typeof ROLE_IMAGES !== 'undefined') ? ROLE_IMAGES[myRole] : null;
                    let bgStyle = "";
                    
                    if (myRole === "EMPEROR") {
                        if (bgUrl) {
                            bgStyle = `background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(0,0,0,0.6)), url('${bgUrl}'); background-size: cover; background-position: center 12%; border: 3px solid #fff; animation: goldPulse 2s infinite alternate;`;
                        } else {
                            bgStyle = `background: linear-gradient(45deg, #FFD700, #FDB931, #FFED86, #FFD700); background-size: 200% 200%; border: 3px solid #fff; animation: goldShine 3s ease infinite, goldPulse 2s infinite alternate; color: #3e2723; text-shadow: none;`;
                        }
                    } else if (bgUrl) {
                        bgStyle = `background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.8)), url('${bgUrl}'); background-size: cover; background-position: center 12%;`;
                    } else {
                        bgStyle = `background: linear-gradient(135deg, #6a1b9a, #4a148c);`;
                    }

                    roleArea.innerHTML = `
                        <div class="role-card" style="${style} ${bgStyle}">
                            <div class="role-name">${myRole}</div>
                            <div class="role-jp">${rInfo.jp}</div>
                            <div class="role-desc">${rInfo.summary}</div>
                            ${actBtnHtml}
                        </div>
                    `;
                }

                // --- 4. 演出・音・カットイン ---
                Object.keys(currentAct).forEach(pid => {
                    if (!prevActivatedList[pid] && currentAct[pid]) {
                        const rKey = roles[pid];
                        const rNameJP = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rKey]) ? ROLE_INFO[rKey].jp : rKey;
                        const pName = players[pid].name;
                        
                        if (typeof playCutInAnimation === 'function') playCutInAnimation(rKey, rNameJP, pName);
                        
                        const sndKey = 'SKILL_' + rKey;
                        if (typeof SOUND_FILES !== 'undefined' && SOUND_FILES[sndKey]) playSoundEffect(sndKey);
                        else playSoundEffect('SKILL');
                    }
                });
                
                Object.keys(currentRev).forEach(pid => {
                    if (!prevRevealedRoles[pid] && currentRev[pid]) {
                        const rKey = roles[pid];
                        if (rKey === "EMPEROR") {
                            const rNameJP = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rKey]) ? ROLE_INFO[rKey].jp : rKey;
                            const pName = players[pid].name;
                            if (typeof playCutInAnimation === 'function') playCutInAnimation(rKey, rNameJP, pName);
                            const sndKey = 'SKILL_' + rKey;
                            playSoundEffect(typeof SOUND_FILES !== 'undefined' && SOUND_FILES[sndKey] ? sndKey : 'SKILL');
                        }
                    }
                });

                prevActivatedList = deepCopy(currentAct);
                prevRevealedRoles = deepCopy(currentRev);

                // --- 5. BGM & 他プレイヤー表示 ---
                // ★修正: ゲーム終了時はロビーBGM（または停止）に切り替える
                if (data.status === "playing") {
                    playBgm('BGM_BATTLE');
                } else {
                    playBgm('BGM_LOBBY'); 
                    // ※もし無音が良ければ stopBgm(); にしてください
                }

                const areaTop = document.getElementById("area-top");
                const areaLeft = document.getElementById("area-left");
                const areaRight = document.getElementById("area-right");
                if(areaTop) areaTop.innerHTML = "";
                if(areaLeft) areaLeft.innerHTML = "";
                if(areaRight) areaRight.innerHTML = "";

                let pIds = getSortedPlayerIds(players); 
                if(data.playerOrder) pIds = data.playerOrder;
                
                // 自分エリアの演出処理
                const myAreaEl = document.getElementById("my-area");
                if (myAreaEl) {
                    let myHand = hands[myId] || [];
                    let myLocked = hackedHands[myId] || [];
                    let myCount = myHand.length + myLocked.length;
                    myAreaEl.classList.remove("current-turn", "warning-1", "warning-2");
                    if (pIds[data.turnIdx] === myId) {
                        myAreaEl.classList.add("current-turn");
                    }
                }

                // 配置計算
                let relativeOrder = [];
                let myIndex = pIds.indexOf(myId);
                if (myIndex !== -1) {
                    for (let i = 1; i < pIds.length; i++) {
                        let idx = (myIndex + i) % pIds.length;
                        relativeOrder.push(pIds[idx]);
                    }
                } else {
                    relativeOrder = pIds; // 観戦用
                }

                let layoutMap = [];
                let total = relativeOrder.length; 
                if (total === 2) { 
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaRight }];
                } else if (total === 3) {
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaTop }, { pid: relativeOrder[2], area: areaRight }];
                } else if (total === 4) {
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaTop }, { pid: relativeOrder[2], area: areaTop }, { pid: relativeOrder[3], area: areaRight }];
                } else {
                    relativeOrder.forEach(pid => layoutMap.push({pid: pid, area: areaTop}));
                }

                // ■■■ 描画ループ (3段固定レイアウト版) ■■■
                layoutMap.forEach(item => {
                    let pid = item.pid;
                    let area = item.area;
                    if (!area) return;

                    // ▼▼▼ 追加: エリアに応じた吹き出し位置クラスを決定 ▼▼▼
                    let bubbleClass = "bubble-pos-top"; // デフォルト（上）
                    if (area.id === "area-left") bubbleClass = "bubble-pos-left";
                    else if (area.id === "area-right") bubbleClass = "bubble-pos-right";
                    // ▲▲▲ 追加ここまで ▲▲▲

                    let isTurn = (pIds[data.turnIdx] === pid);
                    let isRanked = (data.rankings && data.rankings[pid]);
                    let pHand = hands[pid] || [];
                    let lockedHand = hackedHands[pid] || []; 
                    let handCount = pHand.length + lockedHand.length;

                    // クラス設定
                    let boxClass = "p-box-new";
                    if (isTurn) boxClass += " current";
                    if (isRanked) boxClass += " passed";

                    // --- 1. 手札枚数の色スタイル ---
                    let countStyle = ""; 
                    if (!isRanked) { 
                        if (handCount === 1) {
                            boxClass += " warning-1";
                            countStyle = "color:#ff1744; text-shadow:0 0 10px #ff1744; animation: blink-text 0.6s infinite;"; 
                        } else if (handCount === 2) {
                            boxClass += " warning-2";
                            countStyle = "color:#ffeb3b; text-shadow:0 0 10px #ffeb3b; animation: blink-text 1.2s infinite;";
                        }
                    } else {
                        // あがった人は枚数0でグレーアウト
                        countStyle = "color:#78909c;";
                    }

                    // --- 2. ステータス表示 (NORMAL / RESET / RANK) ---
                    let statusHtml = `<span class="status-text status-normal">NORMAL</span>`;
                    
                    if (isRanked) {
                        // 順位がついている場合
                        let rank = data.rankings[pid];
                        let suffix = ["st","nd","rd"][rank-1] || "th"; // 1st, 2nd...
                        statusHtml = `<span class="status-text status-rank">🏆 ${rank}${suffix}</span>`;
                    } else if (pid === effectiveResetHolder) {
                        // リセット権を持っている場合
                        statusHtml = `<span class="status-text status-reset">👑 RESET</span>`;
                    }
                    
                    // --- 3. 役職表示 (??? / ROLE NAME) ---
                    let isRevealed = currentAct[pid] || isRanked || currentRev[pid];
                    let roleHtml = `<span class="role-unknown">ROLE: ???</span>`; // デフォルト
                    
                    if (isRevealed) {
                        let rName = roles[pid];
                        let rJp = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rName]) ? ROLE_INFO[rName].jp : rName;
                        
                        // ▼▼▼ 修正・追加箇所: ピエロと同じスタイルにする ▼▼▼
                        if (rName === "CROWN" && typeof currentAct[pid] === 'string') {
                            // ピエロ: 内容をそのまま表示
                            roleHtml = `<div class="role-badge-pill">ピエロ: ${currentAct[pid]}</div>`;
                        }
                        else {
                            // 通常
                            roleHtml = `<div class="role-badge-pill">${rJp}</div>`;
                        }
                        // ▲▲▲ 修正ここまで ▲▲▲
                    }

                    // ヘッダーアイコン
                    let hostMark = (pid === effectiveHostId) ? "<span class='p-host-mark'>★</span>" : "";
                    
                    // --- 4. 公開カード情報のテキスト生成 (ここが変更点) ---
                    // 手札データ(hands)の中で isOpen フラグが立っているものを探す
                    let openFromHand = pHand.filter(c => c.isOpen);
                    
                    // サーバーから別途リストが送られてくる場合（念のため安全策）
                    let openFromServer = (data.revealedCards && data.revealedCards[pid]) ? data.revealedCards[pid] : [];
                    
                    // 両方をマージ
                    let allOpenCards = [...openFromHand, ...openFromServer];
                    let revealedTextHtml = "";

                    if (allOpenCards.length > 0) {
                        // 文字列リストを作成 (例: ["1", "REV"])
                        let textList = allOpenCards.map(c => {
                            let v = c.val; 
                            // 数字(0-9)があればそのまま返す
                            if (v !== undefined && v !== null && !isNaN(v)) {
                                return v;
                            }
                            
                            // 記号カードの略称変換
                            let name = String(v).toUpperCase();
                            if (name.includes('REVERSE')) return 'REV';
                            if (name.includes('TRADE'))   return 'TRD';
                            if (name.includes('DIG'))     return 'DIG';
                            if (name.includes('DISCARD')) return 'DIS';
                            
                            return "?"; 
                        });
                        
                        // ★修正: 重複を削除せず、ソートして見やすくしてから結合
                        // (Setを使わないことで、3が2枚なら "3, 3" と表示されるようになります)
                        textList.sort((a, b) => {
                            // 数字なら数字順、文字ならアルファベット順
                            if (!isNaN(a) && !isNaN(b)) return a - b;
                            return String(a).localeCompare(String(b));
                        });

                        let uniqueText = textList.join(', ');
                        revealedTextHtml = `公開: <span class="revealed-active">${uniqueText}</span>`;
                    } else {
                        // なし (グレー文字)
                        revealedTextHtml = `<span class="revealed-none">公開: NONE</span>`;
                    }
                    let pName = players[pid].name;


                    // ★ HTML組み立て ★
                    let html = `
                        <div class="${boxClass}" style="position:relative;">
                            <div id="bubble-${pid}" class="chat-bubble ${bubbleClass}"></div>
                            <div class="p-header" onclick="showPlayerLogs('${pid}')" style="cursor:pointer; text-decoration:underline;">${hostMark}${pName}</div>
                            <div class="p-body">
                                <div class="p-hand-count" style="${countStyle}">
                                    <span class="p-hand-icon">🃏×</span>${handCount}
                                </div>

                                <div class="p-status-area">
                                    ${statusHtml}
                                    <div class="p-revealed-info">
                                        ${revealedTextHtml}
                                    </div>
                                </div>
                            </div>

                            <div class="p-role-row">
                                ${roleHtml}
                            </div>
                        </div>
                    `;
                    
                    let wrapper = document.createElement("div");
                    wrapper.style.display = "flex";
                    wrapper.style.flexDirection = "column";
                    wrapper.style.alignItems = "center";
                    wrapper.innerHTML = html;
                    area.appendChild(wrapper);
                });

                // ▼▼▼ 追加: 3人対戦などで上エリアが空なら非表示にして詰める ▼▼▼
                if (areaTop.children.length === 0) {
                    areaTop.style.display = "none";
                } else {
                    areaTop.style.display = "flex";
                }
                // ▲▲▲ 追加ここまで ▲▲▲

                // --- 6. 場の情報更新 ---
                if (els.indicator) {
                    let targetSrc = data.isReverse ? "./images/reverse_red.jpg" : "./images/reverse_blue.jpg";
                    if (els.indicator.getAttribute('src') !== targetSrc) els.indicator.src = targetSrc;
                }
                if (els.graveNum) els.graveNum.innerHTML = renderPile(data.graveNum);
                if (els.graveSym) els.graveSym.innerHTML = renderPile(data.graveSym);
                if (document.getElementById("exclusion-count")) document.getElementById("exclusion-count").innerText = (data.exclusion || []).length;

                // メッセージ
                let isMyTurnNow = (pIds[data.turnIdx] === myId);
                if (data.status === "finished") {
                     els.msg.innerText = `ゲーム終了！`;
                     document.getElementById("btn-play").disabled = true;
                     document.getElementById("btn-pass").disabled = true;
                } else if (data.rankings && data.rankings[myId]) {
                    els.msg.innerText = `あなたは ${data.rankings[myId]}位 であがりました！`;
                    document.getElementById("btn-play").disabled = true;
                    document.getElementById("btn-pass").disabled = true;
                
                } else {
                    // ここでの activeCount, isInheritedReset は冒頭で計算したものを使用
                    let isOwnerReset = (resetHolder === myId);
                    let canReset = isOwnerReset || isInheritedReset;

                    if (isMyTurnNow) {
                        if (!wasMyTurn) playSoundEffect('turn');
                        if (data.turnIdx !== lastCleanupTurnIdx) {
                            lastCleanupTurnIdx = data.turnIdx;
                            if (typeof checkHackerCleanup === 'function') checkHackerCleanup();
                        }
                        els.msg.innerText = canReset ? "リセット可能（パスで発動）" : "あなたの番です";
                        document.getElementById("btn-play").disabled = false;
                        document.getElementById("btn-pass").disabled = false;
                    } else {
                        lastCleanupTurnIdx = -1;
                        let curP = players[pIds[data.turnIdx]];
                        els.msg.innerText = `${curP ? curP.name : '相手'} のターン`;
                        document.getElementById("btn-play").disabled = true;
                        document.getElementById("btn-pass").disabled = true;
                    }
                }
                wasMyTurn = isMyTurnNow;

            } else {
                // 待機中 (Lobby)
                els.msg.innerText = `待機中... ${Object.keys(players).length}人が参加`;
                playBgm('BGM_LOBBY');
                prevActivatedList = {};
                prevRevealedRoles = {};
                if(handContainer) handContainer.innerHTML = "";
                if(document.getElementById("my-role-panel")) document.getElementById("my-role-panel").innerHTML = "";
            }

            // 共通: ログ更新
            renderLogs(data.logs);

            // ホストコントロール (★変更点: effectiveHostIdを使用)
            // ↓↓↓ render関数内の「ホストコントロール」部分を書き換え ↓↓↓
            // ホストコントロール (★変更点: 新しいボタンを表示/非表示にする)
            const isHost = (effectiveHostId === myId);
            const btnHost = document.getElementById("btn-host-settings");
            
            if (isHost && btnHost) {
                btnHost.classList.remove("hidden");
            } else if (btnHost) {
                btnHost.classList.add("hidden");
            }

            // ↓↓↓ render関数内の「通知チェック」の上あたりに追加 ↓↓↓
            // --- 7. 自分の順位決定音 (敗者も含む) ---
            if (data.rankings && data.rankings[myId]) {
                if (!myRankPlayed) {
                    let rank = data.rankings[myId];
                    let total = data.playerOrder.length;
                    
                    if (rank === 1) playSoundEffect('RANK_1');     // 1位
                    else if (rank === total) playSoundEffect('RANK_4'); // ★最下位(敗者)
                    else playSoundEffect('RANK_2_3');              // それ以外
                    
                    myRankPlayed = true; // 再生済みにする
                }
            } else {
                // まだ順位がついていない（またはゲーム開始時）はリセット
                myRankPlayed = false;
            }

            // ↑↑↑ 書き換えここまで ↑↑↑
            // 通知チェック
            const myPlayer = players[myId] || {};
            if (myPlayer.notification) {
                playSoundEffect('WARNING');
                const note = myPlayer.notification;
                const getNotifDisplay = (val) => {
                    if (CARD_IMAGES[val]) return `<img src="${CARD_IMAGES[val]}" style="height:80px; width:auto; display:block; margin:0 auto;">`;
                    let style = "font-size:32px; font-weight:bold; line-height:80px;";
                    return `<div style="${style}">${val}</div>`;
                };
                let html = `
                    <div style="text-align:center;">
                        <p style="font-size:16px; font-weight:bold; color:#d32f2f;">${note.fromName} にトレードされました！</p>
                        <div style="display:flex; justify-content:space-around; align-items:center; margin:10px 0;">
                            <div style="width:100px;"><div style="font-size:10px; color:#888;">盗まれた</div>${getNotifDisplay(note.lostVal)}</div>
                            <div style="font-size:20px; color:#ccc;">➡</div>
                            <div style="width:100px;"><div style="font-size:10px; color:#888;">渡された</div>${getNotifDisplay(note.gotVal)}</div>
                        </div>
                    </div>`;
                openModal("⚠️ トレード警告", html);
                firebase.database().ref(`rooms/${currentRoom}/players/${myId}/notification`).remove();
            }

            // ↓↓↓ 追加: 自分の名前バーの更新 ↓↓↓
            // ■■■ 自分エリア（名前・役職・順位）の表示処理 ■■■
            const nameBar = document.getElementById("my-name-bar");
            if (nameBar && players[myId]) {

                // ▼▼▼ 追加: 自分用の吹き出しを nameBar の近くに追加 ▼▼▼
                // nameBar は position: relative がないので、親の my-area に依存させるか、
                // nameBar自体に relative をつける手もありますが、
                // ここでは nameBar の中に absolute で配置します。
                // nameBar に style="position:relative" を付与しておくと安全です
                nameBar.style.position = "relative";
                nameBar.style.overflow = "visible"; // はみ出してもOKにする

                let myPName = players[myId].name;
                
                // 1. 役職のHTML生成
                let myRoleHtml = "";
                if (roles[myId]) {
                    const rKey = roles[myId];
                    const rInfo = (typeof ROLE_INFO !== 'undefined') ? ROLE_INFO[rKey] : null;
                    const jpName = rInfo ? rInfo.jp : rKey;
                    
                    // スキル使用済みなら灰色、未使用なら紫
                    const isUsed = currentAct[myId];
                    const textColor = isUsed ? "#616161" : "#e040fb"; 
                    
                    // フォントサイズや太さの指定を消して、名前のスタイルをそのまま引き継ぐようにしました
                    myRoleHtml = `<span style="color:${textColor}; margin-left:10px;">【役職】${jpName}</span>`;
                }

                // ★修正: resetHolder ではなく effectiveResetHolder を使用して判定
                let resetBadge = "";
                if (effectiveResetHolder === myId) {
                    // status-resetクラスをそのまま利用（位置調整のためstyleを追加）
                    resetBadge = `<span class="status-reset" style="margin-left:10px; font-size:12px; vertical-align:middle; display:inline-block;">👑 RESET</span>`;
                }

                // 2. ホストなら★を表示
                let hostIcon = (effectiveHostId === myId) ? "<span style='color:#ffd700; margin-right:4px;'>★</span>" : "";

                // 3. 順位がついているなら表示
                let rankText = (data.rankings && data.rankings[myId]) ? `<span style="color:#ffd700; margin-left:10px;">🏆${data.rankings[myId]}位</span>` : "";

                let bubbleHtml = `<div id="bubble-${myId}" class="chat-bubble bubble-pos-bottom"></div>`;
                
                // ★全部まとめてセット！ (先頭に bubbleHtml を追加)
                // ★変更: 自分の名前もクリックして履歴を見れるようにする
                nameBar.innerHTML = `${bubbleHtml}${hostIcon}<span onclick="showPlayerLogs('${myId}')" style="cursor:pointer; text-decoration:underline;">${myPName}</span>${myRoleHtml}${resetBadge}${rankText}`;
            }

            // 音再生
            const soundData = data.lastSound;
            if (soundData && soundData.id !== prevSoundId) {
                if (Array.isArray(soundData.type)) {
                    soundData.type.forEach(t => playSoundEffect(t));
                } else {
                    playSoundEffect(soundData.type);
                }
                prevSoundId = soundData.id;
            }
        }

        function getTotalHandCount(pid) {
            let h1 = (gameState.hands[pid] || []).length;
            let h2 = (gameState.hackedHands && gameState.hackedHands[pid]) ? gameState.hackedHands[pid].length : 0;
            return h1 + h2;
        }

        function viewGrave(type) {
            let list;
            let title;
            if (type === 'num') { list = gameState.graveNum; title = "数字墓地"; }
            else if (type === 'sym') { list = gameState.graveSym; title = "記号墓地"; }
            else if (type === 'excl') { list = gameState.exclusion; title = "除外場"; }

            if (!list || list.length === 0) return showInfoModal(title, "空です");
            
            let html = '<div class="modal-list">';
            list.slice().reverse().forEach(c => {
                let style = '';
                let imgUrl = CARD_IMAGES[c.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                html += `<div class="card ${c.type}" style="${style} ${imgStyle}">${c.val}</div>`;
            });
            html += '</div>';
            openModal(title, html);
        }

        function renderPile(arr) {
            if (!arr || arr.length === 0) return "";
            let c = arr[arr.length-1];
            let style = '';
            let imgUrl = CARD_IMAGES[c.val];
            let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
            return `<div class="card ${c.type}" style="${style} ${imgStyle}">${c.val}</div>`;
        }

        // --- Action Logic ---
        function passTurn() {
            if (!isMyTurn()) return;
            
            let activeCount = getActiveCount(gameState);
            let top = getTop(gameState.graveNum);
            let resetHolder = top ? top.owner : null;

            let isOwnerReset = (resetHolder === myId && (gameState.graveNum||[]).length > 0);

            // ★修正: 共通関数を使ってリセット権の継承判定を行う
            let isInheritedReset = checkInheritedResetLogic(gameState, myId);

            if (isOwnerReset || isInheritedReset) {
                openModal("パス (リセット権行使)", "山札からドローしますか？<br><br><span style='color:#ef5350; font-weight:bold;'>※リセット権を行使します（場が流れ、自分のターンが続きます）</span><br><br><button class='modal-btn primary' onclick='execPassDraw(true)'>ドローする</button><button class='modal-btn' onclick='execPassNoDraw(true)'>しない</button>");
                return;
            }

            openModal("パス", "山札からドローしますか？<br><br><button class='modal-btn primary' onclick='execPassDraw(false)'>ドローする</button><button class='modal-btn' onclick='execPassNoDraw(false)'>しない</button>");
        }

        async function execPassNoDraw(isReset) {
            closeModal();
            let updates = {};
            
            if(isReset) {
                let excl = [...(gameState.exclusion || []), ...(gameState.graveNum || [])];
                updates[`rooms/${currentRoom}/exclusion`] = excl;
                updates[`rooms/${currentRoom}/graveNum`] = [];
                updates[`rooms/${currentRoom}/passCount`] = 0;
                await pushLog(`${myName}がドローせずリセットしました`, 'public');
            } else {
                updates[`rooms/${currentRoom}/passCount`] = (gameState.passCount || 0) + 1;
                await pushLog(`${myName}がドローせずパスしました`, 'public');
                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            }
            
            await db.ref().update(updates);
        }

        // ↓↓↓ execPassDraw関数を丸ごとこれに置き換えてください ↓↓↓
        async function execPassDraw(isReset) {
            closeModal();
            let updates = {};
            let deck = [...(gameState.deckNum || [])];
            
            // 山札が空の場合の補充処理
            if (deck.length === 0) {
                let excl = [...(gameState.exclusion || [])];
                let newDeck = excl.filter(c => c.type === 'num');
                let remainingExcl = excl.filter(c => c.type !== 'num');

                if (newDeck.length > 0) {
                    shuffle(newDeck);
                    deck = newDeck;
                    updates[`rooms/${currentRoom}/exclusion`] = remainingExcl;
                    await pushLog("除外場から数字山札を補充しました", 'public');
                } else {
                    showInfoModal("通知", "山札も除外場もありません。ドローなしでパスします。");
                    execPassNoDraw(isReset);
                    return;
                }
            }
            
            // カードを引く
            let card = deck.pop();
            const top = getTop(gameState.graveNum);
            // リセット時でなければ、出せるかどうか判定する
            const playable = !isReset && (card.type === 'num' && canPlay(card, top, gameState.isReverse));
            
            drawnCardTemp = card;
            updates[`rooms/${currentRoom}/deckNum`] = deck;
            await db.ref().update(updates);

            if (playable) {
                // 出せる場合：選択肢を表示
                let imgUrl = CARD_IMAGES[card.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                let cardHtml = `<div class="card ${card.type}" style="display:inline-flex; ${imgStyle}">${card.val}</div>`;
                
                let html = `引いたカード: ${cardHtml}<br>これを出しますか？<br><br>
                            <button class='modal-btn primary' onclick='execPassPlay()'>出す</button>
                            <button class='modal-btn' onclick='execPassKeep()'>手札に入れる</button>`;
                
                openModal("ドロー結果", html);

                // ★修正: ここでフッター（閉じるボタン）を消去して、キャンセル不可にする
                if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }

            } else {
                // 出せない場合（またはリセット時）：自動的に手札へ
                let msg = isReset ? "(リセットのため手札に入れます)" : "(出せないので手札に入れます)";
                await pushLog(`[${card.val}] を引きました ${msg}`, 'private', myId);
                execPassKeep(isReset);
            }
        }

        async function execPassPlay() {
            closeModal();
            let card = drawnCardTemp;
            if(!card) return;
            
            let updates = {};
            let gn = [...(gameState.graveNum || [])];
            gn.push({ ...card, owner: myId });
            updates[`rooms/${currentRoom}/graveNum`] = gn;
            updates[`rooms/${currentRoom}/passCount`] = 0;
            
            await pushLog(`${myName}がパスドローから [${card.val}] を出しました`, 'public');
            
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await db.ref().update(updates);
            drawnCardTemp = null;
        }

        async function execPassKeep(isReset = false) {
            closeModal(); 
            let card = drawnCardTemp;
            if(!card) return;

            let updates = {};
            let hand = [...gameState.hands[myId]];
            hand.push(card);
            hand = sortCards(hand);
            updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            
            if(isReset) {
                let excl = [...(gameState.exclusion || []), ...(gameState.graveNum || [])];
                updates[`rooms/${currentRoom}/exclusion`] = excl;
                updates[`rooms/${currentRoom}/graveNum`] = [];
                updates[`rooms/${currentRoom}/passCount`] = 0;
                await pushLog(`${myName}がリセットして1枚引きました`, 'public');
            } else {
                updates[`rooms/${currentRoom}/passCount`] = (gameState.passCount || 0) + 1;
                if(gameState.lastLog !== `${myName}がドローせずパスしました`) {
                     await pushLog(`${myName}がパスして1枚引きました`, 'public');
                }
                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            }

            await db.ref().update(updates);
            drawnCardTemp = null;
        }

        async function playCard() {
            if (selectedIdx === -1) return;
            if (!isMyTurn()) return showInfoModal("エラー", "あなたの番ではありません");

            let currentHand = sortCards(deepCopy(gameState.hands[myId]));
            const card = currentHand[selectedIdx];
            
            if (card.type === 'num') {
                if (Number(card.val) === 0 && currentHand.length === 1) {
                    return showInfoModal("禁止あがり", "最後の一枚が「0」であがることはできません。");
                }

                const top = getTop(gameState.graveNum);
                
                if (!canPlay(card, top, gameState.isReverse)) {
                    return showInfoModal("エラー", "そのカードは出せません");
                }
                
                let updates = {};
                let newHand = [...currentHand];
                newHand.splice(selectedIdx, 1);
                updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;

                // ★残り枚数を計算して、鳴らす音を決定する
                // ★音のセットを作成（基本はPUT）
                let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
                let nextTotal = newHand.length + myHackedCount;
                
                let soundList = ['PUT']; 
                if (nextTotal === 1) soundList.push('UNO');
                else if (nextTotal === 2) soundList.push('DOS');

                // セットで送信
                updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

                let newGraveNum = [...(gameState.graveNum || [])];
                
        
                
                let playCardData = { ...card, owner: myId };
                newGraveNum.push(playCardData);

                updates[`rooms/${currentRoom}/graveNum`] = newGraveNum;
                updates[`rooms/${currentRoom}/passCount`] = 0;
                
                await pushLog(`${myName}が [${card.val}] を出しました`, 'public');

                /* --- playCard 関数内の修正 (推奨版) --- */

                // 手札(newHand)が0枚、かつ、隔離エリア(hackedHands)も0枚ならあがり
                // ★ここを書き換え
                if (newHand.length === 0 && myHackedCount === 0) {
                    let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                    // ... (以下、あがり処理はそのまま)
                    updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                    await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');

                    // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
                    updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
                    updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
                    // ▲▲▲ 追加ここまで ▲▲▲

                    let totalPlayers = gameState.playerOrder.length;

                    if (currentRank >= totalPlayers - 1) {
                         updates[`rooms/${currentRoom}/status`] = "finished";

                        // 敗者（最後の一人）を特定
                        let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！！最下位 ${lName} の残り手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！！`, 'public');
                        }

                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                    }
                }
                
                let tempRankings = {...(gameState.rankings || {})};
                if(newHand.length === 0) tempRankings[myId] = 99;

                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

                await db.ref().update(updates);
                selectedIdx = -1;

            } else { handleSymbol(card, selectedIdx, currentHand); }
        }

        async function handleSymbol(card, idx, currentHand) {
            // ▼▼▼ 修正箇所: ロック中のカードも考慮して「あがり」かどうか判定する ▼▼▼
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            
            if (currentHand.length === 1 && myHackedCount === 0) return showInfoModal("禁止あがり", "記号であがることはできません。");
            
            
            if (card.val === "DIG UP") {
                const hasNum = currentHand.some((c, i) => i !== idx && c.type === 'num');
                if (!hasNum) return showInfoModal("使用不可", "手札に数字カードがないため、DIG UPは使用できません。");
                let gn = gameState.graveNum || [];
                if (gn.length === 0) return showInfoModal("使用不可", "数字墓地がないため使用できません");
                
                let top = gn[gn.length-1];
                let imgUrl = CARD_IMAGES[top.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                let topCardHtml = `<div class="card ${top.type}" style="${imgStyle} display:inline-flex;">${top.val}</div>`;

                let html = `<p>墓地の ${topCardHtml} を手札に入れます。<br>代わりに場に埋めるカード(手札)を選んでください。</p><div class="modal-list">`;
                currentHand.forEach((c, i) => {
                    if (i === idx) return; 
                    if (c.type !== 'num') return; 
                    let style = '';
                    let cImg = CARD_IMAGES[c.val];
                    if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                    html += `<div class="card ${c.type}" style="${style}" onclick="execDigUp(${idx}, ${i})">${c.val}</div>`;
                });
                html += `</div>`;
                openModal("DIG UP: 交換", html);
                return;
            }
            if (card.val === "TRADE") {
                let pIds = gameState.playerOrder;
                let html = `<p>トレード相手を選んでください。</p>`;
                pIds.forEach(pid => {
                    if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
                    let p = gameState.players[pid];
                    let count = gameState.hands[pid] ? gameState.hands[pid].length : 0;
                    if (count > 0) {
                        html += `<button class="modal-btn" onclick="tradeStep2('${pid}', ${idx})">${p.name} (手札${count})</button>`;
                    }
                });
                openModal("TRADE: 相手選択", html);
                return;
            }
            if (card.val === "DISCARD") {
                let newHand = [...currentHand];
                // 使用したDISCARDカード以外をリスト化
                let discardable = newHand.filter((_, i) => i !== idx);
                
                // ★追加: 捨てられる数字カードがあるかチェック
                let hasNum = discardable.some(c => c.type === 'num');
                if (!hasNum) return showInfoModal("エラー", "捨てることのできる数字カードがありません");

                let html = `<p>捨てるカードを選んでください<br><span style="font-size:12px; color:#ef5350;">※数字カードのみ選択可能です</span></p><div class="modal-list">`;
                discardable.forEach((c, i) => {
                    let style = '';
                    let onClick = '';
                    let cImg = CARD_IMAGES[c.val];

                    // ★変更: 数字カードなら選択可能、記号カードなら選択不可
                    if (c.type === 'num') {
                        // 選択可能
                        style = 'cursor:pointer; transition:transform 0.1s; ';
                        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                        onClick = `onclick="execDiscard(${idx}, ${i})"`;
                    } else {
                        // 選択不可 (グレーアウト)
                        style = 'opacity:0.3; cursor:not-allowed; border:1px dashed #777; background:rgba(0,0,0,0.2); transform:scale(0.95);';
                        if(cImg) {
                            style += `background-image:url('${cImg}'); background-size:cover; background-position:center; color:transparent;`;
                        }
                    }

                    html += `<div class="card ${c.type}" style="${style}" ${onClick}>${c.val}</div>`;
                });
                html += `</div>`;
                openModal("DISCARD: 手札破棄", html);
                return;
            }

            // ↓↓↓ handleSymbol関数内の lastSound 送信部分をこれに書き換え ↓↓↓
            // ---------------------------------------------------------
            // ★修正: REVERSEなどの即時発動カード処理
            // ---------------------------------------------------------
            // 1. まず手札から出したカードを取り除く (ここで newHand を定義！)
            let updates = {};
            let newHand = [...currentHand];
            newHand.splice(idx, 1);

            // 2. 残り枚数を計算して、音のセットを作成
            let nextTotal = newHand.length + myHackedCount;

            let soundList = [card.val]; // 例: ['REVERSE']
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            // 3. データを更新
            updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;
            let newGraveSym = [...(gameState.graveSym || [])];
            newGraveSym.push(card);
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;

            let logMsg = `${myName}が [${card.val}] を使用して`;
            if (card.val === "REVERSE") {
                updates[`rooms/${currentRoom}/isReverse`] = !gameState.isReverse;
                logMsg += "強弱を逆転させました";
            }

            await pushLog(logMsg, 'public');

            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await db.ref().update(updates);
            selectedIdx = -1;
        }

        // ↓↓↓ execDigUp関数を丸ごとこれに置き換えてください ↓↓↓
        async function execDigUp(digUpIdx, returnIdx) {
            closeModal();
            let updates = {};
            let newHand = sortCards(deepCopy(gameState.hands[myId]));
            let gn = [...gameState.graveNum];
            
            // 処理
            let top = gn.pop(); 
            let usedDigUp = newHand.splice(digUpIdx, 1)[0]; 
            let newGraveSym = [...(gameState.graveSym || []), usedDigUp];
            
            // インデックス調整
            let actualReturnIdx = (returnIdx > digUpIdx) ? returnIdx - 1 : returnIdx;
            let retCard = newHand.splice(actualReturnIdx, 1)[0];
            newHand.push(top);
            
            gn.push({ ...retCard, owner: myId }); 
            newHand = sortCards(newHand);
            
            updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;
            
            // ★修正: UNO/DOS音の追加
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = newHand.length + myHackedCount;

            let soundList = ['DIG UP'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            updates[`rooms/${currentRoom}/graveNum`] = gn;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await pushLog(`${myName}が [DIG UP] を使用して [${top.val}] を回収し、[${retCard.val}] を埋めました。`, 'public');
            
            await db.ref().update(updates);
            selectedIdx = -1;
        }

        /* --- 通常のTRADE改修 (狙い撃ち対応) --- */

        // 元の tradeStep2 を「奪うカード選択」に上書き
        // (handleSymbol からはこれが呼ばれます)
        /* --- 修正版: tradeStep2 (フォントバレ防止) --- */
        function tradeStep2(targetId, tradeCardIdx) {
            let targetHand = deepCopy(gameState.hands[targetId] || []);
            
            // 元のインデックスを記録してシャッフル
            targetHand.forEach((c, i) => c.originalIndex = i);
            shuffle(targetHand);

            let html = `<p>相手の手札から<strong>欲しいカード</strong>を選んでください。<br>
                        <span style="font-size:11px;">(通常は裏向きですが、公開カードは見えます)</span></p>
                        <div class="modal-list">`;

            targetHand.forEach(c => {
                let content = "?";
                let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
                let cssClass = "card"; // ★修正: 初期値はただのcard

                // 公開カードなら中身を表示
                // ★ハッキングチェック
                if (c.isHacked) {
                    cssClass += " hacked";
                    style = "cursor:not-allowed; border:1px solid #555; background:#333;";
                    content = "🔒"; // 裏向きでもロックされていることはわかる
                    onClick = ""; // クリック無効
                }
                // 公開カードチェック (ハックされてたらロック優先)
                else if (c.isOpen) {
                    cssClass = `card ${c.type}`;
                    content = c.val;
                    style = "cursor:pointer; ";
                    let cImg = CARD_IMAGES[c.val];
                    if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                }

                html += `<div class="${cssClass}" style="${style}" 
                        onclick="tradeStep3('${targetId}', ${tradeCardIdx}, ${c.originalIndex})">
                        ${content}
                        </div>`;
            });
            
            html += `</div>`;
            openModal("TRADE: 略奪選択", html);
        }

        // 新設: 自分の渡すカードを選ぶ (旧 tradeStep2 の中身)
        function tradeStep3(targetId, tradeCardIdx, takeIdx) {
            let myHand = sortCards(deepCopy(gameState.hands[myId]));
            let html = `<p>相手に渡すカードを選んでください。</p><div class="modal-list">`;
            
            myHand.forEach((c, i) => {
                if (i === tradeCardIdx) return; // コストとして払うTRADEカードは選べない
                
                let style = "";
                let cImg = CARD_IMAGES[c.val];
                if (cImg) {
                    style = `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                }

                // 実行 (execTrade に takeIdx を渡す)
                html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                        onclick="execTrade('${targetId}', ${tradeCardIdx}, ${i}, ${takeIdx})">${c.val}</div>`;
            });
            
            html += `</div>`;
            openModal("TRADE: 譲渡選択", html);
        }

        // 実行処理 (引数 takeIdx を追加)
        // ↓↓↓ execTrade関数を丸ごとこれに置き換えてください ↓↓↓
        async function execTrade(targetId, tradeCardIdx, giveCardIdx, takeIdx) {
            closeModal();
            let updates = {};
            let myHand = sortCards(deepCopy(gameState.hands[myId]));
            let targetHand = sortCards(deepCopy(gameState.hands[targetId]));
            
            // コスト支払い
            let usedTrade = myHand.splice(tradeCardIdx, 1)[0];
            let newGraveSym = [...(gameState.graveSym || []), usedTrade];
            
            // インデックス調整
            let actualGiveIdx = (giveCardIdx > tradeCardIdx) ? giveCardIdx - 1 : giveCardIdx;
            
            // 交換実行
            let giveCard = myHand.splice(actualGiveIdx, 1)[0];
            let receiveCard = targetHand.splice(takeIdx, 1)[0];
            
            myHand.push(receiveCard);
            targetHand.push(giveCard);
            myHand = sortCards(myHand);
            targetHand = sortCards(targetHand);
            
            updates[`rooms/${currentRoom}/hands/${myId}`] = myHand;
            updates[`rooms/${currentRoom}/hands/${targetId}`] = targetHand;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            
            await pushLog(`${myName}が [TRADE] を使用して${gameState.players[targetId].name} とカードを交換しました`, 'public');
            await pushLog(`${gameState.players[targetId].name}から [${receiveCard.val}] を奪い、[${giveCard.val}] を渡しました。`, 'private', myId);
            await pushLog(`${gameState.players[myId].name}に [${receiveCard.val}] を奪われ、 [${giveCard.val}] を渡されました。`, 'private', targetId);

            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
                fromName: myName + "(TRADE)",
                lostVal: receiveCard.val,
                gotVal: giveCard.val
            };

            // ★修正: UNO/DOS音の追加
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = myHand.length + myHackedCount;

            let soundList = ['TRADE'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };
            
            await db.ref().update(updates);
            selectedIdx = -1;
        }

        // ↓↓↓ execDiscard関数を丸ごとこれに置き換えてください ↓↓↓

        async function execDiscard(useCardIdx, targetIdx) {
            closeModal();
            let updates = {};
            let currentHand = sortCards(deepCopy(gameState.hands[myId]));

            // 1. コストとして使う「DISCARD」カード自体
            let usedCard = currentHand.splice(useCardIdx, 1)[0];
            let newGraveSym = [...(gameState.graveSym || []), usedCard];

            // 2. 捨てられるカード
            // (UIの仕組み上、splice後のインデックスが渡ってくるのでそのまま使えます)
            let discardCard = currentHand.splice(targetIdx, 1)[0];

            // ★ここが修正ポイント：種類によって送り先を変える
            let newGraveNum = [...(gameState.graveNum || [])];

            if (discardCard.type === 'num') {
                // 数字なら「数字墓地」へ（これで場のトップが更新され、バグが直る！）
                // ownerを自分にすることで、責任の所在を明確にする
                newGraveNum.push({ ...discardCard, owner: myId });
            } else {
                // 記号なら「記号墓地」へ
                newGraveSym.push(discardCard);
            }
            currentHand = sortCards(currentHand);
            
            // 音のセットを作成
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = currentHand.length + myHackedCount;

            let soundList = ['DISCARD'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };
            
            // 墓地情報を更新（除外場 exclusion への追加は削除）
            updates[`rooms/${currentRoom}/graveNum`] = newGraveNum;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            updates[`rooms/${currentRoom}/hands/${myId}`] = currentHand;
        
            await pushLog(`${myName}が [DISCARD] で [${discardCard.val}] を捨てました！！`, 'public');

            updates[`rooms/${currentRoom}/passCount`] = 0;

            // あがり判定
            if (currentHand.length === 0 && myHackedCount === 0) {
                let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');

                // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
                updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
                updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
                // ▲▲▲ 追加ここまで ▲▲▲

                let totalPlayers = gameState.playerOrder.length;
                if (currentRank >= totalPlayers - 1) {
                         updates[`rooms/${currentRoom}/status`] = "finished";

                        // 敗者（最後の一人）を特定
                        let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！　最下位 ${lName} の残り手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！`, 'public');
                        }
                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                }
            }

            let tempRankings = {...(gameState.rankings || {})};
            if(currentHand.length === 0) tempRankings[myId] = 99;

            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await db.ref().update(updates);
            selectedIdx = -1;
        }

        function isMyTurn() {
            if (!gameState || !gameState.playerOrder) return false;
            return gameState.playerOrder[gameState.turnIdx] === myId;
        }
        function getTop(arr) { return (arr && arr.length > 0) ? arr[arr.length-1] : null; }
        function canPlay(card, topCard, isRev) {
            if (!topCard) return true;
            if (card.val === 0 || topCard.val === 0) return true;
            return isRev ? (card.val < topCard.val) : (card.val > topCard.val);
        }
        function shuffle(arr) { for(let i=arr.length-1; i>0; i--){ let j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
        function renderPile(arr) {
            if (!arr || arr.length === 0) return "";
            let c = arr[arr.length-1];
            let style = '';
            let imgUrl = CARD_IMAGES[c.val];
            let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
            return `<div class="card ${c.type}" style="${style} ${imgStyle}">${c.val}</div>`;
        }

        function getActiveCount(data) {
            if(!data || !data.playerOrder) return 0;
            let finishedCount = Object.keys(data.rankings || {}).length;
            return Math.max(1, data.playerOrder.length - finishedCount);
        }

        function getNextActivePlayerIndex(currentIdx, playerOrder, rankings) {
            let next = (currentIdx + 1) % playerOrder.length;
            let loop = 0;
            while (rankings && rankings[playerOrder[next]] && loop < playerOrder.length) {
                next = (next + 1) % playerOrder.length;
                loop++;
            }
            return next;
        }
	// 追加: リセット処理の実体
        async function execPassReset() {
            // 既存の「ドローなしでリセット」する処理へ委譲します
            return execPassNoDraw(true);
        }
/* --- ANGLER (釣り人) の実装 --- */

// ステップ1: 手札から除外するカードを選ぶ
function activateAngler() {
    let hand = gameState.hands[myId] || [];
    if(hand.length === 0) return showInfoModal("エラー", "手札がないため発動できません");
    
    // 墓地が空っぽか確認（拾うものがないと損するだけなので警告、でもルール上は発動できそうだが一応チェック）
    let gn = gameState.graveNum || [];
    let gs = gameState.graveSym || [];
    if(gn.length === 0 && gs.length === 0) return showInfoModal("エラー", "墓地にカードがないため釣れません");

    let html = `<p>エサとして除外する手札を選んでください。</p><div class="modal-list">`;
    hand.forEach((c, i) => {
        // カード表示用の共通処理（画像など）
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // クリックでステップ2へ
        html += `<div class="card ${c.type}" style="${style}" onclick="anglerStep2(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("釣り人: エサ選択", html);
}

// ステップ2: 墓地から拾うカードを選ぶ
function anglerStep2(excludeIdx) {
    let gn = gameState.graveNum || [];
    let gs = gameState.graveSym || [];
    
    let html = `<p>墓地から釣り上げるカードを選んでください。</p><div class="modal-list" style="justify-content:flex-start;">`;
    
    // 数字墓地
    gn.forEach((c, i) => {
        let style = '';
        html += `<div class="card num" style="${style}" onclick="execAngler(${excludeIdx}, 'num', ${i})">${c.val}<span style="font-size:8px; display:block;"></span></div>`;
    });
    // 記号墓地
    gs.forEach((c, i) => {
        let cImg = CARD_IMAGES[c.val];
        let style = cImg ? `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;` : '';
        html += `<div class="card sym" style="${style}" onclick="execAngler(${excludeIdx}, 'sym', ${i})">${c.val}</div>`;
    });
    
    html += `</div>`;
    openModal("釣り人: 釣魚選択", html);
}

// ステップ3: 実行
async function execAngler(excludeIdx, targetType, targetGraveIdx) {
    closeModal();
    let updates = {};
    
    // データのコピー
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let gn = [...(gameState.graveNum || [])];
    let gs = [...(gameState.graveSym || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 1. 手札を除外
    let excludedCard = hand.splice(excludeIdx, 1)[0];
    excl.push(excludedCard);

    // 2. 墓地から回収
    let pickedCard;
    if (targetType === 'num') {
        pickedCard = gn.splice(targetGraveIdx, 1)[0];
    } else {
        pickedCard = gs.splice(targetGraveIdx, 1)[0];
    }
    hand.push(pickedCard);
    hand = sortCards(hand); // 手札整理

    // 3. データ更新準備
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    updates[`rooms/${currentRoom}/graveNum`] = gn;
    updates[`rooms/${currentRoom}/graveSym`] = gs;
    
    // 使用済みフラグON
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ログ
    await pushLog(`${myName}が[釣り人]を発動！手札を除外して墓地の [${pickedCard.val}] を釣り上げました`, 'public');
    //playSoundEffect('SKILL'); 

    // 4. ターン終了処理
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- FORTUNE TELLER (占い師) の実装 --- */
// 修正版: ログに詳細を残す機能を追加

async function activateFortuneTeller() {
    // 1. 他のプレイヤーの情報を収集
    let html = `<div style="text-align:left;">`;
    let logText = ``; // ★ログ保存用のテキスト
    
    const pIds = gameState.playerOrder;
    
    pIds.forEach(pid => {
        if (pid === myId) return; // 自分はスキップ

        const pName = gameState.players[pid].name;
        const pRole = gameState.roles[pid];
        const pRoleJP = (ROLE_INFO[pRole]) ? ROLE_INFO[pRole].jp : pRole;
        const pHand = gameState.hands[pid] || [];

        // 手札の内容（表示用HTML）
        let handHtml = pHand.map(c => {
             // 画像があるかチェック
             let imgUrl = CARD_IMAGES[c.val];
             
             // 共通のスタイル（小さめのカードにする）
             let baseStyle = "display:inline-block; width:30px; height:45px; border-radius:4px; margin:2px; vertical-align:middle; line-height:45px; text-align:center; font-weight:bold; border:1px solid #ccc; background:#fafafa; color:#333; position:relative;";
             
             // 画像がある場合（記号など）：背景画像にして文字を消す
             if (imgUrl) {
                 return `<span class="card ${c.type}" style="${baseStyle} background-image:url('${imgUrl}'); background-size:cover; color:transparent; border:none;">${c.val}</span>`;
             }
             
             // 画像がない場合（数字など）：数字を表示
             // 数字の「0」だけは紫色にする
             
             // 普通の数字
             return `<span class="card ${c.type}" style="${baseStyle}">${c.val}</span>`;
        }).join("");

        // 手札の内容（ログ保存用の簡易テキスト）
        let handText = pHand.map(c => c.val).join(", ");

        // モーダル用HTML作成
        html += `
            <div style="margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
                <div style="font-weight:bold; color:#fdd835;">${pName}</div>
                <div style="font-size:12px;">役職: <span style="color:#e1bee7;">${pRoleJP}</span></div>
                <div style="font-size:12px;">手札: ${handHtml}</div>
            </div>
        `;

        // ★ログ用テキスト作成（改行を入れて見やすく）
        logText += `[${pName}] 役職:${pRoleJP} / 手札:${handText}<br>`;
    });

    html += `</div><p style="font-size:12px; color:#aaa;">※この内容はログ(チャット履歴)にも保存されました。</p>`;

    // 2. サーバー更新
    let updates = {};
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true; // 使用済みにする
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    
    // 全員への通知（中身は言わない）
    await pushLog(`${myName}が[占い師]を発動！水晶玉を覗き込みました...`, 'public');
    
    // ★自分だけのメモとして詳細を保存（ここがポイント！）
    // type='private', targetId=myId にすることで自分にしか見えません
    await pushLog(`【占い結果メモ】<br>${logText}`, 'private', myId);
    
    //playSoundEffect('SKILL'); 
    
    // データベース更新
    await db.ref().update(updates);

    // 3. モーダルで情報を表示
    openModal("占い師: 千里眼", html);
}

/* --- THIEF (盗賊) の実装 (修正版) --- */
// トレードを2回まで行える (1回でやめてもOK)

// 1. ターゲット選択
/* --- THIEF (盗賊) の実装 (ババ抜き形式) --- */
// 1. ターゲット選択 -> 2. 奪うカード選択(New) -> 3. 渡すカード選択 -> 4. 実行

// 1. ターゲット選択
function activateThief(count = 1) {
    let html = `<p><strong>【盗賊スキル ${count}/2回目】</strong><br>トレードする相手を選んでください。</p>`;
    
    const pIds = gameState.playerOrder;
    pIds.forEach(pid => {
        if (pid === myId) return; 
        if (gameState.rankings && gameState.rankings[pid]) return; 

        const pName = gameState.players[pid].name;
        // 公開情報の表示（警察官などでバレている場合）
        const hand = gameState.hands[pid] || [];
        const handLen = hand.length;
        let revealed = hand.filter(c => c.isOpen).map(c => c.val).join(", ");
        let revealedInfo = revealed ? `<br><span style="font-size:11px; color:#000000;">(公開: ${revealed})</span>` : "";

        html += `<button onclick="thiefSelectTake('${pid}', ${count})" style="display:block; width:100%; margin:5px 0; padding:10px;">
            ${pName} (手札${handLen}枚)${revealedInfo}
        </button>`;
    });

    openModal(`盗賊: ターゲット選択 (${count}回目)`, html);
    if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
}

// 2. ★追加: 奪うカードを選ぶ（裏向きシャッフル）
/* --- 修正版: 盗賊 (ハッカー対応) --- */

// 奪うカード選択
function thiefSelectTake(targetId, count) {
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p>相手の手札から<strong>奪うカード</strong>を選んでください。<br>
                <span style="font-size:11px;">(公開カードは見えます)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "?";
        let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        let cssClass = "card"; 
        let onClick = `onclick="thiefSelectGive('${targetId}', ${c.originalIndex}, ${count})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            style = "cursor:not-allowed; border:1px solid #555; background:#333;";
            content = "🔒"; 
            onClick = "";
        }
        else if (c.isOpen) {
            cssClass = `card ${c.type}`;
            content = c.val;
            style = "cursor:pointer; "; 
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });
    
    openModal(`盗賊: 略奪選択 (${count}回目)`, html);
    if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
}

// 渡すカード選択
function thiefSelectGive(targetId, takeIdx, count) {
    const myHand = sortCards(deepCopy(gameState.hands[myId] || []));

    let html = `<p>相手に押し付けるカードを選んでください。</p><div class="modal-list">`;
    
    myHand.forEach((c, idx) => {
        let style = "";
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execThiefTrade('${targetId}', ${idx}, ${takeIdx}, ${count})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            onClick = "";
        }

        html += `<div class="${cssClass}" style="${style} cursor:pointer;" ${onClick}>${c.val}</div>`;
    });

    openModal(`盗賊: 譲渡選択 (${count}回目)`, html);

    if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
}

// 3. 自分の手札から「押し付けるカード」を選ぶ
function thiefSelectGive(targetId, takeIdx, count) {
    const myHand = sortCards(deepCopy(gameState.hands[myId] || []));

    let html = `<p>相手に押し付けるカードを選んでください。</p><div class="modal-list">`;
    
    myHand.forEach((c, idx) => {
        let style = "";
        
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // 実行関数へ (takeIdx も渡す)
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                      onclick="execThiefTrade('${targetId}', ${idx}, ${takeIdx}, ${count})">
                      ${c.val}
                 </div>`;
    });
    

    openModal(`盗賊: 譲渡選択 (${count}回目)`, html);

    if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
}

// 4. トレード実行処理 (ランダムではなく指定インデックスで)
async function execThiefTrade(targetId, giveIdx, takeIdx, count) {
    closeModal();
    const updates = {};
    
    let myHand = [...(gameState.hands[myId] || [])];
    let targetHand = [...(gameState.hands[targetId] || [])]; // 相手の手札(ソート済み)
    
    if (targetHand.length === 0) {
        showInfoModal("エラー", "相手の手札がありません！");
        return;
    }

    // --- トレード実行 ---
    // 自分が出すカード
    const giveCard = myHand.splice(giveIdx, 1)[0]; 
    // 相手から奪うカード (指定したインデックス)
    const receiveCard = targetHand.splice(takeIdx, 1)[0]; 
    
    myHand.push(receiveCard); 
    targetHand.push(giveCard); 

    // カード移動後の整理
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);
    
    const targetName = gameState.players[targetId].name;
    
    // ログ出力
    await pushLog(`${myName}が[盗賊]で${targetName}とトレードしました！(${count}回目)`, 'public');
    await pushLog(`${targetName}から [${receiveCard.val}] を盗み、 [${giveCard.val}] を奪いました。`, 'private', myId);
    await pushLog(`${myName}に [${receiveCard.val}] を盗まれ、 [${giveCard.val}] を渡されました。`, 'private', targetId);

    // 通知
    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(盗賊)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };

    // 音（2回目は専用音）
    if (count === 2) {
         const skillSound = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_THIEF']) ? 'SKILL_THIEF' : 'SKILL';
         updates[`rooms/${currentRoom}/lastSound`] = { type: skillSound, id: Date.now() };
    }

    // 1回目なら使用済みフラグを立てる
    if (count === 1) {
        let actList = {...(gameState.activatedList || {})};
        actList[myId] = true; 
        updates[`rooms/${currentRoom}/activatedList`] = actList;
    }

    await db.ref().update(updates);

    // 次の行動確認
    if (count === 1) {
        let confirmHtml = `
            <p>1回目のトレードが完了しました。<br>
            <strong>奪ったカード: ${receiveCard.val}</strong><br>
            続けて2回目のトレードを行いますか？
            </p>
            <button onclick="activateThief(2)" style="width:100%; padding:15px; background:#d32f2f; color:white; font-weight:bold; margin-bottom:10px;">
                はい (もう一度盗む)
            </button>
            <button onclick="endThiefTurn()" style="width:100%; padding:15px; background:#444; color:white;">
                いいえ (ターンを終了する)
            </button>
        `;
        openModal("盗賊: 追撃の選択", confirmHtml);
        
        if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
    } else {
        endThiefTurn();
    }
}
// 4. ターン終了処理
async function endThiefTurn() {
    closeModal();
    
    // ★修正: gameState.turnIdx を使うように変更（念のため）
    let currentTurnIdx = (typeof turnIdx !== 'undefined') ? turnIdx : gameState.turnIdx;
    let nextIdx = (currentTurnIdx + 1) % gameState.playerOrder.length;
    
    let updates = {};
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
    updates[`rooms/${currentRoom}/passCount`] = 0; 
    updates[`rooms/${currentRoom}/lastAction`] = "THIEF_END";

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await db.ref().update(updates);
    await pushLog(`${myName}の[盗賊]が終了しました。`, 'public');
}

/* --- HUNTER (狩人) の実装 (UI改善版) --- */

function activateHunter() {
    let deckSym = gameState.deckSym || [];
    let hand = gameState.hands[myId] || [];
    
    if (deckSym.length === 0) return showInfoModal("エラー", "記号山札が空です。");

    let html = `
        <p style="font-size:12px;">
            記号山札の中身をすべて確認できます。<br>
            交換したいカードをタップして、<strong>「手札」と「山札」を同じ枚数</strong>にしてください。<br>
            <span style="color:#d32f2f;">※この画面を開いた時点でスキル使用済みとなります。</span>
        </p>
        
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
            <div style="width:48%; background:rgba(0,0,0,0.05); border-radius:8px; padding:5px;">
                <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; font-size:12px;">自分の手札 (除外)</div>
                <div id="hunter-hand-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>
            </div>

            <div style="width:48%; background:rgba(0,0,0,0.05); border-radius:8px; padding:5px;">
                <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; font-size:12px;">記号山札 (入手)</div>
                <div id="hunter-deck-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>
            </div>
        </div>

        <div style="margin-top:15px; text-align:center;">
            <p id="hunter-msg" style="color:#d32f2f; font-size:12px; font-weight:bold;">枚数が一致していません</p>
            
            <button onclick="execHunterSwap()" id="btn-hunter-exec" disabled 
                style="background:#ccc; color:#fff; padding:10px 30px; font-weight:bold; border-radius:20px;">交換して終了</button>
            <br>
            <button onclick="execHunterSwap(true)" style="background:#546e7a; color:#fff; margin-top:10px; padding:8px 20px; font-size:12px; border-radius:20px;">
                交換せずに終了
            </button>
        </div>
    `;

    openModal("狩人: 武器の選定", html);
    document.getElementById("modal-footer").innerHTML = ""; // 閉じるボタン削除

    // --- カードリスト生成関数 ---
    const createCardDiv = (c, i, type) => {
        let imgUrl = CARD_IMAGES[c.val];
        // 基本スタイル
        let style = "width:40px; height:60px; font-size:10px; cursor:pointer; transition:transform 0.1s; border:1px solid #999;";
        if (imgUrl) style += `background-image:url('${imgUrl}'); color:transparent; border:none;`;
        
        // クリックイベント: toggleHunterSelect(要素, タイプ, インデックス)
        return `<div class="card ${c.type} hunter-item" id="hunter-${type}-${i}" 
                    data-idx="${i}" data-type="${type}"
                    style="${style}" 
                    onclick="toggleHunterSelect(this)">
                    ${c.val}
                </div>`;
    };

    // 1. 手札リスト (記号のみ)
    let handHtml = "";
    hand.forEach((c, i) => {
        if (c.type === 'sym') handHtml += createCardDiv(c, i, 'hand');
    });
    document.getElementById("hunter-hand-list").innerHTML = handHtml;

    // 2. 山札リスト (すべて)
    let deckHtml = "";
    deckSym.forEach((c, i) => {
        deckHtml += createCardDiv(c, i, 'deck');
    });
    document.getElementById("hunter-deck-list").innerHTML = deckHtml;
}

// カード選択の切り替え & チェック
function toggleHunterSelect(el) {
    // クラス "selected-hunter" をつけ外しする
    if (el.classList.contains('selected-hunter')) {
        el.classList.remove('selected-hunter');
        el.style.border = el.style.backgroundImage ? "none" : "1px solid #999";
        el.style.transform = "scale(1)";
        el.style.boxShadow = "none";
    } else {
        el.classList.add('selected-hunter');
        // 選択時の見た目 (オレンジ色の太枠 + 少し拡大)
        el.style.border = "3px solid #ff9800";
        el.style.transform = "scale(1.1)";
        el.style.boxShadow = "0 0 5px rgba(255, 152, 0, 0.8)";
    }
    
    checkHunterCount(); // ボタン状態更新
}

// 枚数チェック関数
function checkHunterCount() {
    // クラス名で選択されている要素を数える
    let handSel = document.querySelectorAll('#hunter-hand-list .selected-hunter').length;
    let deckSel = document.querySelectorAll('#hunter-deck-list .selected-hunter').length;
    
    let btn = document.getElementById('btn-hunter-exec');
    let msg = document.getElementById('hunter-msg');

    if (handSel > 0 && handSel === deckSel) {
        btn.disabled = false;
        btn.style.background = "#e65100"; // 狩人っぽいオレンジ
        msg.innerText = `OK! (${handSel}枚交換)`;
        msg.style.color = "#e65100";
    } else {
        btn.disabled = true;
        btn.style.background = "#ccc";
        if (handSel === 0 && deckSel === 0) {
            msg.innerText = "交換するカードを選んでください";
        } else {
            msg.innerText = `枚数が一致していません (手札:${handSel} vs 山札:${deckSel})`;
        }
        msg.style.color = "#d32f2f";
    }
}

// 実行処理（山札循環・シャッフル追加版）
async function execHunterSwap(isSkip = false) {
    closeModal();
    
    let updates = {};
    let actList = {...(gameState.activatedList || {})};

    if (!isSkip) {
        // 選択された要素を取得
        let handEls = document.querySelectorAll('#hunter-hand-list .selected-hunter');
        let deckEls = document.querySelectorAll('#hunter-deck-list .selected-hunter');

        // インデックスを取り出して降順ソート
        let handIndices = Array.from(handEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);
        let deckIndices = Array.from(deckEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);

        let hand = sortCards(deepCopy(gameState.hands[myId]));
        let deckSym = [...(gameState.deckSym || [])];
        let excl = [...(gameState.exclusion || [])]; // 今回は使いませんが念のため

        let outNames = [];
        let inNames = [];

        // 1. 手札から出す（山札に戻す）
        handIndices.forEach(idx => {
            let c = hand.splice(idx, 1)[0];
            // excl.push(c); // ← 元の「除外」処理
            deckSym.push(c); // ★変更: 記号山札に追加！
            outNames.push(c.val);
        });

        // 2. 山札から取る
        deckIndices.forEach(idx => {
            let c = deckSym.splice(idx, 1)[0];
            hand.push(c);
            inNames.push(c.val);
        });
        
        // ★追加: 山札の中身が変わったのでシャッフルする
        // (これをしないと、戻したカードが一番下や上に固まってしまうため)
        shuffle(deckSym);

        // 手札を整理
        hand = sortCards(hand);

        updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
        updates[`rooms/${currentRoom}/deckSym`] = deckSym; 
        // updates[`rooms/${currentRoom}/exclusion`] = excl; // 除外場は変わらないので更新不要（またはそのまま更新してもOK）
        
        await pushLog(`${myName}が[狩人]を発動！手札 ${handIndices.length} 枚を記号山札と交換しました。`, 'public');
        await pushLog(`【狩りの成果】<br>使用武器(山札へ): ${outNames.join(', ')}<br>獲物: ${inNames.join(', ')}`, 'private', myId);

    } else {
        await pushLog(`${myName}が[狩人]を発動！交換せずに終了しました。`, 'public');
        await pushLog(`【狩りの成果】<br>なし`, 'private', myId);
    }

    // 共通処理
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    //playSoundEffect('SKILL');
    await db.ref().update(updates);
}

/* --- GAMBLER (賭博師) の実装 --- */
// 効果: 山札の数字を予想し、当たれば手札を捨て、外れればペナルティ。

// 1. 予想を選択する画面
function activateGambler() {
    let deck = gameState.deckNum || [];
    if (deck.length === 0) return showInfoModal("エラー", "数字山札がありません");

    let html = `
        <p>数字山札の一番上を予想してください。<br>
        <span style="font-size:12px; color:#666;">※実行すると全員に通知されます</span>
        </p>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <button onclick="execGamblerGuess('A')" style="padding:15px; background:#4fc3f7; color:#01579b; font-weight:bold; border-radius:8px;">
                A: 小さい (1, 2, 3, 4)<br>
                <span style="font-size:10px;">的中: 手札1枚捨て / 外れ: そのカード獲得</span>
            </button>
            <button onclick="execGamblerGuess('B')" style="padding:15px; background:#ffb74d; color:#e65100; font-weight:bold; border-radius:8px;">
                B: 大きい (6, 7, 8, 9)<br>
                <span style="font-size:10px;">的中: 手札1枚捨て / 外れ: そのカード獲得</span>
            </button>
            <button onclick="execGamblerGuess('C')" style="padding:15px; background:#ba68c8; color:#4a148c; font-weight:bold; border-radius:8px;">
                C: 命知らず (0, 5)<br>
                <span style="font-size:10px;">的中: 手札2枚捨て / 外れ: 獲得 + 1ドロー</span>
            </button>
        </div>
    `;
    openModal("賭博師: 運命の選択", html);
}

// --- 賭博師：送信処理（スクイーズ対応版） ---
async function execGamblerGuess(type) {
    closeModal();
    let updates = {};
    let deck = [...(gameState.deckNum || [])];
    
    let card = deck.pop(); 
    let val = card.val;
    let win = false;

    // 判定
    let guessText = "";
    if (type === 'A') {
        if ([1,2,3,4].includes(val)) win = true;
        guessText = "小さい [1-4]";
    } else if (type === 'B') {
        if ([6,7,8,9].includes(val)) win = true;
        guessText = "大きい [6-9]";
    } else if (type === 'C') {
        if ([0,5].includes(val)) win = true;
        guessText = "命知らず [0, 5]";
    }

    // --- ★演出データ送信 ---
    updates[`rooms/${currentRoom}/effect`] = {
        guessTitle: guessText,
        cardVal: val,
        sub: win ? "WIN!!" : "LOSE...",
        color: win ? "#d50000" : "#333",
        isWin: win,
        guessType: type, // ★追加: これで「大当たり」かどうか判定する
        timestamp: firebase.database.ServerValue.TIMESTAMP
    };
    // ------------------------

    await pushLog(`${myName}が[賭博師]を発動！: ${guessText} -> 結果は...?`, 'public');

    // データ更新
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/deckNum`] = deck;

    //playSoundEffect('SKILL'); // 演出開始の合図音

    // DB更新（これで全員の画面で演出が始まる）
    await db.ref().update(updates);

    // 結果処理の分岐（演出時間の5秒+余韻3秒 = 8秒待ってから画面を出す）
    if (win) {
        let discardCount = (type === 'C') ? 2 : 1;
        setTimeout(() => {
            gamblerSelectDiscard(discardCount);
        }, 6000); // 結果スタンプが出た1秒後くらいに操作画面へ

    } else {
        // ハズレ処理
        let hand = sortCards(deepCopy(gameState.hands[myId]));
        hand.push(card);
        if (type === 'C' && deck.length > 0) {
            let penaltyCard = deck.pop();
            hand.push(penaltyCard);
            updates[`rooms/${currentRoom}/deckNum`] = deck;
        }
        hand = sortCards(hand);
        
        // 遅延更新のために再度updatesを作る必要がある
        // （最初のupdateでDBは書き換わっているので、ここは追加処理）
        setTimeout(async () => {
            let finalUpdates = {};
            finalUpdates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            finalUpdates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            finalUpdates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await db.ref().update(finalUpdates);
            await pushLog(`結果: [${val}] でした。ペナルティを受けます。`, 'public');
        }, 6000);
    }
}

// 3. (勝利時) 捨てるカードを選ぶ画面
function gamblerSelectDiscard(count) {
    let hand = sortCards(deepCopy(gameState.hands[myId] || []));
    
    // 捨てる枚数が手札より多い場合のケア
    if (hand.length < count) count = hand.length;

    let html = `
        <p style="font-size:14px; font-weight:bold; color:#2e7d32;">
            おめでとうございます！<br>
            手札から <span style="font-size:18px;">${count}枚</span> 選んで捨ててください。
        </p>
        
        <div id="gambler-hand-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>

        <div style="margin-top:15px; text-align:center;">
             <p id="gambler-msg" style="font-size:12px;">あと ${count} 枚選んでください</p>
            <button onclick="execGamblerDiscard(${count})" id="btn-gambler-exec" disabled 
                style="background:#ccc; color:#fff; padding:10px 30px; border-radius:20px;">決定</button>
        </div>
    `;

    openModal("賭博師: 勝利の報酬", html);
    document.getElementById("modal-footer").innerHTML = ""; 

    // カードリスト生成 (狩人と同じUIを使用)
    let handHtml = "";
    hand.forEach((c, i) => {
        let imgUrl = CARD_IMAGES[c.val];
        let style = "width:40px; height:60px; font-size:10px; cursor:pointer; transition:transform 0.1s; border:1px solid #999;";
        if (imgUrl) style += `background-image:url('${imgUrl}'); color:transparent; border:none;`;

        handHtml += `<div class="card ${c.type} gambler-item" data-idx="${i}" 
                    style="${style}" 
                    onclick="toggleGamblerSelect(this, ${count})">
                    ${c.val}
                </div>`;
    });
    document.getElementById("gambler-hand-list").innerHTML = handHtml;
}

// 選択切り替え処理
function toggleGamblerSelect(el, maxCount) {
    if (el.classList.contains('selected-gambler')) {
        el.classList.remove('selected-gambler');
        el.style.border = (el.style.backgroundImage) ? "none" : (el.innerText=="0" ? "2px solid #ab47bc" : "1px solid #999");
        el.style.transform = "scale(1)";
    } else {
        // 選択可能枚数チェック
        let currentSel = document.querySelectorAll('.selected-gambler').length;
        if (currentSel >= maxCount) return; // これ以上選べない

        el.classList.add('selected-gambler');
        el.style.border = "3px solid #2e7d32"; // 緑枠
        el.style.transform = "scale(1.1)";
    }

    // ボタン制御
    let selCount = document.querySelectorAll('.selected-gambler').length;
    let btn = document.getElementById('btn-gambler-exec');
    let msg = document.getElementById('gambler-msg');

    if (selCount === maxCount) {
        btn.disabled = false;
        btn.style.background = "#2e7d32";
        msg.innerText = "OK!";
        msg.style.color = "#2e7d32";
    } else {
        btn.disabled = true;
        btn.style.background = "#ccc";
        msg.innerText = `あと ${maxCount - selCount} 枚選んでください`;
        msg.style.color = "#333";
    }
}

// 4. (勝利時) 捨てる実行処理
// ↓↓↓ execGamblerDiscard関数を丸ごとこれに置き換えてください ↓↓↓
        async function execGamblerDiscard(count) {
            closeModal();
            let updates = {};
            
            let handEls = document.querySelectorAll('.selected-gambler');
            let indices = Array.from(handEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);
            
            let hand = sortCards(deepCopy(gameState.hands[myId]));
            let graveNum = [...(gameState.graveNum || [])];
            let graveSym = [...(gameState.graveSym || [])];
            
            let discardedNames = [];

            // 手札から捨てて、それぞれの墓地へ
            indices.forEach(idx => {
                let c = hand.splice(idx, 1)[0];
                discardedNames.push(c.val);
                
                if (c.type === 'num') graveNum.push({...c, owner:myId});
                else graveSym.push(c);
            });

            hand = sortCards(hand);

            updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            updates[`rooms/${currentRoom}/graveNum`] = graveNum;
            updates[`rooms/${currentRoom}/graveSym`] = graveSym;
            updates[`rooms/${currentRoom}/passCount`] = 0;

            let tempRankings = {...(gameState.rankings || {})};
            if (hand.length === 0) tempRankings[myId] = 99; 

            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await pushLog(`${myName}が[賭博師]の報酬で [${discardedNames.join(', ')}] を捨てました！`, 'public');
            
            // ★重複エラー対策 & 同時再生対応
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = hand.length + myHackedCount;

            let soundList = ['DISCARD'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            // あがり判定
            if (hand.length === 0 && myHackedCount === 0) {
                let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');
                
                // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
                updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
                updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
                // ▲▲▲ 追加ここまで ▲▲▲
                
                let totalPlayers = gameState.playerOrder.length;
                if (currentRank >= totalPlayers - 1) {
                         updates[`rooms/${currentRoom}/status`] = "finished";

                        // 敗者（最後の一人）を特定
                        let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！！最下位 ${lName} の残り手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！！`, 'public');
                        }
                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                }
            }

            await db.ref().update(updates);
        }


/* --- バカラ風スクイーズ演出 --- */
function showVisualEffect(data) {
    let overlay = document.getElementById('visual-overlay');
    let guessDiv = document.getElementById('squeeze-guess');
    let contentDiv = document.getElementById('squeeze-content');
    let coverDiv = document.getElementById('squeeze-cover');
    let resultDiv = document.getElementById('squeeze-result');

    // 初期化
    guessDiv.innerHTML = `賭博師の予想: <br><span style="font-size:32px;">${data.guessTitle}</span>`;
    contentDiv.innerText = data.cardVal;
    
    coverDiv.style.transition = "none";
    coverDiv.style.top = "0%";
    
    resultDiv.style.transform = "translate(-50%, -50%) scale(0)";
    resultDiv.style.opacity = "0";
    resultDiv.innerText = data.sub;
    resultDiv.style.color = data.color;
    resultDiv.style.border = `4px solid ${data.color}`;
    resultDiv.style.padding = "10px 40px";
    resultDiv.style.borderRadius = "10px";
    resultDiv.style.background = "rgba(255,255,255,0.9)";

    // 表示
    overlay.style.display = "flex";
    
    // アニメーション開始
    setTimeout(() => {
        // ★追加: ここでドラムロール開始！
        playSoundEffect('DRUM');

        coverDiv.style.transition = "top 5s ease-in-out"; 
        coverDiv.style.top = "100%";
    }, 500);

    // 結果ドン！
    setTimeout(() => {
        resultDiv.style.opacity = "1";
        resultDiv.style.transform = "translate(-50%, -50%) scale(1)";
        
        // ★追加: 結果に応じた音を鳴らす
        if (data.isWin) {
            // C(0,5)なら大当たり、それ以外なら普通当たり
            if (data.guessType === 'C') {
                playSoundEffect('WIN_BIG'); 
            } else {
                playSoundEffect('WIN_NORMAL');
            }
        } else {
            playSoundEffect('LOSE');
        }

    }, 5000); // 5秒後 (ドラムロールが終わる頃)

    // 終了
    setTimeout(() => {
        overlay.style.display = "none";
    }, 8000);
}

/* --- CROWN (ピエロ) の実装 --- */
// 概要: パネル自体を「REVERSE」「TRADE」「DIG UP」のいずれかとして使う

// 1. 発動：効果を選択する
function activateMagician() {
    let html = `
        <p>どのサプライズを行いますか？<br>
        <span style="font-size:12px; color:#888;">※手札のカードは消費しません（コストとして必要な場合を除く）</span>
        </p>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <button onclick="execMagicianReverse()" style="padding:15px; background:#e91e63; color:white; font-weight:bold; border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span style="font-size:18px;">🔄 REVERSE</span>
                <span style="font-size:11px; margin-top:4px;">強弱をひっくり返す！</span>
            </button>
            <button onclick="activateMagicianTrade()" style="padding:15px; background:#ffb74d; color:#e65100; font-weight:bold; border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span style="font-size:18px;">🤝 TRADE</span>
                <span style="font-size:11px; margin-top:4px;">こっそりカードを交換する！</span>
            </button>
            <button onclick="activateMagicianDigUp()" style="padding:15px; background:#8d6e63; color:white; font-weight:bold; border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span style="font-size:18px;">⛏ DIG UP</span>
                <span style="font-size:11px; margin-top:4px;">カードを拾ってすり替える！</span>
            </button>
        </div>
    `;
    openModal("ピエロ: サプライズ選択", html);
}

// --- A: REVERSE (革命) ---
async function execMagicianReverse() {
    closeModal();
    let updates = {};
    
    // 革命フラグ反転
    updates[`rooms/${currentRoom}/isReverse`] = !gameState.isReverse;
    
    // ★ポイント: 使用済みリストに「何を使ったか」を書き込む
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "REVERSE"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ログなど
    await pushLog(`${myName}が[ピエロ]で[REVERSE] を使用して強弱を逆転させました`, 'public');
    //playSoundEffect('SKILL');
    //playSoundEffect('REVERSE');
    
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'REVERSE', id: Date.now() };
    // ターン進行
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

// --- B: TRADE (交換) ---
/* --- 修正版: ピエロ (ハッカー & 公開対応) --- */

// B: TRADE (交換) - 相手選択
function activateMagicianTrade() {
    let hand = gameState.hands[myId] || [];
    // 自分の手札が全てハッキングされていたら交換に出せるカードがない
    let availableHand = hand.filter(c => !c.isHacked);
    
    if (hand.length === 0) return showInfoModal("エラー", "手札がありません");
    if (availableHand.length === 0) return showInfoModal("ロック中", "ハッキングされていない手札がありません");

    let html = `<p>トレード相手を選んでください。</p>`;
    gameState.playerOrder.forEach(pid => {
        if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
        let p = gameState.players[pid];
        let count = gameState.hands[pid] ? gameState.hands[pid].length : 0;
        
        // ★変更: 次は「奪うカード選択 (magicianSelectTake)」へ
        if (count > 0) {
            html += `<button class="modal-btn" onclick="magicianSelectTake('${pid}')">${p.name} (手札${count})</button>`;
        }
    });
    openModal("ピエロ(TRADE): 相手選択", html);
}

// ★新設: 奪うカード選択 (ハッカー & 公開対応)
function magicianSelectTake(targetId) {
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p>相手の手札から<strong>奪うカード</strong>を選んでください。<br>
                <span style="font-size:11px;">(公開カードは見えます)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "?";
        let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        let cssClass = "card"; 
        let onClick = `onclick="magicianSelectGive('${targetId}', ${c.originalIndex})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            style = "cursor:not-allowed; border:1px solid #555; background:#333;";
            content = "🔒"; 
            onClick = "";
        }
        // ★公開対応
        else if (c.isOpen) {
            cssClass = `card ${c.type}`;
            content = c.val;
            style = "cursor:pointer; ";
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });

    html += `</div>`;
    openModal("ピエロ(TRADE): 略奪選択", html);
}

// 渡すカード選択 (名前変更: SelectTradeCard -> SelectGive)
function magicianSelectGive(targetId, takeIdx) {
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>相手に渡すカードを選んでください。<br><span style="font-size:11px;">(ピエロの効果なのでTRADEカード自体は不要です)</span></p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execMagicianTrade('${targetId}', ${i}, ${takeIdx})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            onClick = "";
        }
        
        html += `<div class="${cssClass}" style="${style}" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;
    openModal("ピエロ(TRADE): 譲渡選択", html);
}

// 実行処理 (引数 takeIdx を追加)
async function execMagicianTrade(targetId, giveIdx, takeIdx) {
    closeModal();
    let updates = {};
    let myHand = sortCards(deepCopy(gameState.hands[myId]));
    let targetHand = sortCards(deepCopy(gameState.hands[targetId]));

    // 交換処理
    let giveCard = myHand.splice(giveIdx, 1)[0]; // 自分のカード
    // ★変更: 指定したカードを奪う
    let receiveCard = targetHand.splice(takeIdx, 1)[0]; // 相手のカード
    
    myHand.push(receiveCard);
    targetHand.push(giveCard);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);

    // 使用済み記録: TRADE
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "TRADE"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'TRADE', id: Date.now() };

    const targetName = gameState.players[targetId].name;

    await pushLog(`${myName}が[ピエロ]で[TRADE]を使用して${targetName} とカードを交換しました`, 'public');
    await pushLog(`[ピエロ]で${targetName}から [${receiveCard.val}] を奪い、[${giveCard.val}] を渡しました。`, 'private', myId);
    await pushLog(`[ピエロ]の${gameState.players[myId].name}に [${receiveCard.val}] を奪われ、 [${giveCard.val}] を渡されました。`, 'private', targetId);

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(ピエロ)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };
    
    await db.ref().update(updates);
}

// --- C: DIG UP (発掘) ---
function activateMagicianDigUp() {
    let gn = gameState.graveNum || [];
    if (gn.length === 0) return showInfoModal("エラー", "数字墓地がないため拾えません");

    let hand = gameState.hands[myId] || [];
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("エラー", "埋めるための数字カードが手札にありません");

    // 埋めるカードを選ぶ
    let html = `<p>墓地の一番上を拾います。<br>代わりに埋めるカード(数字)を選んでください。</p><div class="modal-list">`;
    hand.forEach((c, i) => {
        if (c.type !== 'num') return; // 数字以外は埋められないルール
        let style = '';
        html += `<div class="card ${c.type}" style="${style}" onclick="execMagicianDigUp(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("ピエロ(DIG UP): 埋葬選択", html);
}

async function execMagicianDigUp(buryIdx) {
    closeModal();
    let updates = {};
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let gn = [...(gameState.graveNum || [])];
    
    // 処理: 墓地トップ取得 → 手札埋め → 手札入れ替え
    let top = gn.pop(); 
    let buryCard = hand.splice(buryIdx, 1)[0];
    hand.push(top);
    gn.push({...buryCard, owner:myId});

    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(hand);
    updates[`rooms/${currentRoom}/graveNum`] = gn;

    // ★使用済み記録: DIG UP
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "DIG UP"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'DIG UP', id: Date.now() };

    await pushLog(`${myName}が[ピエロ]の[DIG UP] を使用して [${top.val}] を回収し、[${buryCard.val}] を埋めました。`, 'public');
    //playSoundEffect('SKILL');
    //playSoundEffect('DIG UP');

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- MILLIONAIRE (富豪) の実装 --- */
function activateMillionaire() {
    let hand = gameState.hands[myId] || [];
    let deckSym = gameState.deckSym || [];

    // 除外できる数字カードがあるかチェック
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("エラー", "除外できる数字カードがありません");
    
    if (deckSym.length === 0) return showInfoModal("エラー", "記号山札が空です");

    let html = `<p>コストとして除外する数字カードを選んでください。<br><span style="font-size:11px;">(記号山札から1枚引きます)</span></p><div class="modal-list">`;
    hand.forEach((c, i) => {
        if (c.type !== 'num') return; 
        
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" onclick="execMillionaire(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("富豪: 資産運用", html);
}

async function execMillionaire(excludeIdx) {
    closeModal();
    let updates = {};
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deckSym = [...(gameState.deckSym || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 1. 手札を除外
    let excludedCard = hand.splice(excludeIdx, 1)[0];
    excl.push(excludedCard);
    
    // 音シグナル送信 (PUT音)
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'PUT', id: Date.now() };

    // 2. 記号山札からドロー
    let drawnCard = deckSym.pop();
    hand.push(drawnCard);
    hand = sortCards(hand);

    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckSym`] = deckSym;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await pushLog(`${myName}が[富豪]を発動！手札の [${excludedCard.val}] を支払って記号カードを買いました`, 'public');
    await pushLog(`【富豪の買い物】買ったカード: [${drawnCard.val}]`, 'private', myId);

    await db.ref().update(updates);
}

/* --- EMPEROR (皇帝) の実装 --- */

// 1. スキル発動：全カード回収＆選択画面
function activateEmperor() {
    // 全員の手札を回収して、ソートして表示する
    let allCards = [];
    let pIds = gameState.playerOrder;
    
    // 全回収
    pIds.forEach(pid => {
        let h = gameState.hands[pid] || [];
        allCards = allCards.concat(h);
    });

    if (allCards.length === 0) return showInfoModal("エラー", "カードがありません");

    // ★ご希望のソート処理
    // 数字は小さい順、記号は名前順
    allCards.sort((a, b) => {
        // タイプが違うなら数字が先
        if (a.type !== b.type) return a.type === 'num' ? -1 : 1;
        
        // 数字同士なら値の小さい順
        if (a.type === 'num') return a.val - b.val;
        
        // 記号同士なら名前順 (DIG UP, DISCARD, REVERSE, TRADE)
        return a.val.localeCompare(b.val);
    });

    // モーダル表示
    let html = `
        <p style="font-size:14px;">
            市民の手札をすべて回収しました。<br>
            <strong>あなたが望む「1枚」を選んでください。</strong><br>
            <span style="font-size:11px; color:#888;">残りは自動的に再分配されます。</span>
        </p>
        <div class="modal-list">
    `;

    allCards.forEach((c, i) => {
        // 通常のカードスタイル生成
        let style = "";
        
        // 画像があるなら背景にセット
        let cImg = CARD_IMAGES[c.val];
        if (cImg) {
            style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        }
        
        // クリックで実行（インデックスを渡す）
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                      onclick="execEmperorSelect(${i})">
                      ${c.val}
                 </div>`;
    });

    html += `</div>`;
    openModal("皇帝: 徴収と選定", html);
    document.getElementById("modal-footer").innerHTML = ""; // 戻るボタンなし
}

// 2. 選択実行＆再分配
async function execEmperorSelect(selectedIdx) {
    closeModal();
    let updates = {};

    // 1. もう一度全カードを回収・ソート（選択されたカードを特定するため）
    let pIds = gameState.playerOrder;
    let handCounts = {}; // 元の枚数を記録
    let allCards = [];
    
    pIds.forEach(pid => {
        let h = gameState.hands[pid] || [];
        handCounts[pid] = h.length;
        allCards = allCards.concat(h);
    });

    // ソート（activateと同じロジック）
    allCards.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'num' ? -1 : 1;
        if (a.type === 'num') return a.val - b.val;
        return a.val.localeCompare(b.val);
    });

    // 2. 皇帝が選んだカードを確保
    let emperorCard = allCards.splice(selectedIdx, 1)[0];

    // 3. 残りをシャッフル
    shuffle(allCards);

    // 4. 再分配 (皇帝の次の人から配る)
    // まず皇帝に選んだ1枚を持たせる
    let newHands = {};
    pIds.forEach(pid => newHands[pid] = []);
    newHands[myId].push(emperorCard);
    
    // 現在の皇帝のインデックス
    let myTurnIdx = gameState.turnIdx; 
    let totalPlayers = pIds.length;
    
    // カードを配るポインタ
    let cardPtr = 0;
    
    // 「皇帝の次の人」から順に、元の枚数になるまで配る
    // ループは最大でも (人数 * 最大手札枚数) 回程度なので安全
    for (let i = 1; i <= totalPlayers; i++) {
        let targetIdx = (myTurnIdx + i) % totalPlayers;
        let targetPid = pIds[targetIdx];
        
        // その人が本来持つべき枚数になるまで山から補充
        while (newHands[targetPid].length < handCounts[targetPid] && cardPtr < allCards.length) {
            newHands[targetPid].push(allCards[cardPtr]);
            cardPtr++;
        }
    }

    // 5. 手札をソートしてセット
    pIds.forEach(pid => {
        newHands[pid] = sortCards(newHands[pid]);
        updates[`rooms/${currentRoom}/hands/${pid}`] = newHands[pid];
    });

    // 6. ログと演出
    await pushLog(`${myName}が[皇帝]を発動！市民の手札を全て回収し、再分配しました。`, 'public');


    // 7. ターン終了
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    // 使用済みにする
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await db.ref().update(updates);
}

/* --- POLICE OFFICER (警察官) 完成版 --- */
// 1. 全員の手札を1枚ずつ公開 (即座にカットイン) -> 3秒待機 -> 2. 強制トレード

// ステップ1: 一斉捜査
async function activatePoliceOfficer() {
    let updates = {};
    let logs = [];
    
    // ★修正1: 発動した瞬間に「使用済み」にする
    // これにより、render関数が反応して「カットイン」と「音」が自動で流れます
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // 全員の手札をチェックして公開フラグを立てる
    gameState.playerOrder.forEach(pid => {
        if (pid === myId) return; 
        if (gameState.rankings && gameState.rankings[pid]) return; 

        let hand = deepCopy(gameState.hands[pid] || []);
        let hiddenIndices = [];
        hand.forEach((c, i) => { if (!c.isOpen) hiddenIndices.push(i); });

        if (hiddenIndices.length > 0) {
            let rand = Math.floor(Math.random() * hiddenIndices.length);
            let targetIdx = hiddenIndices[rand];
            
            hand[targetIdx].isOpen = true; // 公開！
            updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
            
            let pName = gameState.players[pid].name;
            logs.push(`${pName}の[${hand[targetIdx].val}]`);
        }
    });

    if (logs.length > 0) {
        await pushLog(`${myName}が[警察官]で一斉捜査！ ${logs.join('、')} を公開させました！`, 'public');
        // 音はrender関数が「activatedList」の変化を検知して鳴らすので、ここでは鳴らしません（二重再生防止）
    } else {
        await pushLog(`${myName}が[警察官]を発動しましたが、新たな証拠は見つかりませんでした。`, 'public');
    }

    await db.ref().update(updates);

    // ★修正2: カットイン演出の余韻（3秒）を待ってから、強制的にトレード画面へ
    setTimeout(() => {
        policeTradeStart();
    }, 3000); 
}

/* --- 警察官のトレード改修 (狙い撃ち対応) --- */

// ステップ2: トレード相手選択
function policeTradeStart() {
    let html = `
        <p><strong>【捜査協力の要請】</strong><br>続けてトレード(交換)を行いますか？<br>
        <span style="font-size:11px; color:#666;">(任意: 行わない場合は下のボタンで終了)</span>
        </p>

        <p style="margin-top:10px;">相手を選んでください</p>
    `;

    // 相手リスト生成
    gameState.playerOrder.forEach(pid => {
        if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
        let p = gameState.players[pid];
        let hand = gameState.hands[pid] || [];
        let count = hand.length;
        
        // 公開情報の表示
        let revealed = hand.filter(c => c.isOpen).map(c => c.val).join(", ");
        let revealedInfo = revealed ? `<br><span style="font-size:11px; color:#000000;">(公開: ${revealed})</span>` : "";

        if (count > 0) {
            html += `<button class="modal-btn" onclick="policeSelectTake('${pid}')">
                        ${p.name} (手札${count})${revealedInfo}
                     </button>`;
        }
    });
    
    // ▼▼▼ キャンセルボタン（トレードしない）を追加 ▼▼▼
    html += `
        <div style="margin-top:20px; border-top:1px solid #ccc; padding-top:10px;">
            <button onclick="endPoliceTurn()" style="background:#78909c; color:white; padding:10px 20px; border-radius:20px;">
                捜査を終了する (トレードしない)
            </button>
        </div>
    `;

    openModal("警察官: 捜査対象の選択", html);
    document.getElementById("modal-footer").innerHTML = ""; // 標準の閉じるボタンは消し、自前の終了ボタンを使わせる
}

// ★追加: トレードせずに終了する関数
async function endPoliceTurn() {
    closeModal();
    let updates = {};

    // ログ
    await pushLog(`${myName}がトレードなしで[警察官]の捜査を終了しました。`, 'public');

    // ターン終了処理
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- 修正版: policeSelectTake (フォントバレ防止) --- */
/* --- 修正版: 警察官 (ハッカー対応) --- */

// 奪うカード選択
function policeSelectTake(targetId) {
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p><strong>押収するカード</strong>を選んでください。<br>
                <span style="font-size:11px;">(公開カードは見えます)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "";
        let style = "cursor:pointer; ";
        let cssClass = "card"; 
        let onClick = `onclick="policeSelectGive('${targetId}', ${c.originalIndex})"`;

        if (c.isOpen) {
            cssClass = `card ${c.type}`; 
            content = c.val;
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        } else {
            content = "?";
            style += "background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });

    html += `</div>`;
    openModal("警察官: 押収品選択", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// 渡すカード選択
function policeSelectGive(targetId, takeIdx) {
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>相手に渡すカードを選んでください。</p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execPoliceTrade('${targetId}', ${i}, ${takeIdx})"`;

        html += `<div class="${cssClass}" style="${style} cursor:pointer;" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;
    openModal("警察官: 提出", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// ステップ3: 自分のカード選択 (引数に takeIdx を追加)
function policeSelectGive(targetId, takeIdx) {
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>相手に渡すカードを選んでください。</p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // execPoliceTrade に takeIdx も渡す
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                  onclick="execPoliceTrade('${targetId}', ${i}, ${takeIdx})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("警察官: 提出", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// ステップ4: トレード実行 (ランダムではなく指定インデックスで交換)
async function execPoliceTrade(targetId, giveIdx, takeIdx) {
    closeModal();
    let updates = {};
    let myHand = sortCards(deepCopy(gameState.hands[myId]));
    let targetHand = sortCards(deepCopy(gameState.hands[targetId])); // 相手の手札はソート済みの状態から取る

    // 交換実行
    let giveCard = myHand.splice(giveIdx, 1)[0];
    // ★変更: ランダムではなく、指定された takeIdx のカードを奪う
    let receiveCard = targetHand.splice(takeIdx, 1)[0];
    const targetName = gameState.players[targetId].name;
    
    myHand.push(receiveCard);
    targetHand.push(giveCard);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);

    updates[`rooms/${currentRoom}/lastSound`] = { type: 'TRADE', id: Date.now() };
    await pushLog(`${myName}が[警察官]として${targetName}とトレードを実行しました。`, 'public');
    await pushLog(`${targetName}から [${receiveCard.val}] を押収し、[${giveCard.val}] を渡しました。`, 'private', myId);
    await pushLog(`${myName}に [${receiveCard.val}] を押収され、[${giveCard.val}] を渡されました。`, 'private', targetId);
    
    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(警察官)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- HACKER (ハッカー) Ver 4.0 [隔離リスト方式] --- */

let hackerTargets = {}; 

// 1. 発動画面
function activateHacker() {
    hackerTargets = {}; 
    renderHackerUI();
}

function renderHackerUI() {
    let pIds = gameState.playerOrder;
    // ターゲット候補: 手札がある人
    let targets = pIds.filter(pid => 
        pid !== myId && 
        !gameState.rankings?.[pid] && 
        (gameState.hands[pid] || []).length > 0
    );

    let html = `
        <p><strong>システムへの侵入を開始します...</strong><br>
        対象プレイヤーの手札から<span style="color:#ef5350; font-weight:bold;">1枚ずつ</span>選び、
        ウイルス(ロック)を仕込んでください。
        </p>
        <div id="hacker-ui-container" style="text-align:left; max-height:300px; overflow-y:auto;">`;

    if (targets.length === 0) {
        html += `<p style="text-align:center; color:#ccc;">ハッキング可能な相手がいません。</p>`;
    }

    targets.forEach(pid => {
        let p = gameState.players[pid];
        let hand = gameState.hands[pid] || [];
        
        let selectedIdx = hackerTargets[pid]; 

        html += `<div style="margin-bottom:10px; background:rgba(0,0,0,0.05); padding:8px; border-radius:5px;">
                    <div style="font-weight:bold; font-size:12px; margin-bottom:5px; color:#333;">
                        ${p.name} <span style="font-size:10px; color:#666;">(手札:${hand.length})</span>
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:4px;">`;
        
        hand.forEach((c, i) => {
            let isSel = (selectedIdx === i);
            let cssClass = `card ${c.type}`;
            if (isSel) cssClass += " target-hack";
            
            let style = "width:36px; height:54px; font-size:12px; cursor:pointer; transition:0.1s;";
            let content = "?";

            if (c.isOpen) {
                content = c.val;
                let cImg = CARD_IMAGES[c.val];
                if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:none;`;
            } else {
                style += "background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
            }

            if (isSel) {
                style += "border:2px solid #ef5350 !important; transform:scale(1.1); box-shadow:0 0 8px #ef5350; opacity:1;";
            }

            html += `<div class="${cssClass}" style="${style}" onclick="selectHackerTarget('${pid}', ${i})">
                        ${content}
                     </div>`;
        });
        html += `</div></div>`;
    });

    html += `</div>`;
    
    let currentSelectCount = Object.keys(hackerTargets).length;
    let requiredCount = targets.length;
    let canExec = (currentSelectCount === requiredCount && requiredCount > 0);

    html += `<div style="text-align:center; margin-top:10px;">
                <p style="font-size:10px; color:${canExec ? '#2e7d32' : '#d32f2f'}; margin-bottom:5px;">
                    選択状況: ${currentSelectCount} / ${requiredCount} 人
                </p>
                <button onclick="execHacker()" ${canExec ? '' : 'disabled'} 
                style="background:${canExec ? '#d32f2f' : '#ccc'}; color:white; padding:10px 30px; font-weight:bold; border-radius:20px; transition:0.3s;">
                ウイルス送信
                </button>
             </div>`;

    openModal("ハッカー: 標的選択", html);
    document.getElementById("modal-footer").innerHTML = `<button onclick="closeModal()">キャンセル</button>`;
}

function selectHackerTarget(targetId, idx) {
    hackerTargets[targetId] = idx;
    renderHackerUI();
}

// 3. 実行処理 (手札からhackedHandsへ移動)
async function execHacker() {
    closeModal();
    let updates = {};
    
    // 現在の隔離リストを取得
    let currentHackedHands = deepCopy(gameState.hackedHands || {});

    Object.keys(hackerTargets).forEach(pid => {
        let idx = hackerTargets[pid];
        let hand = deepCopy(gameState.hands[pid] || []);
        
        if (hand[idx]) {
            // 1. 手札から抜く
            let targetCard = hand.splice(idx, 1)[0];
            
            // 2. IDを刻印
            targetCard.hackedBy = myId;
            
            // ★修正: 番号ではなく「時間」を記録する
            targetCard.hackedAt = Date.now();
            
            // 3. 隔離リストへ追加
            if (!currentHackedHands[pid]) currentHackedHands[pid] = [];
            currentHackedHands[pid].push(targetCard);
            
            // 4. DB更新準備
            updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
        }
    });

    updates[`rooms/${currentRoom}/hackedHands`] = currentHackedHands;

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'SKILL_HACKER', id: Date.now() };
    await pushLog(`${myName}が[ハッカー]を発動！システムをハッキングしました`, 'public');

    // ★削除: 以下の3行を削除（またはコメントアウト）してください！
    // ハッカーは能力使用後も自分のターンが続くルールです。
    /*
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
    */

    await db.ref().update(updates);
}

async function checkHackerCleanup() {
    if (!gameState || !gameState.hackedHands) return;
    
    // 自分のターンが来た時のみチェック
    if (isMyTurn()) {
        let updates = {};
        let needsUpdate = false;
        let currentHackedHands = deepCopy(gameState.hackedHands);

        // ★追加: 最後の「ゲームの動き(publicログ)」があった時間を取得
        let lastLogTime = 0;
        if (gameState.logs) {
            for (let i = gameState.logs.length - 1; i >= 0; i--) {
                if (gameState.logs[i].type === 'public') {
                    lastLogTime = gameState.logs[i].timestamp || 0;
                    break;
                }
            }
        }
        
        Object.keys(currentHackedHands).forEach(pid => {
            if (!gameState.players[pid]) {
                delete currentHackedHands[pid];
                needsUpdate = true;
                return;
            }

            let lockedCards = currentHackedHands[pid] || [];
            let remainingLocked = [];
            let returningCards = [];
            
            lockedCards.forEach(c => {
                // ハックした時間（なければ0）
                let hackTime = c.hackedAt || 0;
                
                // ★判定ロジック修正:
                // 1. 自分がかけたロックである (c.hackedBy === myId)
                // 2. 最後のログの時間より、ハックした時間が「2秒以上」古い
                //    (今ハックしたばかりなら、時間はほぼ同じなので解除されません)
                //    (一周回ってきたなら、ログの時間はもっと進んでいるので解除されます)
                if (c.hackedBy === myId && (lastLogTime - hackTime > 2000)) {
                    let newC = {...c};
                    delete newC.hackedBy;
                    delete newC.hackedAt; // 時間記録も消す
                    returningCards.push(newC);
                } else {
                    remainingLocked.push(c);
                }
            });
            
            if (returningCards.length > 0) {
                let hand = deepCopy(gameState.hands[pid] || []);
                hand = hand.concat(returningCards);
                hand = sortCards(hand);
                
                updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
                currentHackedHands[pid] = remainingLocked;
                needsUpdate = true;
            }
        });

        if (needsUpdate) {
            updates[`rooms/${currentRoom}/hackedHands`] = currentHackedHands;
            await pushLog(`${myName}のウイルス効果が切れ、ロックが解除されました。`, 'public');
            await db.ref().update(updates);
        }
    }
}

/* --- ALCHEMIST (錬金術師) 修正版 [UI改善 & 判定強化] --- */

let alchemyDrawnCard = null; 
let alchemyHandIdx = -1;     

// 発動
async function activateAlchemist() {
    let deck = gameState.deckNum || [];
    if (deck.length === 0) return showInfoModal("錬金失敗", "数字山札が尽きているため、素材を調達できません。");

    let hand = gameState.hands[myId] || [];
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("錬金失敗", "手札に触媒となる数字カードがありません。");

    // 仮引き
    let tempDeck = [...deck];
    alchemyDrawnCard = tempDeck.pop();
    
    alchemyHandIdx = -1;
    renderAlchemistUI();
}

// UI表示
/* --- 修正版: 場の確認機能 & ボタン改善 --- */
/* --- ALCHEMIST (錬金術師) UI修正版 --- */
function renderAlchemistUI() {
    let hand = sortCards(deepCopy(gameState.hands[myId] || []));
    
    // ▼ 場の状況（トップカードとルール）を取得
    let top = getTop(gameState.graveNum);
    let topVal = top ? top.val : "なし (何でも出せます)";
    let isRev = gameState.isReverse;
    let ruleText = isRev ? "▼ 逆行 (弱い方が強い)" : "▲ 順行 (強い方が強い)";
    
    // ▼ 修正: 場札のHTML生成 (実際のカードと同じクラス・スタイルを使用)
    let topCardHtml = "";
    if (top) {
        let style = "margin-right:15px; cursor:default; transform:scale(0.9);"; // 少しだけ小さくしてレイアウトに合わせる
        let cssClass = `card ${top.type}`;
        
        // 画像対応
        let imgUrl = CARD_IMAGES[top.val];
        if (imgUrl) {
            style += `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;`;
        }
        
        // 実際のカードと同じHTML構造
        topCardHtml = `<div class="${cssClass}" style="${style}" ${Number(top.val)===0 ? 'data-val="0"':''}>${top.val}</div>`;
    } else {
        // 場が空の場合のプレースホルダー
        topCardHtml = `<div class="card" style="border:2px dashed #999; background:rgba(0,0,0,0.2); color:#ccc; margin-right:15px; display:flex; align-items:center; justify-content:center; transform:scale(0.9);">?</div>`;
    }

    // 引いたカードの表示スタイル
    let drawImg = CARD_IMAGES[alchemyDrawnCard.val];
    let drawStyle = "border:3px solid #7b1fa2; box-shadow:0 0 10px #7b1fa2; transform:scale(1.1);";
    if (drawImg) drawStyle += `background-image:url('${drawImg}'); color:transparent;`;

    // HTML組み立て
    let html = `
        <div style="background:#37474f; color:white; padding:10px 15px; border-radius:8px; margin-bottom:15px; text-align:left; font-size:12px; display:flex; align-items:center; justify-content:center; box-shadow:inset 0 0 10px rgba(0,0,0,0.5);">
            ${topCardHtml}
            <div>
                <div style="font-size:10px; opacity:0.8;">現在の場</div>
                <div style="font-size:18px; font-weight:bold; margin:2px 0;">${topVal}</div>
                <div style="color:#ffb74d; font-weight:bold; border:1px solid #ffb74d; padding:2px 6px; border-radius:4px; display:inline-block; font-size:11px;">${ruleText}</div>
            </div>
        </div>

        <div style="display:flex; justify-content:space-around; align-items:center; margin-bottom:10px; background:#f3e5f5; padding:10px; border-radius:8px;">
            <div style="text-align:center;">
                <div style="font-size:10px; color:#4a148c; font-weight:bold; margin-bottom:5px;">素材A (ドロー)</div>
                <div class="card num" style="${drawStyle} margin:0 auto;">${alchemyDrawnCard.val}</div>
            </div>
            <div style="font-size:20px; color:#aaa;">+</div>
            <div style="text-align:center;">
                <div style="font-size:10px; color:#4a148c; font-weight:bold; margin-bottom:5px;">素材B (手札)</div>
                <div id="alchemy-hand-preview" style="width:54px; height:86px; border:2px dashed #ccc; border-radius:6px; line-height:86px; color:#ccc;">?</div>
            </div>
        </div>

        <p>手札から<strong>素材にする数字カード</strong>を選んでください。</p>
        <div class="modal-list">`;

    // 手札リスト (変更なし)
    hand.forEach((c, i) => {
        let isNum = (c.type === 'num');
        let isSelected = (alchemyHandIdx === i);
        let style = "transition: transform 0.2s; ";
        let onClick = "";

        if (isNum) {
            style += "cursor:pointer; ";
            if (isSelected) style += "border:3px solid #7b1fa2; transform:scale(1.1); box-shadow:0 0 10px #7b1fa2;";
            
            if (c.isHacked) {
                style += "cursor:not-allowed; filter:grayscale(100%); border:1px solid #555; background:#333;";
                onClick = `onclick="showInfoModal('ロック', 'ハッキングされているカードは素材にできません')"`;
            } else {
                onClick = `onclick="selectAlchemistHand(${i})"`;
            }
        } else {
            style += "opacity:0.4; cursor:default; border:1px dashed #999;";
        }
        
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent;`;

        html += `<div class="card ${c.type}" style="${style}" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;

    // 錬金実行ボタンエリア (ロジック変更なし)
    if (alchemyHandIdx !== -1) {
        let val1 = Number(alchemyDrawnCard.val);
        let val2 = Number(hand[alchemyHandIdx].val);

        let sumVal = (val1 + val2) % 10;
        let diffVal = Math.abs(val1 - val2);

        // 3. 積 (×)
        let prodVal = val1 * val2 % 10; // そのまま掛ける

        // 4. 商 (÷)
        // 大きい方を小さい方で割る
        let big = Math.max(val1, val2);
        let small = Math.min(val1, val2);
        let divVal = null;
        let divValid = false;

        // 0除算防止のみ (割り切れなくても切り捨てて商とする)
        if (small !== 0) {
            divVal = Math.floor(big / small); // ★ Math.floor() で切り捨て
            divValid = true;
        }

        // 判定
        let canSum = canPlay({type:'num', val:sumVal}, top, gameState.isReverse);
        let canDiff = canPlay({type:'num', val:diffVal}, top, gameState.isReverse);
        let canProd = canPlay({type:'num', val:prodVal}, top, gameState.isReverse);
        
        let canDiv = false;
        if (divValid) {
            canDiv = canPlay({type:'num', val:divVal}, top, gameState.isReverse);
        }

        const makeBtn = (label, val, can, isInvalidCalc) => {
            let bg = can ? "#7b1fa2" : "#e0e0e0"; 
            let color = can ? "white" : "#999";
            let cursor = can ? "pointer" : "not-allowed"; // カーソルを禁止マークに
            
            // 出せる時だけクリックイベントを設定
            let onClick = can ? `onclick="execAlchemist(${val})"` : "";
            // 出せない時は disabled 属性をつける
            let disabledAttr = can ? "" : "disabled";
            
            // 計算不能(0除算など)の場合の注記
            let note = "";
            if (!can) {
                if (isInvalidCalc) {
                    note = "<br><span style='font-size:10px; opacity:0.8;'>(不可)</span>";
                } else {
                    note = "<br><span style='font-size:10px; opacity:0.8;'>(ルール違反)</span>";
                }
            }

            // 表示値がnullの場合は "?" と表示
            let dispVal = (val !== null) ? val : "?";

            return `<button ${onClick} ${disabledAttr} style="background:${bg}; color:${color}; padding:10px 5px; border-radius:8px; cursor:${cursor}; width:48%; font-weight:bold; border:none; box-shadow:0 2px 4px rgba(0,0,0,0.2);">
                        ${label} <span style="font-size:18px;">[${dispVal}]</span>${note}
                    </button>`;
        };

        html += `
            <div style="margin-top:15px; padding:10px; background:#fff; border:1px solid #eee; border-radius:8px;">
                <p style="margin:0 0 10px 0; font-weight:bold; color:#333; font-size:12px;">錬成結果 (場の強弱に従う)</p>
                <div style="display:flex; justify-content:space-between; gap:5px;">
                    ${makeBtn("和 (+)", sumVal, canSum)}
                    ${makeBtn("差 (-)", diffVal, canDiff)}
                    ${makeBtn("積 (×)", prodVal, canProd, false)}
                    ${makeBtn("商 (÷)", divVal, canDiv, !divValid)}
                </div>
            </div>
        `;
    }

    // 中止ボタン
    let footerHtml = `<button onclick="execAlchemistKeep()" class="modal-btn" style="background:#78909c; margin-top:10px; width:100%;">
                        錬金失敗 (素材を手札に加える)
                      </button>`;

    openModal("錬金術師: 素材融合", html);
    document.getElementById("modal-footer").innerHTML = footerHtml;
    
    // プレビュー更新
    if (alchemyHandIdx !== -1) {
        let c = hand[alchemyHandIdx];
        let prev = document.getElementById("alchemy-hand-preview");
        if(prev) {
            prev.innerText = c.val;
            prev.style.border = "2px solid #7b1fa2";
            prev.style.color = "#7b1fa2";
            prev.style.fontWeight = "bold";
            prev.style.fontSize = "22px";
        }
    }
}

function selectAlchemistHand(idx) {
    alchemyHandIdx = idx;
    renderAlchemistUI();
}

// 実行: 成功（場に出す）
// ↓↓↓ execAlchemist関数を丸ごとこれに置き換えてください ↓↓↓
async function execAlchemist(resultVal) {
    closeModal();
    let updates = {};
    
    // 整合性チェック
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deck = [...(gameState.deckNum || [])];
    let gn = [...(gameState.graveNum || [])];
    let excl = [...(gameState.exclusion || [])];
    
    // 山札チェック
    let realDrawn = deck[deck.length - 1]; 
    if (!realDrawn || Number(realDrawn.val) !== Number(alchemyDrawnCard.val)) {
        return showInfoModal("錬金失敗", "詠唱中に山札が変動しました。やり直してください。");
    }
    
    // 手札チェック
    if (!hand[alchemyHandIdx] || hand[alchemyHandIdx].isHacked) {
        return showInfoModal("錬金失敗", "選択した手札がロックされたか、失われました。");
    }

    // 処理実行
    deck.pop(); 
    let realHandCard = hand.splice(alchemyHandIdx, 1)[0];
    
    excl.push(realDrawn);
    excl.push(realHandCard);

    // 生成カードを場に出す
    let createdCard = { type: 'num', val: Number(resultVal), owner: myId, isAlchemy: true };
    gn.push(createdCard);
    
    hand = sortCards(hand);
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckNum`] = deck;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    updates[`rooms/${currentRoom}/graveNum`] = gn;

    await pushLog(`${myName}が錬金成功！ [${realDrawn.val}] (ドロー)と [${realHandCard.val}] (手札)を融合し [${resultVal}] を出しました。`, 'public');
    
    // ★1. ハッキング枚数と合計枚数の計算
    let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
    let nextTotal = hand.length + myHackedCount;

    // ★2. 音の決定（スキル音 + UNO/DOS）
    let baseSound = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_ALCHEMIST']) ? 'SKILL_ALCHEMIST' : 'SKILL';
    let soundList = [baseSound];

    if (nextTotal === 1) soundList.push('UNO');
    else if (nextTotal === 2) soundList.push('DOS');

    // 音情報を送信
    updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ★3. あがり判定（計算済みの myHackedCount を使う）
    if (hand.length === 0 && myHackedCount === 0) {
        let currentRank = Object.keys(gameState.rankings || {}).length + 1;
        updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
        await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');
        
        // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
        updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
        updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
        // ▲▲▲ 追加ここまで ▲▲▲
        
        let totalPlayers = gameState.playerOrder.length;
        if (currentRank >= totalPlayers - 1) {
             updates[`rooms/${currentRoom}/status`] = "finished";

            // 敗者（最後の一人）を特定
            let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！！最下位 ${lName} の残りの手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！！`, 'public');
                        }
                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                    }           
    }
    
    let tempRankings = {...(gameState.rankings || {})};
    if (hand.length === 0) tempRankings[myId] = 99;

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
    
    alchemyDrawnCard = null;
    alchemyHandIdx = -1;
}

// 実行: 中止（手札に加える）
async function execAlchemistKeep() {
    closeModal();
    let updates = {};
    
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deck = [...(gameState.deckNum || [])];
    
    // 山札チェック
    let realDrawn = deck[deck.length - 1]; 
    if (!realDrawn || Number(realDrawn.val) !== Number(alchemyDrawnCard.val)) {
        return showInfoModal("エラー", "山札の不整合が発生しました。");
    }
    
    // 手札に加える
    deck.pop(); 
    realDrawn.owner = myId; 
    hand.push(realDrawn);
    hand = sortCards(hand);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckNum`] = deck;

    await pushLog(`${myName}の錬金は失敗し、素材を手札に追加しました。`, 'public');

    // スキル使用済み & パスカウントリセット
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/passCount`] = 0;

    let tempRankings = {...(gameState.rankings || {})};
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
    
    alchemyDrawnCard = null;
    alchemyHandIdx = -1;
}

/* --- NECROMANCER (ネクロマンサー) の実装 --- */

// 1. 発動確認
function activateNecromancer() {
    // 墓地チェック
    let gn = gameState.graveNum || [];
    if (gn.length === 0) {
        return showInfoModal("発動不可", "数字墓地にカードがないため、除外できません。");
    }

    // 除去する対象（一番上のカード）
    let topCard = gn[gn.length - 1];
    
    // 画像表示用のスタイル作成
    let style = "";
    let cImg = CARD_IMAGES[topCard.val];
    if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;

    let html = `
        <p>数字墓地の一番上のカードを除外しますか？<br>
        <span style="font-size:12px; color:#ef5350;">※除外した後、あなたのターンが続きます。</span>
        </p>
        
        <div style="display:flex; justify-content:center; margin:15px 0;">
            <div class="card ${topCard.type}" style="${style}">${topCard.val}</div>
        </div>

        <button onclick="execNecromancer()" style="background:#4a148c; color:white; padding:10px 30px; font-weight:bold; border-radius:20px;">
            蘇生（除外）実行
        </button>
    `;

    openModal("ネクロマンサー: 死者蘇生", html);
}

// 2. 実行処理
async function execNecromancer() {
    closeModal();
    let updates = {};

    // 最新の墓地データを取得
    let gn = [...(gameState.graveNum || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 念のため再チェック
    if (gn.length === 0) return showInfoModal("エラー", "墓地が空になりました。");

    // 墓地から除去
    let removedCard = gn.pop();
    
    // 除外場へ
    excl.push(removedCard);

    // データ更新
    updates[`rooms/${currentRoom}/graveNum`] = gn;
    updates[`rooms/${currentRoom}/exclusion`] = excl;

    // スキル使用済みにする
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ログ＆音
    await pushLog(`${myName}が[ネクロマンサー]を発動！墓地の [${removedCard.val}] を除外しました`, 'public');
    
    // 音の再生（スキル音があればそれ、なければDISCARD音などを代用）
    let soundType = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_NECROMANCER']) ? 'SKILL_NECROMANCER' : 'DISCARD';
    updates[`rooms/${currentRoom}/lastSound`] = { type: soundType, id: Date.now() };

    /* ★重要: ターンを進める処理（turnIdxの更新）は書きません。
       これにより、まだ自分のターン（playCardができる状態）が維持されます。
    */

    await db.ref().update(updates);
}

/* --- AGENT (工作員) の実装 --- */

// 1. 1人目選択
function activateAgent() {
    const pIds = gameState.playerOrder || [];
    const candidates = pIds.filter(pid => (gameState.hands[pid] || []).length > 0);

    if (candidates.length < 2) {
        return showInfoModal("発動不可", "手札を持つプレイヤーが2人未満のため、交換できません。");
    }

    let html = `<p>ランダム交換する<strong>1人目（対象A）</strong>を選んでください。<br>
        <span style="font-size:12px; color:#666;">※このあと2人目（対象B）を選びます。</span>
    </p>`;

    candidates.forEach(pid => {
        const p = gameState.players[pid];
        const handCount = (gameState.hands[pid] || []).length;
        const selfLabel = (pid === myId) ? " (あなた)" : "";
        html += `<button class="modal-btn" onclick="agentSelectSecondTarget('${pid}')">${p.name}${selfLabel} (手札${handCount})</button>`;
    });

    openModal("工作員: 対象A選択", html);
    if (document.getElementById("modal-footer")) {
        document.getElementById("modal-footer").innerHTML = "";
    }
}

// 2. 2人目選択
function agentSelectSecondTarget(firstId) {
    const pIds = gameState.playerOrder || [];
    const candidates = pIds.filter(pid =>
        pid !== firstId &&
        (gameState.hands[pid] || []).length > 0
    );

    if (candidates.length === 0) {
        return showInfoModal("発動不可", "2人目の候補がいません。");
    }

    const firstName = gameState.players[firstId] ? gameState.players[firstId].name : "不明";
    let html = `<p><strong>2人目</strong>を選んでください。<br>
        <span style="font-size:12px; color:#666;">選択済み: ${firstName}</span>
    </p>`;

    candidates.forEach(pid => {
        const p = gameState.players[pid];
        const handCount = (gameState.hands[pid] || []).length;
        const selfLabel = (pid === myId) ? " (あなた)" : "";
        html += `<button class="modal-btn" onclick="execAgentSwap('${firstId}', '${pid}')">${p.name}${selfLabel} (手札${handCount})</button>`;
    });

    openModal("工作員: 対象B選択", html);
    if (document.getElementById("modal-footer")) {
        document.getElementById("modal-footer").innerHTML = "";
    }
}

// 3. 実行処理（ランダム1枚交換）
async function execAgentSwap(pidA, pidB) {
    closeModal();

    let handA = deepCopy(gameState.hands[pidA] || []);
    let handB = deepCopy(gameState.hands[pidB] || []);

    if (handA.length === 0 || handB.length === 0) {
        return showInfoModal("エラー", "対象プレイヤーの手札が不足しています。");
    }

    const idxA = Math.floor(Math.random() * handA.length);
    const idxB = Math.floor(Math.random() * handB.length);

    const cardA = handA.splice(idxA, 1)[0];
    const cardB = handB.splice(idxB, 1)[0];
    handA.push(cardB);
    handB.push(cardA);

    const updates = {};
    updates[`rooms/${currentRoom}/hands/${pidA}`] = sortCards(handA);
    updates[`rooms/${currentRoom}/hands/${pidB}`] = sortCards(handB);

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    const nameA = gameState.players[pidA] ? gameState.players[pidA].name : "不明";
    const nameB = gameState.players[pidB] ? gameState.players[pidB].name : "不明";

    await pushLog(`${myName}が[工作員]を発動！${nameA}と${nameB}の手札をランダムに1枚交換しました。`, 'public');
    await pushLog(`【工作員の策略】${nameA}:[${cardA.val}] ↔ ${nameB}:[${cardB.val}]`, 'private', pidA);
    await pushLog(`【工作員の策略】${nameA}:[${cardA.val}] ↔ ${nameB}:[${cardB.val}]`, 'private', pidB);

    if (pidA !== myId) {
        updates[`rooms/${currentRoom}/players/${pidA}/notification`] = {
            fromName: `${myName}(工作員)`,
            lostVal: cardA.val,
            gotVal: cardB.val
        };
    }
    if (pidB !== myId) {
        updates[`rooms/${currentRoom}/players/${pidB}/notification`] = {
            fromName: `${myName}(工作員)`,
            lostVal: cardB.val,
            gotVal: cardA.val
        };
    }

    // ターンは進めない（このあと自分のターンを継続）
    await db.ref().update(updates);
}

// カットイン再生関数（画像対応版）
function playCutInAnimation(roleKey, roleNameJp, playerName) {
    const overlay = document.getElementById("cut-in-overlay");
    const roleDiv = document.getElementById("cut-in-role");
    const playerDiv = document.getElementById("cut-in-player");
    
    // 画像があるかチェック
    const imgUrl = ROLE_IMAGES[roleKey];
    
    // 画像があれば背景にセット、なければ黒背景
    if (imgUrl) {
        // 画像を暗くして表示（文字を目立たせるため linear-gradient を被せる）
        overlay.style.background = `
            linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)),
            url('${imgUrl}') no-repeat center center / cover
        `;
    } else {
        overlay.style.background = "rgba(0, 0, 0, 0.8)";
    }
        
    // テキストセット
    roleDiv.innerText = roleNameJp; 
    playerDiv.innerText = playerName;

    overlay.classList.remove("hidden");
    overlay.classList.remove("animate-cut-in");
        
    void overlay.offsetWidth; // リフロー発生（アニメーション再始動のおまじない）
    overlay.classList.add("animate-cut-in");

    setTimeout(() => {
        overlay.classList.add("hidden");
        overlay.classList.remove("animate-cut-in");
        // 終わったら背景をリセットしておく
        overlay.style.background = "";
    }, 2500);
}

/* --- ★追加: 演出受信リスナー --- */
function setupEffectListener() {
    // DBの 'effect' ノードを監視
    db.ref(`rooms/${currentRoom}/effect`).on('value', (snapshot) => {
        let data = snapshot.val();
        if (!data) return;

        // タイムスタンプが古すぎる(5秒以上前)なら無視 (リロード時の暴発防止)
        if (Date.now() - data.timestamp > 5000) return;

        // 演出実行
        showVisualEffect(data);
    });
}
// ★新設: ホスト設定メニューを開く
        // ↓↓↓ openHostSettings関数をこれに置き換えてください ↓↓↓
        function openHostSettings() {
            let check6 = (lastHostHandMode === 6) ? "checked" : "";
            let check4 = (lastHostHandMode === 4) ? "checked" : "";

            let html = `
                <div style="text-align:left; font-size:14px;">
                    <div style="margin-bottom:15px; background:#f9f9f9; padding:10px; border-radius:8px; border:1px solid #eee;">
                        <label style="display:flex; align-items:center; cursor:pointer; margin-bottom:8px;">
                            <input type="radio" name="handMode" value="6" ${check6} style="margin:0 8px 0 0; width:auto; transform:scale(1.2);">
                            <div>
                                <span style="font-weight:bold; color:#2e7d32;">通常モード (6枚)</span>
                                <span style="font-size:11px; color:#888; margin-left:5px;">― 数字6 + 記号2</span>
                            </div>
                        </label>
                        <label style="display:flex; align-items:center; cursor:pointer;">
                            <input type="radio" name="handMode" value="4" ${check4} style="margin:0 8px 0 0; width:auto; transform:scale(1.2);">
                            <div>
                                <span style="font-weight:bold; color:#ef6c00;">短期決戦 (4枚)</span>
                                <span style="font-size:11px; color:#888; margin-left:8px;">― 数字4 + 記号2</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="display:flex; gap:10px;">
                        <button onclick="confirmInitGameWithSettings()" style="flex:1; background:linear-gradient(135deg, #66bb6a, #43a047); color:white; padding:10px; font-weight:bold; border-radius:20px; box-shadow:0 2px 5px rgba(0,0,0,0.2);">
                            開始 / リセット
                        </button>
                        <button onclick="confirmCloseRoom()" style="width:80px; background:#ef5350; color:white; padding:10px; font-size:11px; border-radius:20px;">
                            解散
                        </button>
                    </div>
                </div>
            `;
            openModal("ホスト設定", html);
        }

        // ★新設: 設定値を読み取って開始確認へ
        function confirmInitGameWithSettings() {
            const modeEls = document.getElementsByName('handMode');
            for(let el of modeEls) { if(el.checked) lastHostHandMode = parseInt(el.value); }

            // 確認画面へ切り替え
            els.mTitle.innerText = "開始確認";
            els.mContent.innerHTML = `<p><strong>${lastHostHandMode}枚モード</strong> で<br>ゲームを開始（リセット）しますか？</p>`;
            els.mFooter.innerHTML = `
                <button onclick="closeModal(); execInitGame(${lastHostHandMode})" class="modal-btn primary">はい</button>
                <button onclick="openHostSettings()" class="modal-btn">戻る</button>
            `;
        }

        /* ===============================================
           iPhone対策: タブ切り替え後のオーディオ復活処理
           =============================================== */
        
        // 1. ページが再び「見える状態」になったら起こす
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                checkAndResumeAudio();
            }
        });

        // 2. 画面をタッチしたときも念のため起こす
        document.addEventListener('touchstart', function() {
            checkAndResumeAudio();
        }, { passive: true }); // passive: true はスクロール性能への配慮

        // オーディオの状態を確認して、死んでたら再開させる関数
        function checkAndResumeAudio() {
            if (!audioCtx) return;

            // 'suspended' (一時停止) や 'interrupted' (割り込み停止) なら再開
            if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
                audioCtx.resume().then(() => {
                    console.log("AudioContext Resumed by User Action/Visibility");
                }).catch(e => {
                    console.log("AudioContext Resume Failed", e);
                });
            }
        }

        function buildRoleGuideHtml() {
            let html = '<div style="text-align:left; max-height: 500px; overflow-y: auto;">';

            Object.keys(ROLE_INFO).forEach(key => {
                const info = ROLE_INFO[key];
                let imgHtml = "";
                if (typeof ROLE_IMAGES !== 'undefined' && ROLE_IMAGES[key]) {
                    imgHtml = `<img src="${ROLE_IMAGES[key]}" style="height:40px; vertical-align:middle; margin-right:10px; border-radius:4px; border:1px solid #ccc;">`;
                }

                html += `
                    <details style="margin-bottom:10px; border-bottom:1px solid #444; padding-bottom:5px;">
                        <summary style="cursor:pointer; display:flex; align-items:center; outline:none; list-style:none;">
                            ${imgHtml}
                            <div style="flex:1;">
                                <div style="font-weight:bold; color:#e050fa; font-size:15px;">
                                    ${info.jp}
                                    <span style="font-size:13px; color:#e050fa; font-weight:normal; margin-left:4px;">${key}</span>
                                </div>
                                <div style="font-size:12px; color:#000000; display: flex; justify-content: space-between; align-items: baseline;">
                                    <div>${info.summary}</div>
                                    <span style="font-size:10px; color:#888; white-space: nowrap;">▼詳細　</span>
                                </div>
                            </div>
                        </summary>
                        <div style="margin-top:10px; padding:10px; background:rgba(0,0,0,0.1); border-radius:5px; font-size:12px; color:#000000; line-height:1.6;">${info.desc}</div>
                    </details>`;
            });

            html += "</div>";
            return html;
        }

        function buildRuleGuideHtml() {
            return `
                <div style="text-align: left; max-height: 400px; overflow-y: auto; font-size: 13px; color: #333;">
                    <h4 style="border-left: 4px solid #2e7d32; padding-left: 8px; margin: 10px 0 5px 0;">基本ルール</h4>
                    <p style="margin: 0 0 10px 0;">・順に回ってくるターンで、手札を先に0枚にした人が勝ち！<br />・自分のターンでは以下から<strong>1つ</strong>の行動ができる<br />　　1. 手札から<span style="color: #3598db;"><strong>数字カード</strong></span>を数字墓地に出す（前の人より<strong>強いカード</strong>を出せる）<br />　　2. 手札から<span style="color: #e03e2d;"><strong>記号カード</strong></span>を使う<br />　　3. 一度きりの<span style="color: #843fa1;"><strong>役職能力</strong></span>を使う（詳しい説明は<strong><span style="color: #843fa1;">【役職】</span></strong>を参照）<br />　　4. <span style="color: #e67e23;"><strong>パス</strong></span>をして自分のターンを流す（パスの詳細は下部へ）</p>
                    <p style="margin: 0 0 10px 0;">&nbsp;</p>
                    <h4 style="border-left: 4px solid #c62828; padding-left: 8px; margin: 10px 0 5px 0;">記号カード</h4>
                    <ul style="padding-left: 20px; margin: 0;">
                    <li><strong>REVERSE</strong>（4枚）: <strong><span style="color: #3598db;">数字カード</span></strong>の強弱を逆転させる</li>
                    <li><strong>TRADE</strong>（4枚）: 好きな手札1枚を他のプレイヤーと交換する</li>
                    <li><strong>DIG UP</strong>（4枚）: 数字墓地の1番上のカードと、手札の<strong><span style="color: #3598db;">数字カード</span></strong>を交換する</li>
                    <li><strong>DISCARD</strong>（<strong><span style="color: #e03e2d;">1</span>枚</strong>）: 好きな<strong><span style="color: #3598db;">数字カード</span></strong>を1枚捨てる</li>
                    </ul>
                    <p>&nbsp;</p>
                    <h4 style="border-left: 4px solid #1565c0; padding-left: 8px; margin: 10px 0 5px 0;">数字カード</h4>
                    <p style="margin: 0 0 10px 0;">・数字カードは0~9まで各4枚ずつ<br /><strong>・「0」はいつでも出せるが、その上に何でも出せる！</strong><br /><strong>　🔵 順行🐘 (通常):</strong><br />　　0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9<br /><strong>　🔴 逆行🐁 (REVERSE中):</strong><br />　　0 &lt; 9 &lt; 8 &lt; 7 &lt; 6 &lt; 5 &lt; 4 &lt; 3 &lt; 2 &lt; 1</p>
                    <p style="margin: 0 0 10px 0;">&nbsp;</p>
                    <h4 style="border-left: 4px solid #f76205; padding-left: 8px; margin: 10px 0 5px 0;">パスとリセット</h4>
                    <p style="margin: 0 0 10px 0;">・<strong>パス</strong>では、数字カードを1枚引いても良い<br />　&rArr;その際、出せるなら出しても良い！</p>
                    <p style="margin: 0 0 10px 0;"><strong>【リセットとは】</strong></p>
                    <ul>
                    <li>数字墓地の一番上のカードを出したプレイヤーは<strong>リセット権</strong>を持つ<br />
                    <li><strong>リセット権</strong>を持っているプレイヤーがパスすると、数字墓地のカードが全て除外され、何でも出せる<br />
                    <li><strong>リセット権</strong>は、<strong>👑RESET</strong>で表示されている</li>
                    <li><strong>リセット権</strong>を持ったプレイヤーがあがった場合、<span style="text-decoration: underline;">数字墓地の一番上のカードが変わらない限り、一周後に次のプレイヤーに移動する</span></li>
                    </ul>
                    <p style="margin: 0 0 10px 0;">&nbsp;</p>
                    <h4 style="border-left: 4px solid #c62828; padding-left: 8px; margin: 10px 0 5px 0;">🚫禁止事項🚫</h4>
                    <ul style="padding-left: 20px; margin: 0;">
                    <li><strong>記号あがり</strong>: 手札の最後の1枚が記号カードのとき、それを使って0枚にはできない</li>
                    </ul>
                    <ul style="padding-left: 20px; margin: 0;">
                    <li><strong>0あがり</strong>: 手札の最後の1枚が0のとき、0を出して0枚にすることはできない</li>
                    </ul>
                </div>
            `;
        }

        function openGuide(kind, surface = "main") {
            let title = "";
            let html = "";

            if (kind === "role") {
                title = "👥役職一覧";
                html = buildRoleGuideHtml();
            } else if (kind === "rule") {
                title = "📖ルール";
                html = buildRuleGuideHtml();
            } else {
                return;
            }

            if (surface === "sub" && typeof openSubModal === "function") {
                openSubModal(title, html);
                return;
            }

            openModal(title, html);
            const mBox = document.getElementById("modal-box");
            if (mBox) {
                mBox.style.width = "600px";
                mBox.style.maxWidth = "95%";
            }
        }

        function showRoleList() { openGuide("role", "main"); }
        function showRule() { openGuide("rule", "main"); }

        // --- ★追加: プレイヤー別ログ表示機能 ---
        function showPlayerLogs(targetId) {
            if (!gameState || !gameState.logs) return showInfoModal("履歴なし", "まだ記録がありません。");
            if (!gameState.players[targetId]) return;

            const targetName = gameState.players[targetId].name;
            const logs = gameState.logs;
            
            // フィルタリング: typeがpublicで、テキストにその人の名前が含まれるもの
            const filtered = logs.filter(l => 
                l.type === 'public' && l.text.includes(targetName)
            );

            if (filtered.length === 0) return showInfoModal(targetName + "の履歴", "表示できる行動履歴がありません。");

            let html = `<div style="text-align:left; max-height:400px; overflow-y:auto; font-size:13px;">`;
            
            // 新しい順に表示
            [...filtered].reverse().forEach(l => {
                let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit'});
                html += `
                    <div style="border-bottom:1px solid #eee; padding:6px 0;">
                        <span style="color:#888; font-size:11px; margin-right:8px;">${time}</span>
                        <span style="color:#333;">${l.text}</span>
                    </div>
                `;
            });
            
            html += `</div>`;
            openModal(`${targetName} の行動履歴`, html);
            
            // モーダルの幅調整
            const mBox = document.getElementById("modal-box");
            if(mBox) {
                mBox.style.width = "400px";
                mBox.style.maxWidth = "90%";
            }
        }

        // --- スコア更新関数 ---
        async function updateFinalScores(finalRankings, playerOrder) {
            let currentScores = gameState.scores || {};
            let totalPlayers = playerOrder.length;
            let updates = {};

            playerOrder.forEach(pid => {
                let rank = finalRankings[pid];
                if (rank) {
                    // スコア計算式: 2 * (人数 - 順位) + 1
                    let roundPoint = 2 * (totalPlayers - rank) + 1;
                    let oldScore = currentScores[pid] || 0;
                    updates[`rooms/${currentRoom}/scores/${pid}`] = oldScore + roundPoint;
                }
            });
            await db.ref().update(updates);
        }

        // --- スコアボード表示関数 ---
        function showScoreboard() {
            if (!gameState) return;
            let scores = gameState.scores || {};
            let players = gameState.players || {};

            // 現在の参加人数を取得（ゲーム開始前なら現在のプレイヤー数を使用）
            let playerOrder = gameState.playerOrder || Object.keys(players);
            let totalPlayers = playerOrder.length;

            // 1. 点数配分のテキストを作成
            let distributionText = "";
            if (totalPlayers >= 2) {
                let distArray = [];
                for (let r = 1; r <= totalPlayers; r++) {
                    let pts = 2 * (totalPlayers - r) + 1;
                    distArray.push(`${r}位:${pts}pt`);
                }
                distributionText = `<div style="font-size:11px; color:#666; margin-bottom:10px; background:#fff9c4; padding:5px; border-radius:4px; text-align:center; border:1px solid #fbc02d;">
                    現在の配分 (${totalPlayers}人戦): ${distArray.join(' / ')}
                </div>`;
            }

            // スコア順にソート
            let sortedPids = Object.keys(scores).sort((a, b) => scores[b] - scores[a]);

            // 2. HTMLの組み立て
            let html = distributionText; // タイトルのすぐ下に配分を表示

            html += `<table style="width:100%; border-collapse:collapse; font-size:14px;">
                        <tr style="border-bottom:2px solid #ccc; background:#f5f5f5;">
                            <th style="padding:8px; text-align:center;">名 前</th>
                            <th style="padding:8px; text-align:right;">合計点数</th>
                        </tr>`;

            if (sortedPids.length === 0) {
                html += `<tr><td colspan="2" style="padding:20px; color:#999;">まだ記録がありません</td></tr>`;
            }

            sortedPids.forEach(pid => {
                let pName = players[pid] ? players[pid].name : "不明なユーザー";
                let score = scores[pid];
                let isMe = (pid === myId) ? "color:#d32f2f; font-weight:bold;" : "";
                html += `<tr style="border-bottom:1px solid #eee; ${isMe}">
                            <td style="padding:8px;">${pName}</td>
                            <td style="padding:8px; text-align:right; font-weight:bold;">${score} pt</td>
                        </tr>`;
            });
            html += `</table>`;
            
            // ホストのみスコアリセットボタンを表示
            let hostId = getEffectiveHostId(gameState);

            if (myId === hostId) {
                html += `<div style="margin-top:20px;">
                            <button onclick="confirmResetScores()" style="font-size:11px; color:#888; background:none; border:1px solid #ccc; border-radius:4px; padding:4px 8px; cursor:pointer;">スコアを全てリセット</button>
                        </div>`;
            }

            openModal("🏆 総合ランキング", html);
        }

        // スコアリセット用（ホスト用）
        function confirmResetScores() {
            showConfirmModal("スコアリセット", "部屋全体の累積スコアを消去しますか？", "db.ref(`rooms/${currentRoom}/scores`).remove()");
        }

        // 1. 共通のホスト判定関数（これを一度作っておけば、どこでも使えます）
    function getEffectiveHostId(data) {
        if (!data) return null;
        let pIds = data.playerOrder || getSortedPlayerIds(data.players || {});
        let hostId = (pIds.length > 0) ? pIds[0] : null;

        // ゲーム終了時は最下位（敗者）にホスト権限を移す
        if (data.status === "finished" && data.rankings) {
            let loserId = Object.keys(data.rankings).reduce((a, b) => 
                data.rankings[a] > data.rankings[b] ? a : b
            , null);
            if (loserId && data.players[loserId]) {
                hostId = loserId;
            }
        }
        return hostId;
    }
        

    
        // Global exports
        window.joinGame = joinGame;
        window.playCard = playCard;
        window.passTurn = passTurn;
        window.initGame = confirmInitGame; 
        window.viewGrave = viewGrave;
        window.closeModal = closeModal;
        window.execDigUp = execDigUp;
        window.tradeStep2 = tradeStep2;
        window.tradeStep3 = tradeStep3; // ★追加: 奪うカード選択
        window.execTrade = execTrade;
        window.execDiscard = execDiscard;
        window.execPassDraw = execPassDraw;
        window.execPassNoDraw = execPassNoDraw;
        window.execPassPlay = execPassPlay;
        window.execPassKeep = execPassKeep;
        window.execPassReset = execPassReset;
        window.closeRoom = confirmCloseRoom;
        window.execInitGame = execInitGame;
        window.execCloseRoom = execCloseRoom;
        window.showLogHistory = showLogHistory;
        window.sendChat = sendChat;
        window.playCutInAnimation = playCutInAnimation;
        window.openHostSettings = openHostSettings;
        window.confirmInitGameWithSettings = confirmInitGameWithSettings;
        window.showRoleList = showRoleList;
        window.showRule = showRule;
        window.leaveRoom = leaveRoom; // これを追加
        // windowオブジェクトに登録してHTMLから呼べるようにする
        window.showPlayerLogs = showPlayerLogs;
        // 釣り人
        window.activateAngler = activateAngler;
        window.anglerStep2 = anglerStep2;
        window.execAngler = execAngler;
        // 占い師
        window.activateFortuneTeller = activateFortuneTeller;
        // 盗賊
        window.activateThief = activateThief;
        window.thiefSelectTake = thiefSelectTake; // ★追加
        window.thiefSelectGive = thiefSelectGive; // ★追加(名前変更)
        window.execThiefTrade = execThiefTrade;
        window.endThiefTurn = endThiefTurn;
        // 狩人
        window.activateHunter = activateHunter;
        window.toggleHunterSelect = toggleHunterSelect; // 新しい関数
        window.checkHunterCount = checkHunterCount;     // 新しい関数
        window.execHunterSwap = execHunterSwap;
        // 賭博師
        window.activateGambler = activateGambler;
        window.execGamblerGuess = execGamblerGuess;
        window.gamblerSelectDiscard = gamblerSelectDiscard;
        window.toggleGamblerSelect = toggleGamblerSelect;
        window.execGamblerDiscard = execGamblerDiscard;
        // 手品師
        window.activateMagician = activateMagician;
        window.execMagicianReverse = execMagicianReverse;
        window.activateMagicianTrade = activateMagicianTrade;
        window.magicianSelectTake = magicianSelectTake; // ★新設
        window.magicianSelectGive = magicianSelectGive; // ★名前変更
        window.activateMagicianDigUp = activateMagicianDigUp;
        window.execMagicianDigUp = execMagicianDigUp;
        // 富豪
        window.activateMillionaire = activateMillionaire;
        window.execMillionaire = execMillionaire;
        // 皇帝
        window.activateEmperor = activateEmperor;
        window.execEmperorSelect = execEmperorSelect;
        // 警察官
        window.activatePoliceOfficer = activatePoliceOfficer;
        window.policeTradeStart = policeTradeStart;
        window.endPoliceTurn = endPoliceTurn;
        window.policeSelectTake = policeSelectTake; // ★追加: 奪うカード選択
        window.policeSelectGive = policeSelectGive;
        window.execPoliceTrade = execPoliceTrade;
        // ハッカー
        window.activateHacker = activateHacker;
        window.selectHackerTarget = selectHackerTarget;
        window.execHacker = execHacker;
        window.checkHackerCleanup = checkHackerCleanup;
        // 錬金術師
        window.activateAlchemist = activateAlchemist;
        window.selectAlchemistHand = selectAlchemistHand;
        window.execAlchemist = execAlchemist;
        window.execAlchemistKeep = execAlchemistKeep; // ★名前変更 (Keep)
        // ネクロマンサー
        window.activateNecromancer = activateNecromancer; // ★追加
        window.execNecromancer = execNecromancer;         // ★追加
        // 工作員
        window.activateAgent = activateAgent;
        window.agentSelectSecondTarget = agentSelectSecondTarget;
        window.execAgentSwap = execAgentSwap;


    </script>
    <div id="counter-hud-wrapper" style="display:none;">
    <div id="counter-toggle-btn" onclick="toggleCounterHUD()">
        📊
    </div>

    <div id="counter-panel">
        <div class="hud-header">
            <span>CARD COUNTER</span>
            <span class="close-btn" onclick="toggleCounterHUD()">×</span>
        </div>
        
        <div class="hud-section-title">NUMBER (残/全4)</div>
        <div class="hud-grid" id="hud-grid-num">
            <div style="grid-column:1/-1; text-align:center; color:#555; font-size:10px;">Loading...</div>
        </div>

        <div class="hud-section-title">SYMBOL</div>
        <div class="hud-grid-sym" id="hud-grid-sym">
            <div style="grid-column:1/-1; text-align:center; color:#555; font-size:10px;">Loading...</div>
        </div>
        
        <div style="font-size:10px; color:#777; margin-top:5px; text-align:center;">
            ※山札 + 相手の手札にある数
        </div>
    </div>
</div>

<style>
    /* --- カウンティングHUDのスタイル --- */
    #counter-hud-wrapper {
        font-family: "M PLUS Rounded 1c", sans-serif;
        user-select: none;
        z-index: 9999; /* 最前面に */
    }

    /* 1. 開閉ボタン（スマホで邪魔にならないサイズ） */
    #counter-toggle-btn {
        position: fixed;
        top: 60px;       /* ヘッダーの下あたり */
        right: 15px;     /* 右端に配置 */
        z-index: 2000;   
        
        width: 44px; height: 44px;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 215, 0, 0.6);
        border-radius: 50%;
        
        display: flex; justify-content: center; align-items: center;
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        transition: transform 0.2s, background 0.2s;
    }
    #counter-toggle-btn:active { transform: scale(0.9); background: rgba(0,0,0,0.8); }

    /* 2. パネル本体（グラスモーフィズム） */
    #counter-panel {
        position: fixed;
        top: 115px;
        right: 15px;
        z-index: 1999;
        
        width: 240px;    /* スマホでも見やすい幅 */
        background: rgba(20, 20, 20, 0.85);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 215, 0, 0.3);
        border-radius: 12px;
        padding: 12px;
        
        /* アニメーション（右上から展開） */
        transform-origin: top right;
        transform: scale(0);
        opacity: 0;
        transition: all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: none;
        
        box-shadow: 0 10px 30px rgba(0,0,0,0.8);
    }
    /* 開いた状態 */
    #counter-panel.active {
        transform: scale(1);
        opacity: 1;
        pointer-events: auto;
    }

    /* 内部レイアウト */
    .hud-header {
        display: flex; justify-content: space-between; align-items: center;
        font-size: 12px; font-weight: bold; color: #ffd700;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        padding-bottom: 5px; margin-bottom: 8px;
    }
    .close-btn { cursor: pointer; padding: 0 5px; font-size: 16px; color: #fff; }

    .hud-section-title {
        font-size: 10px; color: #aaa; margin-bottom: 4px; letter-spacing: 1px;
    }

    .hud-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr); /* 5列 (0-4, 5-9) */
        gap: 4px;
        margin-bottom: 12px;
    }
    .hud-grid-sym {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* 記号は2列 */
        gap: 4px;
    }

    .hud-item {
        background: rgba(255,255,255,0.05);
        border-radius: 6px;
        padding: 4px 0;
        text-align: center;
        border: 1px solid transparent;
    }
    /* 残り0枚になったら暗くする */
    .hud-item.zero { opacity: 0.3; background: transparent; border: 1px dashed #444; }
    /* 残り枚数が多いときは強調 */
    .hud-item.rich { border-color: rgba(255,215,0,0.3); background: rgba(255,215,0,0.05); }

    .hud-val { font-size: 11px; font-weight: bold; color: #ccc; display: block; line-height: 1; margin-bottom: 2px; }
    .hud-count { font-size: 15px; font-weight: 800; color: #fff; display: block; line-height: 1; }
    
    /* 記号ごとの色分け */
    .hud-item.sym-rev .hud-val { color: #e91e63; } /* REVERSE: 赤 */
    .hud-item.sym-tra .hud-val { color: #ff9800; } /* TRADE: オレンジ */
    .hud-item.sym-dig .hud-val { color: #795548; } /* DIG UP: 茶 */
    .hud-item.sym-dis .hud-val { color: #9e9e9e; } /* DISCARD: グレー */

</style>

<script>
    /* --- カウンティングロジック (改修版) --- */
    
    // カードの初期枚数定義
    const INITIAL_COUNTS = {
        // 数字 (各4枚)
        0:4, 1:4, 2:4, 3:4, 4:4, 5:4, 6:4, 7:4, 8:4, 9:4,
        // 記号
        "REVERSE": 4,
        "TRADE": 4,
        "DIG UP": 4,
        "DISCARD": 1
    };

    // パネル開閉関数
    window.toggleCounterHUD = function() {
        const panel = document.getElementById("counter-panel");
        if(panel) {
            panel.classList.toggle("active");
            updateCounterHUD(); // 開いた瞬間に更新
        }
    };

    // カウント更新関数（メインロジック）
    function updateCounterHUD() {
        const wrapper = document.getElementById("counter-hud-wrapper");
        
        // ★重要: ゲームに参加していない（ログイン画面）ときは隠す
        // gameStateがない、または myId がない場合は非表示にして終了
        if (typeof gameState === 'undefined' || !gameState || typeof myId === 'undefined' || !myId) {
            if(wrapper) wrapper.style.display = "none";
            return;
        }

        // ゲーム中なら表示する
        if(wrapper && wrapper.style.display === "none") {
            wrapper.style.display = "block";
        }

        // ★修正ポイント: 手札の取得方法を変更
        // 以前の currentHand は更新されていない場合があるため、
        // 確実な gameState.hands[myId] から取得します。
        let myHandRef = [];
        // myId が定義されているか念のためチェック
        if (typeof myId !== 'undefined' && gameState.hands && gameState.hands[myId]) {
            myHandRef = gameState.hands[myId];
        }

        // 1. カウント用オブジェクトを初期化（コピー）
        let remaining = Object.assign({}, INITIAL_COUNTS);

        // 2. 「見えているカード」を減算するヘルパー関数
        const subtractVisible = (cardList) => {
            if (!cardList || !Array.isArray(cardList)) return;
            cardList.forEach(c => {
                if (!c || c.val === undefined) return;

                // ★重要: 錬金術師によって生成されたカード(isAlchemy=true)は
                // 「本来の山札の枚数」ではないため、カウントから除外しない（無視する）。
                if (c.isAlchemy) return;

                if (remaining[c.val] !== undefined) {
                    remaining[c.val]--;
                }
            });
        };

        // 3. 各場所から減算 (gameStateのキー名に注意)
        subtractVisible(myHandRef);                // 自分の手札（これで正しく引かれます！）
        subtractVisible(gameState.graveNum);       // 数字墓地
        subtractVisible(gameState.graveSym);       // 記号墓地
        
        // ★除外エリアの対応
        // コード解析の結果、gameState.exclusion に格納されていることが判明
        if (gameState.exclusion) subtractVisible(gameState.exclusion);
        
        // 念のため removed もチェック (古いバージョン対策)
        if (gameState.removed) subtractVisible(gameState.removed);


        // 4. HTMLへの描画（数字）
        const gridNum = document.getElementById("hud-grid-num");
        if(gridNum) {
            let html = "";
            for (let i = 0; i <= 9; i++) {
                let count = remaining[i];
                if (count < 0) count = 0; // エラー防止
                let cls = count === 0 ? "zero" : (count >= 3 ? "rich" : "");
                html += `
                    <div class="hud-item ${cls}">
                        <span class="hud-val">${i}</span>
                        <span class="hud-count" style="color:${getColorForCount(count)}">${count}</span>
                    </div>
                `;
            }
            gridNum.innerHTML = html;
        }

        // 5. HTMLへの描画（記号）
        const gridSym = document.getElementById("hud-grid-sym");
        if(gridSym) {
            const syms = [
                {k: "REVERSE", l:"REV", c:"sym-rev"}, 
                {k: "TRADE",   l:"TRA", c:"sym-tra"}, 
                {k: "DIG UP",  l:"DIG", c:"sym-dig"}, 
                {k: "DISCARD", l:"DIS", c:"sym-dis"}
            ];
            let html = "";
            syms.forEach(s => {
                let count = remaining[s.k];
                if (count < 0) count = 0;
                let cls = count === 0 ? "zero" : "";
                html += `
                    <div class="hud-item ${s.c} ${cls}">
                        <span class="hud-val">${s.l}</span>
                        <span class="hud-count">${count}</span>
                    </div>
                `;
            });
            gridSym.innerHTML = html;
        }
    }

    // カウントの色分け（多いと緑、少ないと赤）
    function getColorForCount(n) {
        if (n === 0) return "#555";
        if (n === 1) return "#ff5252"; // 赤
        if (n === 2) return "#ffeb3b"; // 黄
        return "#69f0ae"; // 緑
    }

    // 6. 定期実行（0.5秒ごとに更新）
    // ゲーム開始前などでエラーが出ないよう try-catch で囲む
    setInterval(() => {
        try {
            updateCounterHUD();
        } catch(e) {
            // エラーは無視（コンソールを汚さない）
        }
    }, 500);

</script>
<div id="sub-modal-overlay" class="hidden" onclick="closeSubModal()">
    <div id="sub-modal-box" onclick="event.stopPropagation()">
        <span class="close-btn" onclick="closeSubModal()">×</span>
        <h3 id="sub-modal-title">タイトル</h3>
        <div id="sub-modal-body"></div>
    </div>
</div>

<style>
    /* メインのモーダルより上に表示 */
    #sub-modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 9999;
        display: flex; justify-content: center; align-items: center;
        backdrop-filter: blur(4px);
        transition: opacity 0.2s;
    }
    #sub-modal-overlay.hidden { display: none !important; opacity: 0; }

    #sub-modal-box {
        background: #fff; color: #333;
        width: 90%; max-width: 600px;
        max-height: 80vh;
        border-radius: 12px;
        padding: 20px;
        position: relative;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        display: flex; flex-direction: column;
        animation: subPopIn 0.2s ease-out;
    }
    @keyframes subPopIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    #sub-modal-title { margin: 0 0 10px 0; border-bottom: 2px solid #2e7d32; padding-bottom: 5px; color: #2e7d32; }
    #sub-modal-body { overflow-y: auto; flex: 1; text-align: left; font-size: 14px; line-height: 1.6; }

    #sub-modal-box .close-btn {
        position: absolute; top: 10px; right: 15px;
        font-size: 24px; cursor: pointer; color: #999;
    }

    /* メインモーダルに追加する共通ボタン */
    #modal-board-toggle {
        position: absolute; top: 10px; right: 10px;
        border: 1px solid #90a4ae; border-radius: 16px;
        background: #eceff1; color: #37474f;
        padding: 3px 10px; font-size: 12px; cursor: pointer;
        line-height: 1.2; z-index: 100;
    }
    #modal-board-toggle.active {
        background: #2e7d32;
        border-color: #2e7d32;
        color: #fff;
    }

    #modal-help-btns {
        position: absolute; top: 10px; left: 10px;
        display: flex; gap: 5px; z-index: 100;
    }
    .help-icon-btn {
        background: none; border: 1px solid rgba(0,0,0,0.2);
        border-radius: 4px; cursor: pointer; font-size: 14px; padding: 2px 6px;
        background: rgba(255,255,255,0.8); transition: 0.2s;
    }
    .help-icon-btn:hover { transform: scale(1.1); background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
</style>

<script>
    /* --- 1. 既存モーダルに共通補助ボタンを注入 --- */
    if (!window._origOpenModal) window._origOpenModal = window.openModal;
    if (!window._origCloseModal) window._origCloseModal = window.closeModal;

    let mainModalBoardMode = false;

    function setMainModalBoardMode(enabled) {
        mainModalBoardMode = !!enabled;
        const overlay = document.getElementById("modal-overlay");
        const toggleBtn = document.getElementById("modal-board-toggle");

        if (overlay) overlay.classList.toggle("board-visible", mainModalBoardMode);
        if (toggleBtn) {
            toggleBtn.classList.toggle("active", mainModalBoardMode);
            toggleBtn.textContent = mainModalBoardMode ? "👁 盤面ON" : "👁 盤面OFF";
        }
    }

    function toggleMainModalBoardMode() {
        setMainModalBoardMode(!mainModalBoardMode);
    }

    function ensureMainModalTools() {
        const box = document.getElementById("modal-box");
        if (!box) return;

        if (getComputedStyle(box).position === "static") box.style.position = "relative";

        let btnDiv = document.getElementById("modal-help-btns");
        if (!btnDiv) {
            btnDiv = document.createElement("div");
            btnDiv.id = "modal-help-btns";
            btnDiv.innerHTML = `
                <button class="help-icon-btn" onclick="showRuleSub()" title="ルール">📖</button>
                <button class="help-icon-btn" onclick="showRoleSub()" title="役職一覧">👥</button>
            `;
            box.appendChild(btnDiv);
        }

        let boardBtn = document.getElementById("modal-board-toggle");
        if (!boardBtn) {
            boardBtn = document.createElement("button");
            boardBtn.id = "modal-board-toggle";
            boardBtn.type = "button";
            boardBtn.setAttribute("onclick", "toggleMainModalBoardMode()");
            boardBtn.title = "盤面確認";
            box.appendChild(boardBtn);
        }
    }

    window.openModal = function(title, html) {
        window._origOpenModal(title, html);
        ensureMainModalTools();
        setMainModalBoardMode(false);
    };

    window.closeModal = function() {
        setMainModalBoardMode(false);
        window._origCloseModal();
    };

    const modalOverlay = document.getElementById("modal-overlay");
    if (modalOverlay && !window._modalBoardObserverAttached) {
        window._modalBoardObserverAttached = true;
        let lastMainModalHiddenState = modalOverlay.classList.contains("hidden");
        const observer = new MutationObserver(() => {
            const isHidden = modalOverlay.classList.contains("hidden");
            if (lastMainModalHiddenState && !isHidden) {
                ensureMainModalTools();
                setMainModalBoardMode(false);
            }
            lastMainModalHiddenState = isHidden;
        });
        observer.observe(modalOverlay, { attributes: true, attributeFilter: ["class"] });
        if (!modalOverlay.classList.contains("hidden")) {
            ensureMainModalTools();
            setMainModalBoardMode(false);
        }
    }

    /* --- 2. サブモーダル制御 --- */
    function openSubModal(title, html) {
        document.getElementById("sub-modal-title").innerText = title;
        document.getElementById("sub-modal-body").innerHTML = html;
        document.getElementById("sub-modal-overlay").classList.remove("hidden");
    }

    function closeSubModal() {
        document.getElementById("sub-modal-overlay").classList.add("hidden");
    }

    /* --- 3. 共通ガイド表示 --- */
    function showRuleSub() {
        openGuide("rule", "sub");
    }

    function showRoleSub() {
        openGuide("role", "sub");
    }

    window.closeSubModal = closeSubModal;
    window.toggleMainModalBoardMode = toggleMainModalBoardMode;
    window.showRuleSub = showRuleSub;
    window.showRoleSub = showRoleSub;
</script>

</body>
</html>
