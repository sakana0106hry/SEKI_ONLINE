<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SEKI Online</title>
    <style>
    /* ãƒ™ãƒ¼ã‚¹è¨­å®šï¼šãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒ¢ãƒ€ãƒ³ã«ã€èƒŒæ™¯ã‚’ãƒªãƒƒãƒã« */
    @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap');

    body { 
        font-family: "M PLUS Rounded 1c", sans-serif; 
        
        /* èƒŒæ™¯ã‚’å›ºå®šï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦ã‚‚ä»˜ã„ã¦ãã‚‹ã‚ˆã†ã«ï¼‰ */
        background: radial-gradient(circle, #2e7d32 0%, #1b5e20 60%, #003300 100%);
        background-attachment: fixed; /* â˜…é‡è¦ */
        
        color: white; 
        margin: 0; 
        text-align: center; 
        user-select: none; 
        -webkit-tap-highlight-color: transparent;
        
        min-height: 100dvh;       /* ã‚¹ãƒãƒ›å¯¾å¿œ */

        /* â˜…ã“ã“ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ã‚‹ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®å³ç«¯ã«å‡ºã‚‹ï¼‰ */
        overflow-y: auto; 
        overflow-x: hidden;

        display: flex;        /* FlexboxåŒ– */
        flex-direction: column;
    }

    /* å…±é€šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
    #game-screen { 
        padding: 0;           /* ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¯å†…éƒ¨ã§èª¿æ•´ */
        margin: 0 auto;
        width: 100%;
        max-width: 800px;     /* æ¨ªå¹…åˆ¶é™ */
        
        /* é«˜ã•ã¯ä¸­èº«ã«åˆã‚ã›ã¦ä¼¸ã³ã‚‹ */
        height: auto;
        min-height: 100vh;

        display: flex;
        flex-direction: column;
        overflow: visible;     /* ã“ã“ã‚‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
    }
    #header-info {
        flex: 0 0 40px;       /* é«˜ã•40pxå›ºå®š */
        padding: 10px;        /* ä½™ç™½ */
    }
    /* ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ï¼ˆç”»é¢ä¸­å¤®ã«é…ç½®ï¼‰ */
    #login-screen {
        width: 90%;             /* ã‚¹ãƒãƒ›ã§æ¨ªå¹…ã„ã£ã±ã„ã«ãªã‚‰ãªã„ã‚ˆã†ã« */
        max-width: 400px;       /* PCã§åºƒãŒã‚Šã™ããªã„ã‚ˆã†ã« */
        
        /* Flexboxã®é­”æ³•ï¼šã“ã‚Œã§ä¸Šä¸‹å·¦å³ã®ã©çœŸã‚“ä¸­ã«æ¥ã¾ã™ */
        margin: auto;           
        
        padding: 40px 30px;     /* å†…å´ã®ä½™ç™½ã‚’å°‘ã—ãƒªãƒƒãƒã« */
        
        /* ãƒ‡ã‚¶ã‚¤ãƒ³è£…é£¾ */
        background: rgba(0, 0, 0, 0.5); /* å°‘ã—æ¿ƒã„ã‚ã«ã—ã¦æ–‡å­—ã‚’è¦‹ã‚„ã™ã */
        backdrop-filter: blur(10px);    /* ã™ã‚Šã‚¬ãƒ©ã‚¹åŠ¹æœã‚’å¼·ã */
        border-radius: 20px;
        border: 1px solid rgba(255,255,255,0.2);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5); /* æµ®éŠæ„Ÿã®ã‚ã‚‹å½± */
        
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;              /* è¦ç´ é–“ã®éš™é–“ */
    }
    .hidden { display: none !important; }
    
    /* å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã¨ãƒœã‚¿ãƒ³ã®ãƒªãƒƒãƒåŒ– */
    input { 
        padding: 12px; 
        font-size: 16px; 
        margin: 10px 0; 
        border-radius: 8px; 
        border: 2px solid rgba(255,255,255,0.3);
        background: rgba(255,255,255,0.9);
        width: 80%;
    }
    button { 
        padding: 12px 24px; 
        font-size: 16px; 
        cursor: pointer; 
        background: linear-gradient(135deg, #fdd835, #fbc02d); /* é‡‘è‰²ã®ç«‹ä½“æ„Ÿ */
        border: none; 
        border-radius: 25px; 
        font-weight: bold; 
        color: #3e2723; 
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        transition: transform 0.1s, box-shadow 0.1s;
    }
    button:hover { filter: brightness(1.1); transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.4); }
    button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    button:disabled { background: #bdbdbd; color: #757575; cursor: not-allowed; transform: none; box-shadow: none; }

    /* ã‚¨ãƒªã‚¢ã”ã¨ã®ãƒ‘ãƒãƒ«åŒ–ï¼ˆã‚°ãƒ©ã‚¹ãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼‰ */
    #my-area, #login-screen {
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(5px);
        border-radius: 16px;
        border: 1px solid rgba(255,255,255,0.1);
        padding: 15px;
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        margin-top: 10px;
    }

    /* ã‚«ãƒ¼ãƒ‰ãƒ»ç›¤é¢ãƒ‡ã‚¶ã‚¤ãƒ³ */
    .pile { 
        width: 60px; height: 90px; 
        border: 2px dashed rgba(255,255,255,0.5); 
        border-radius: 8px;
        margin: auto; display:flex; align-items:center; justify-content:center; 
        background: rgba(0,0,0,0.2); 
        cursor: pointer; transition: 0.2s; 
    }
    .pile:hover { background: rgba(255,255,255,0.1); border-color: #ffeb3b; transform: scale(1.05); }

    .card { 
        width: 54px; height: 86px; 
        background-color: #fafafa; color: #333; 
        border-radius: 6px; 
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.3); /* ã‚«ãƒ¼ãƒ‰ã®å½± */
        display: inline-flex; align-items: center; justify-content: center; 
        font-weight: bold; margin: 3px; font-size: 22px; 
        cursor: pointer; position: relative; 
        transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* ãƒãƒã®ã‚ˆã†ãªå‹•ã */
        vertical-align: bottom;
        background-size: cover; background-position: center; background-repeat: no-repeat;
    }
    /* ã‚«ãƒ¼ãƒ‰ã®å‹•ã */
    .card:not(.selected):hover { transform: translateY(-8px) rotate(2deg); z-index: 5; }
    
    .card.num { color: #1565c0; font-family: 'Arial Black', sans-serif; }
    .card.sym { color: #c62828; font-size: 11px; text-align:center; line-height:1.1; letter-spacing: -0.5px;}
    .card[data-val="0"] { border: 2px solid #ab47bc; color: #8e24aa; background: #f3e5f5; }

    /* é¸æŠçŠ¶æ…‹ï¼šå…‰ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
    .selected { 
        transform: translateY(-20px) scale(1.1) !important; 
        border: 2px solid #ffeb3b; 
        box-shadow: 0 0 15px #ffeb3b, 0 10px 20px rgba(0,0,0,0.5); 
        z-index: 100; 
    }
    .card.has-img { color: transparent !important; font-size: 0; border: 2px solid #fff; }

    /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º */
    /* --- å††å“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨CSS --- */
    /* --- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾© (å…‰ã‚‹æ¼”å‡ºç”¨) --- */
    @keyframes pulse-yellow {
        0% { box-shadow: 0 0 5px #ffeb3b; }
        50% { box-shadow: 0 0 15px #ffeb3b, 0 0 5px rgba(255,235,59,0.5) inset; }
        100% { box-shadow: 0 0 5px #ffeb3b; }
    }
    @keyframes blink-red {
        0% { border-color: #ff1744; background-color: rgba(255, 23, 68, 0.1); }
        50% { border-color: #b71c1c; background-color: rgba(255, 23, 68, 0.3); }
        100% { border-color: #ff1744; background-color: rgba(255, 23, 68, 0.1); }
    }
    @keyframes blink-orange {
        0% { border-color: #ff9800; }
        50% { border-color: #ffe0b2; }
        100% { border-color: #ff9800; }
    }
    @keyframes pulse-badge { from{transform:scale(1);} to{transform:scale(1.3);} }

    /* --- å††å“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨ (ç”»é¢åˆ†å‰²) --- */
    #game-table {
        /* æ®‹ã‚Šã®é«˜ã•ã‚’å…¨éƒ¨ä½¿ã† */
        flex: 1;
        
        display: flex;
        flex-direction: column;
        width: 100%;
        position: relative;
        
        /* â˜…ã“ã“ãŒé‡è¦ï¼šå…¥ã‚Šåˆ‡ã‚‰ãªã„å ´åˆã¯ã“ã“ã ã‘ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ã‚‹ */
        overflow-y: visible; 
        
        /* â˜…ãƒ­ã‚°ãƒãƒ¼(35px)ã¨è¢«ã‚‰ãªã„ã‚ˆã†ã€åº•ä¸Šã’ã™ã‚‹ */
        padding-bottom: 80px !important; 
        
        /* æ¨ªã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚° */
        padding-left: 10px;
        padding-right: 10px;
        box-sizing: border-box;
        
        /* é«˜ã•æŒ‡å®šï¼ˆcalcï¼‰ã¯å‰Šé™¤ã—ã¦ auto ã« */
        height: auto !important; 
    }

    /* ã‚¨ãƒªã‚¢å®šç¾© */
    #area-top {
        height: 15%; /* ç”»é¢ä¸Šéƒ¨ */
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: 10px;
        padding-bottom: 5px;
    }

    #area-middle {
        flex: 1; /* æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ */
        display: flex;
        align-items: center;
        /* justify-content: space-between;  â† ã“ã‚Œã‚’å‰Šé™¤ã—ã¦ */
        justify-content: center;         /* â† ã“ã‚Œã«å¤‰æ›´ï¼ */
        gap: 5px;                        /* â† é–“éš”ã‚’å°‘ã—ç©ºã‘ã‚‹ */
        width: 100%;
        position: relative;
    }
    /* â†“â†“â†“ è¿½åŠ : è‡ªåˆ†ã®æ‰‹ç•ªã®ã¨ãã®å¼·èª¿è¡¨ç¤º â†“â†“â†“ */
    #my-area.current-turn {
        border: 2px solid #ffeb3b !important;       /* é»„è‰²ã„æ ç·š */
        box-shadow: 0 0 30px rgba(255, 235, 59, 0.5); /* ã¼ã‚“ã‚„ã‚Šå…‰ã‚‹ */
        background: rgba(60, 60, 0, 0.5);           /* èƒŒæ™¯ã‚‚å°‘ã—é»„è‰²ã */
        transform: translateY(-2px);                /* ã»ã‚“ã®å°‘ã—æµ®ãä¸ŠãŒã‚‹ */
        transition: all 0.3s ease;
    }

    /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ (å·¦å³ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼) */
    /* --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¨ãƒªã‚¢ã®æ çµ„ã¿ --- */
    /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®å¹…ã‚’å°‘ã—åºƒã’ã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒœãƒƒã‚¯ã‚¹ãŒå…¥ã‚‹ã‚ˆã†ã«ã™ã‚‹ */
    /* --- 1. ã‚¨ãƒªã‚¢å®šç¾©ã®èª¿æ•´ (ãƒœãƒƒã‚¯ã‚¹æ‹¡å¤§ã«åˆã‚ã›ã¦åºƒã’ã‚‹) --- */
    
    /* å·¦å³ã®ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼šå¹…ã‚’åºƒã’ã‚‹ */
    .player-zone.col {
        width: 150px; /* 80px -> 110px -> 130px ã«æ‹¡å¤§ */
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 10px;
        z-index: 10; /* ä¸­å¤®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚ˆã‚Šæ‰‹å‰ã«è¡¨ç¤º */
    }

    /* ä¸Šéƒ¨ã‚¨ãƒªã‚¢ï¼šé«˜ã•ã‚’ç¢ºä¿ */
    #area-top {
        height: auto;
        min-height: 130px; /* ãƒœãƒƒã‚¯ã‚¹ãŒã—ã£ã‹ã‚Šå…¥ã‚‹é«˜ã• */
        display: flex;
        justify-content: center;
        align-items: flex-end; /* ä¸‹æƒãˆ */
        gap: 12px; /* æ¨ªä¸¦ã³æ™‚ã®éš™é–“ */
        padding-bottom: 5px;
        z-index: 10;
    }
    /* â†“â†“â†“ è¿½åŠ : è‡ªåˆ†ã®ãƒãƒ¼ãƒ ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼é¢¨ï¼‰ â†“â†“â†“ */
    .my-name-plate {
        background: rgba(0, 0, 0, 0.4);       /* å°‘ã—æš—ãã—ã¦æ–‡å­—ã‚’ç›®ç«‹ãŸã›ã‚‹ */
        border-bottom: 1px solid rgba(255,255,255,0.15);
        padding: 8px 15px;
        margin: -15px -15px 10px -15px;       /* è¦ªã®padding(15px)ã‚’ç›¸æ®ºã—ã¦ä¸Šç«¯ã«å¯†ç€ */
        border-radius: 16px 16px 0 0;         /* è¦ªã®è§’ä¸¸ã«åˆã‚ã›ã¦ä¸¸ã‚ã‚‹ */
        
        font-weight: bold;
        font-size: 14px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 6px;
        color: #fff;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    /* --- 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆæœ¬ä½“ (ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—) --- */
    .p-box-new {
        width: 140px;            /* æ¨ªå¹… */
        height: 110px;           /* â˜…é«˜ã•ã‚’æ•°å€¤ã§å¼·åˆ¶å›ºå®šï¼ */
        
        display: flex;
        flex-direction: column;  /* ç¸¦ä¸¦ã³ */
        justify-content: space-between; /* ä¸Šãƒ»ä¸­ãƒ»ä¸‹ã‚’ãã£ã¡ã‚Šé…ç½® */
        
        background: rgba(30, 40, 50, 0.9);
        border: 1px solid rgba(255,255,255,0.4);
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.6);
        transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
        overflow: hidden;        /* â˜…ã¯ã¿å‡ºã—ãŸåˆ†ã¯ã‚«ãƒƒãƒˆï¼ˆã“ã‚Œã§ä¼¸ã³ãªã„ï¼‰ */
    }

    /* æ‰‹ç•ªã®ã¨ãã®å¼·èª¿ */
    .p-box-new.current {
        border: 2px solid #ffeb3b;
        box-shadow: 0 0 20px rgba(255, 235, 59, 0.7);
        background: rgba(70, 70, 10, 0.9);
        z-index: 100;
        /* currentã§æ‹¡å¤§ã•ã›ã‚‹ã¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒå´©ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ã€
           scaleã§ã¯ãªã translate ã‚„ shadow ã ã‘ã§ç›®ç«‹ãŸã›ã‚‹ã®ãŒå®‰å…¨ã§ã™ãŒã€
           ä¸€æ—¦ scale(1.05) ã¯ãã®ã¾ã¾ã§ã„ãã¾ã™ */
        transform: scale(1.05);
    }

    /* --- 3. å†…éƒ¨ãƒ‘ãƒ¼ãƒ„ (æ–‡å­—ã‚µã‚¤ã‚ºæ‹¡å¤§) --- */

    /* ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆåå‰ï¼‰ */
    .p-header {
        height: 26px;            /* â˜…é«˜ã•å›ºå®š */
        line-height: 26px;       /* å‚ç›´ä¸­å¤® */
        padding: 0 4px;
        background: rgba(255,255,255,0.15);
        border-bottom: 1px solid rgba(255,255,255,0.1);
        font-size: 13px;
        font-weight: bold;
        color: #fff;
        white-space: nowrap;     /* æ”¹è¡Œã•ã›ãªã„ */
        overflow: hidden;
        text-overflow: ellipsis; /* é•·ã™ããŸã‚‰...ã«ã™ã‚‹ */
    }

    .p-host-mark { color: #ffd700; margin-right: 4px; font-size: 13px; }

    /* --- 3æ®µå›ºå®šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨ã®ä¿®æ­£ --- */

    /* ä¸­æ®µï¼šæ‰‹æœ­æ•°ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ¨ªä¸¦ã³ã« */
    .p-body {
        flex: 1;                 /* â˜…ä½™ã£ãŸé«˜ã•ã‚’å…¨éƒ¨ä½¿ã† */
        display: flex;
        flex-direction: row;     /* æ¨ªä¸¦ã³ */
        justify-content: space-between;
        align-items: center;
        padding: 0 8px;
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    /* å·¦å´ï¼šæ‰‹æœ­æšæ•°ï¼ˆãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã¯ãã®ã¾ã¾ç¶­æŒï¼‰ */
    .p-hand-count {
        flex-shrink: 0 !important;      /* æ¨ªå¹…ãŒè¶³ã‚Šãªãã¦ã‚‚ã€çµ¶å¯¾ã«ç¸®ã‚ãªã„ï¼ */
        white-space: nowrap !important; /* å‹æ‰‹ã«æ”¹è¡Œã•ã›ãªã„ï¼ */
        font-size: 24px;         /* â˜…ãã®ã¾ã¾ï¼ */
        font-weight: 800;
        color: #fff;
        display: flex; 
        align-items: center; 
        gap: 2px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }
    .p-hand-icon { font-size: 16px; opacity: 0.8; margin-right: 2px; } 

    /* å³å´ï¼šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚¨ãƒªã‚¢ */
    .p-status-area {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        justify-content: center;
    }
    
    /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ–‡å­—ã®ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾© */
    .status-text { font-size: 10px; font-weight: bold; letter-spacing: 1px; }
    
    .status-normal { color: #546e7a; } /* NORMAL: ç›®ç«‹ãŸãªã„ã‚°ãƒ¬ãƒ¼ */
    
    .status-reset { 
        color: #ffeb3b; 
        animation: pulse-yellow 2s infinite; 
        border: 1px solid #ffeb3b;
        padding: 0 4px;
        border-radius: 4px;
        background: rgba(0,0,0,0.3);
    }
    
    .status-rank {
        color: #ffd700;
        font-size: 14px; /* é †ä½ã¯å°‘ã—å¤§ãã */
        text-shadow: 0 0 5px #ff9800;
    }

    /* ä¸‹æ®µï¼šå½¹è·ã‚¨ãƒªã‚¢ï¼ˆé«˜ã•å›ºå®šï¼‰ */
    .p-role-row {
        height: 30px;            /* â˜…é«˜ã•å›ºå®š */
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0,0,0,0.2);
        padding: 0 4px;
    }

    /* --- å½¹è·ãƒãƒƒã‚¸ï¼ˆè¦–èªæ€§ã‚¢ãƒƒãƒ—ç‰ˆï¼‰ --- */
    .role-badge-pill {
        font-size: 13px;       /* 12px -> 13px (å°‘ã—å¤§ãã) */
        font-weight: 800;      /* å¤ªæ–‡å­—ã«ã—ã¦ã‚¯ãƒƒã‚­ãƒªã•ã›ã‚‹ */
        
        padding: 2px 0;        /* ä¸Šä¸‹ã¯è©°ã‚ã¦æ–‡å­—ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ */
        width: 95%;            /* æ¨ªå¹…ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
        
        /* æ˜ã‚‹ãç›®ç«‹ã¤ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤‰æ›´ */
        background: linear-gradient(135deg, #e040fb, #7b1fa2); 
        border: 1px solid #fff; /* ç™½ã„æ ç·šã§å›²ã‚“ã§å¼·èª¿ */
        
        /* ã»ã‚“ã®ã‚Šç™ºå…‰ã•ã›ã¦ç›®ç«‹ãŸã›ã‚‹ */
        box-shadow: 0 0 8px rgba(224, 64, 251, 0.6);
        
        color: #fff;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        
        /* ä¸­å¤®æƒãˆ */
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 12px;
        letter-spacing: 1px;
    }

    /* æ­£ä½“ä¸æ˜ã®ã¨ãï¼ˆROLE: ???ï¼‰ã‚‚è¦‹ã‚„ã™ã */
    .role-unknown {
        font-size: 11px;
        /* æš—ã„ã‚°ãƒ¬ãƒ¼ã§ã¯ãªãã€åŠé€æ˜ã®ç™½ã«ã—ã¦èª­ã¿ã‚„ã™ãã™ã‚‹ */
        color: rgba(255, 255, 255, 0.6); 
        font-weight: bold;
        letter-spacing: 2px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    /* ä¿®æ­£: å½¹è·ã®è£œè¶³æƒ…å ±ï¼ˆæ‰‹å“å¸«ã®ã‚¹ã‚­ãƒ«åãªã©ï¼‰ã‚’æ¨ªä¸¦ã³ã«ã™ã‚‹ */
    .role-sub { 
        font-size: 10px; 
        display: inline;      /* æ¨ªã«ä¸¦ã¹ã‚‹ */
        opacity: 0.9; 
        margin-left: 4px;
    }
    /* --- 4. å…¬é–‹ã‚«ãƒ¼ãƒ‰ (ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ã‚‚æ‹¡å¤§) --- */
    .p-revealed-container {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 3px;
        margin-top: 6px;
        width: 140px; /* ãƒœãƒƒã‚¯ã‚¹å¹…ã«åˆã‚ã›ã‚‹ */
    }
    .mini-card {
        width: 24px; height: 36px; /* 18x26 -> 24x36 ã«æ‹¡å¤§ */
        border-radius: 4px;
        background: #fff;
        color: #333;
        font-size: 14px; /* æ•°å­—ã‚‚èª­ã¿ã‚„ã™ã */
        font-weight: bold;
        line-height: 36px;
        text-align: center;
        border: 1px solid #999;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }
    /* 0ã®ã‚«ãƒ¼ãƒ‰ */
    .mini-card[data-val="0"] { border: 1px solid #ab47bc; color: #8e24aa; background: #f3e5f5; }

    /* --- ãã®ä»–å¾®èª¿æ•´ --- */
    /* è‡ªåˆ†ã‚¨ãƒªã‚¢ãŒéš ã‚Œãªã„ã‚ˆã†ã«ãƒãƒ¼ã‚¸ãƒ³ç¢ºä¿ */
    /* ä¸­å¤®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆã‚¾ãƒ¼ãƒ³åˆ†ã‘ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿®æ­£ï¼‰ */
    #field-center {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between; /* ä¸Šä¸‹ã«è¦ç´ ã‚’åˆ†æ•£ */
        
        background: rgba(0,0,0,0.2);
        border-radius: 20px;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        
        padding: 5px;
        margin: 0 5px;
        z-index: 1;
    }
    /* --- ã‚¾ãƒ¼ãƒ³åˆ†ã‘ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
    
    /* ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ï¼ˆå°‘ã—å°ã•ãï¼‰ */
    /* ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ï¼ˆç”»åƒã‚’å¤§ããå¼·èª¿ï¼‰ */
    #indicator { 
        width: auto;           /* æ¨ªå¹…ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
        height: auto;         /* é«˜ã•ã¯è‡ªå‹•ã§åˆã‚ã›ã‚‹ */
        max-height: 60px;     /* å¤§ãããªã‚Šã™ããªã„ã‚ˆã†ã«åˆ¶é™ */
        object-fit: contain;  /* ç”»åƒå…¨ä½“ãŒåã¾ã‚‹ã‚ˆã†ã« */
        
        border-radius: 8px;   /* è§’ã‚’ä¸¸ã */
        
        /* ç«‹ä½“æ„Ÿã‚’å‡ºã™å½±ã¨ã€å°‘ã—ã®ç™ºå…‰ */
        box-shadow: 0 5px 15px rgba(0,0,0,0.6);
        filter: drop-shadow(0 0 2px rgba(255,255,255,0.3));
        
        margin-bottom: 10px;  /* ä¸‹ã¨ã®éš™é–“ã‚’ç¢ºä¿ */
        display: block;       /* ãƒ–ãƒ­ãƒƒã‚¯è¦ç´ ã«ã—ã¦ä¸­å¤®å¯„ã› */
        margin-left: auto;
        margin-right: auto;
    }

    /* å·¦å³ã®ã‚¾ãƒ¼ãƒ³ã‚’ã¾ã¨ã‚ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ */
    .field-zone-container {
        display: flex;
        justify-content: center;
        gap: 8px; /* ã‚¾ãƒ¼ãƒ³é–“ã®éš™é–“ */
        width: 100%;
        flex: 1; /* é«˜ã•ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
    }

    /* å€‹åˆ¥ã‚¾ãƒ¼ãƒ³ã®æ  */
    .field-zone {
        flex: 1; /* å·¦å³å‡ç­‰ */
        border-radius: 12px;
        padding: 5px 2px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        border: 1px solid rgba(255,255,255,0.15);
        position: relative;
    }

    /* æ•°å­—ã‚¾ãƒ¼ãƒ³ (é’ç³») */
    .zone-num {
        background: rgba(33, 150, 243, 0.1); 
        border-color: rgba(33, 150, 243, 0.3);
    }
    /* è¨˜å·ã‚¾ãƒ¼ãƒ³ (èµ¤ç³») */
    .zone-sym {
        background: rgba(244, 67, 54, 0.1); 
        border-color: rgba(244, 67, 54, 0.3);
    }

    /* ãƒ©ãƒ™ãƒ« (NUMBER / SYMBOL) */
    .zone-label {
        font-size: 12px;
        font-weight: bold;
        letter-spacing: 1px;
        margin-bottom: 2px;
        opacity: 0.6;
    }

    /* å¢“åœ°ã‚¹ãƒ­ãƒƒãƒˆ (å°‘ã—ç¸®å°) */
    .grave-slot {
        transform: scale(0.9); 
        margin-bottom: auto; /* å±±æœ­ã‚’ä¸‹ã«æŠ¼ã—ã‚„ã‚‹ */
    }

    /* å±±æœ­ã‚¨ãƒªã‚¢ (ã‚¢ã‚¤ã‚³ãƒ³åŒ–) */
    .deck-slot {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        background: rgba(0,0,0,0.25);
        padding: 4px 10px;
        border-radius: 15px;
        margin-bottom: 5px;
        cursor: default;
    }

    /* å±±æœ­ã‚¢ã‚¤ã‚³ãƒ³ (CSSã§ã‚«ãƒ¼ãƒ‰è£é¢ã‚’è¡¨ç¾) */
    .deck-icon {
        width: 12px; height: 18px;
        border-radius: 2px;
        border: 1px solid #fff;
    }
    .deck-icon.num { background: repeating-linear-gradient(45deg, #1565c0, #1565c0 2px, #0d47a1 2px, #0d47a1 4px); }
    .deck-icon.sym { background: repeating-linear-gradient(45deg, #c62828, #c62828 2px, #b71c1c 2px, #b71c1c 4px); }

    /* å±±æœ­ã®æ•°å­— */
    .deck-count {
        font-size: 14px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 1px 2px #000;
    }

    /* é™¤å¤–ã‚¨ãƒªã‚¢ (ã‚´ãƒŸç®±) */
    #exclusion-area {
        margin-top: 2px;
        font-size: 11px;
        opacity: 0.8;
        cursor: pointer;
        background: rgba(0,0,0,0.3);
        padding: 3px 12px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        gap: 5px;
        transition: 0.2s;
    }
    #exclusion-area:hover { opacity: 1; background: rgba(0,0,0,0.5); }

    /* æ®‹ã‚Šæšæ•°ãƒãƒƒã‚¸ã‚‚å¤§ãã */
    .p-count-badge {
        width: 24px; height: 24px;
        line-height: 24px;
        font-size: 14px;
        top: -10px; left: -10px;
    }

    /* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰èª¿æ•´ */
    #graveyard-container { display: flex; gap: 15px; align-items: center; }
    .grave-box { text-align: center; cursor: pointer; transition: transform 0.1s; }
    .grave-box:active { transform: scale(0.95); }
    .grave-label { font-size: 10px; color: #ccc; }

    /* ãƒ­ã‚°ã‚¨ãƒªã‚¢ */
    #game-log-bar { 
        position: fixed; bottom: 0; left: 0; width: 100%; height: 35px; 
        background: rgba(33, 33, 33, 0.95); font-size: 13px; line-height: 35px; 
        text-align: left; padding-left: 15px; overflow: hidden; white-space: nowrap; 
        z-index: 50; cursor: pointer; border-top: 1px solid #555; box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
    }
    
    /* é€šçŸ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    @keyframes flash-notify {
        0% { background-color: #ff9800; transform: scale(1); }
        50% { background-color: #f57c00; transform: scale(1.1); }
        100% { background-color: #ff9800; transform: scale(1); }
    }
    .notify-active { animation: flash-notify 1s infinite; border: 2px solid #fff !important; }
    .notify-bar { background-color: #ff9800 !important; color: white !important; font-weight: bold; }

    /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
    #modal-overlay {
        position: fixed; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.6); z-index: 999;
        backdrop-filter: blur(3px); /* èƒŒæ™¯ã‚’ã¼ã‹ã™ */
        display: flex; justify-content: center; align-items: center;
        animation: fadeIn 0.2s ease;
    }
    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }

    #modal-box {
        background: #fff; color: #333; padding: 25px; border-radius: 12px;
        max-width: 90%; max-height: 80%; width: 400px;
        overflow-y: auto; text-align: center; display:flex; flex-direction:column;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    #modal-content { margin-bottom: 20px; flex: 1; overflow-y: auto; }
    .modal-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .modal-btn { margin: 5px; padding: 10px 20px; background: #e0e0e0; border:none; border-radius: 5px; cursor: pointer; font-size:14px; transition:0.2s; }
    .modal-btn:hover { background: #d5d5d5; }
    .modal-btn.primary { background: #fdd835; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .modal-btn.danger { background: #ef5350; color: white; font-weight: bold; }

    /* ãƒ­ã‚°ã‚¹ã‚¿ã‚¤ãƒ« */
    .log-entry { text-align: left; padding: 8px; border-bottom: 1px solid #eee; font-size: 13px; display: flex; align-items: flex-start; }
    .log-time { color: #888; margin-right: 10px; font-size: 11px; min-width: 45px; }
    .log-text { word-break: break-all; line-height: 1.4; }
    .log-private .log-text { color: #d32f2f; font-weight: bold; background: #ffebee; padding: 2px 5px; border-radius: 4px;}
    .log-chat { background: #f1f8e9; }
    
    /* ãƒãƒ£ãƒƒãƒˆå…¥åŠ› */
    #chat-input-container { display: flex; gap: 8px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #ccc; }
    #chat-input { flex: 1; padding: 10px; border-radius: 20px; border: 1px solid #ccc; outline:none; }
    #chat-send-btn { background: #43a047; color: white; border-radius: 20px; padding: 0 20px; }

    .host-settings { margin-bottom: 15px; font-size: 14px; text-align: left; background: rgba(0,0,0,0.1); padding: 10px; border-radius: 8px; }
    .host-settings label { margin-right: 15px; cursor: pointer; display: inline-block; padding: 5px; }
/* --- è¿½åŠ ä¿®æ­£: å¢“åœ°ã‚«ãƒ¼ãƒ‰ã®ã¯ã¿å‡ºã—é˜²æ­¢ --- */
    
    /* å¢“åœ°ï¼ˆpileï¼‰ã®ä¸­ã«ã‚ã‚‹ã‚«ãƒ¼ãƒ‰ã¯ä½™ç™½ã¨å½±ã‚’ãªãã™ */
    .pile .card {
        margin: 0; 
        box-shadow: none; /* åŸ‹ã¾ã£ã¦ã„ã‚‹æ„Ÿã˜ã«ã™ã‚‹ãŸã‚å½±ã‚‚æ¶ˆã™ */
        width: 100%; /* æ ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
        height: 100%;
        border: none; /* æ ç·šã‚‚pileå´ã«ä»»ã›ã¦æ¶ˆã™ */
        border-radius: 6px; /* è§’ä¸¸ã‚’åˆã‚ã›ã‚‹ */
    }
    
    /* å¢“åœ°ã®ã‚«ãƒ¼ãƒ‰ã¯ãƒ›ãƒãƒ¼ã—ã¦ã‚‚æµ®ãä¸ŠãŒã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ */
    .pile:hover .card {
        transform: none; 
    }

    /* --- å½¹è·ãƒ‘ãƒãƒ«ã®ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
    #my-role-panel {
        margin: 10px 0;
        display: flex;
        justify-content: center;
    }

    .role-card {
        background: linear-gradient(135deg, #6a1b9a, #4a148c); /* ç´«ç³»ã®é«˜è²´ãªè‰² */
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        border: 1px solid #e1bee7;
        box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        text-align: center;
        width: 100%;
        max-width: 300px;
        position: relative;
        overflow: hidden;
    }
    
    /* èƒŒæ™¯ã«ã†ã£ã™ã‚‰è£…é£¾ */
    .role-card::before {
        content: 'ROLE';
        position: absolute;
        top: -10px; right: -10px;
        font-size: 50px;
        color: rgba(255,255,255,0.05);
        font-weight: bold;
        transform: rotate(15deg);
    }

    .role-name {
        font-family: 'Arial Black', sans-serif;
        font-size: 16px;
        letter-spacing: 1px;
        color: #dc94e9;
        text-transform: uppercase;
    }
    
    .role-jp {
        font-size: 20px;
        font-weight: bold;
        margin: 2px 0;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .role-desc {
        font-size: 11px;
        color: #c0a4ef;
        border-top: 1px solid rgba(255,255,255,0.3);
        margin-top: 5px;
        padding-top: 4px;
    }
    /* --- ã‚«ãƒƒãƒˆã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨CSS --- */
    #cut-in-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7); /* èƒŒæ™¯ã‚’å°‘ã—æš—ãã™ã‚‹ */
        z-index: 9999; /* æœ€å‰é¢ã«è¡¨ç¤º */
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: none; /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã‚‚è£ã®æ“ä½œã‚’é˜»å®³ã—ãªã„ãªã‚‰noneã€é‚ªé­”ã™ã‚‹ãªã‚‰auto */
        opacity: 0; /* åˆæœŸçŠ¶æ…‹ã¯é€æ˜ */
        transition: opacity 0.3s;
    }

    /* JavaScriptã§ hidden ãŒå¤–ã‚ŒãŸã‚‰è¡¨ç¤ºï¼ˆopacityã¯animate-cut-inã§åˆ¶å¾¡ã—ã¦ã‚‚ã‚ˆã„ãŒã€ãƒ™ãƒ¼ã‚¹ã‚’è¡¨ç¤ºã«ã™ã‚‹ï¼‰ */
    #cut-in-overlay:not(.hidden) {
        opacity: 1;
    }

    #cut-in-content {
        text-align: center;
        color: #ffeb3b;
        font-family: 'Arial Black', sans-serif;
        text-shadow: 0 0 10px #ff9800;
        transform: scale(0); /* æœ€åˆã¯å°ã•ã */
    }

    /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹ãŒä»˜ä¸ã•ã‚ŒãŸã¨ãã®å‹•ä½œ */
    .animate-cut-in #cut-in-content {
        animation: cutInZoom 2.5s ease-out forwards;
    }

    /* å‹•ãã®å®šç¾© */
    @keyframes cutInZoom {
        0% { transform: scale(0) rotate(-10deg); opacity: 0; }
        20% { transform: scale(1.2) rotate(0deg); opacity: 1; }
        30% { transform: scale(1.0); }
        80% { transform: scale(1.0); opacity: 1; }
        100% { transform: scale(1.5); opacity: 0; }
    }
    
    /* å½¹è·åï¼šã‚´ãƒ¼ãƒ«ãƒ‰ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã§é«˜ç´šæ„Ÿã‚’å‡ºã™ */
    #cut-in-role { 
        font-size: 50px; 
        font-weight: 900;
        margin-bottom: 5px; 
        
        /* é‡‘è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­— */
        background: linear-gradient(to bottom, #fff 0%, #ffd700 50%, #bf953f 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        
        /* å½±ã‚’ã¤ã‘ã¦æµ®ãä¸ŠãŒã‚‰ã›ã‚‹ */
        filter: drop-shadow(0 4px 0px rgba(0,0,0,0.5));
        
        /* å°‘ã—æ–œä½“ã«ã—ã¦ã‚¹ãƒ”ãƒ¼ãƒ‰æ„Ÿã‚’å‡ºã™ */
        font-style: italic;
        letter-spacing: 2px;
    }
    /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åï¼šç™½æ–‡å­—ã§ã‚·ãƒ³ãƒ—ãƒ«ã« */
    #cut-in-player { 
        font-size: 20px; 
        color: #ddd; 
        margin-bottom: 15px;
        letter-spacing: 1px;
        font-weight: bold;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }

    /* â–¼â–¼â–¼ ã‚¯ãƒƒã‚­ãƒªãƒ»èª­ã¿ã‚„ã™ã„ç‰ˆ â–¼â–¼â–¼ */
    #cut-in-text { 
        font-family: 'Impact', 'Arial Black', sans-serif;
        font-weight: 900;
        font-size: 60px; /* å°‘ã—å¤§ããã—ã¦è¦–èªæ€§UP */
        
        font-style: italic;
        letter-spacing: 0.1em;
        transform: skewX(-15deg);

        /* ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šç™½ã‚’å¤šã‚ã«ã—ã¦æ˜ã‚‹ãã‚¯ãƒƒã‚­ãƒªã•ã›ã‚‹ */
        background: linear-gradient(to bottom, #ffffff 45%, #cfd8dc 50%, #78909c 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;

        /* â˜…ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼šfilterã§ã¯ãªãã€Œç·šã€ã§ç¸å–ã‚Šã™ã‚‹ */
        /* ã“ã‚Œã«ã‚ˆã‚Šæ–‡å­—ã®è¼ªéƒ­ãŒãƒã‚·ãƒƒã¨æ±ºã¾ã‚Šã¾ã™ */
        -webkit-text-stroke: 2px #000;

        /* å½±ï¼šã¼ã‹ã—(px)ã‚’0ã«ã—ã¦ã€ãƒ‘ã‚­ãƒƒã¨ã—ãŸå½±ã‚’è½ã¨ã™ */
        filter: drop-shadow(4px 4px 0px rgba(0, 0, 0, 0.8));
            
        margin-top: 10px;
        white-space: nowrap;
        
        /* éš ã—å‘³ï¼šå°‘ã—ã ã‘å…‰ã‚‰ã›ãŸã„å ´åˆã¯ä»¥ä¸‹ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆè§£é™¤ */
        /* text-shadow: 0 0 10px rgba(255,255,255,0.5); */
    }
    

    /* â–¼â–¼â–¼ è¿½åŠ ï¼šçš‡å¸ãƒ‘ãƒãƒ«ç”¨ã®è¼ãã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ â–¼â–¼â–¼ */
    @keyframes goldShine {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    @keyframes goldPulse {
        0% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
        100% { box-shadow: 0 0 30px rgba(255, 215, 0, 1.0), 0 0 10px #fff; }
    }
    
    /* --- Hacked Corner (æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã¯å‰Šé™¤ã¾ãŸã¯ç„¡è¦–) --- */
    /* ä»£ã‚ã‚Šã«ä»¥ä¸‹ã‚’è¿½åŠ  */

    /* ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
    .card.locked {
        /* é€šå¸¸ã‚«ãƒ¼ãƒ‰ã¨åŒã˜ã‚µã‚¤ã‚ºãƒ»é…ç½® */
        filter: grayscale(0.9) brightness(0.6); /* ãƒ¢ãƒã‚¯ãƒ­ã«ã—ã¦æš—ãã™ã‚‹ */
        border: 2px dashed #ff1744 !important;   /* èµ¤æ ã§å±é™ºã‚’ç¤ºã™ */
        cursor: not-allowed;
        position: relative;
    }

    /* å³ä¸‹ã«éµã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤ºï¼ˆã‚«ãƒ¼ãƒ‰ã®çµµæŸ„ã‚’éš ã•ãªã„ï¼‰â‡å‰Šé™¤æ¸ˆã¿

    /* ãƒ›ãƒãƒ¼ã—ã¦ã‚‚æµ®ãä¸ŠãŒã‚‰ã›ãªã„ */
    .card.locked:hover {
        transform: none !important;
        box-shadow: none !important;
    }

    /* è­¦å¯Ÿã«ã‚ˆã‚‹å…¬é–‹ã‚«ãƒ¼ãƒ‰ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
    .card.revealed {
        /* é’è‰²ã®æ ç·šã§ã€Œè­¦å¯Ÿã€æ„Ÿã‚’å‡ºã™ */
        border: 3px solid #fdd835 !important;
        box-shadow: 0 0 10px rgba(246, 246, 41, 0.6); 
        position: relative; /* å¸¯ã®é…ç½®ç”¨ */
        overflow: hidden;   /* å¸¯ãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã« */
    }

    /* å³ä¸Šã®ã€ŒOPENã€å¸¯ */
    .card.revealed::after {
        content: "OPEN";
        position: absolute;
        top: 5px;
        right: -22px;
        width: 80px;
        height: 18px;
        background: #fdd835; /* è­¦å‘Šè‰²ï¼ˆé»„è‰²ï¼‰ */
        color: #000;
        font-size: 10px;
        font-weight: bold;
        text-align: center;
        line-height: 18px;
        transform: rotate(45deg); /* æ–œã‚ã«é…ç½® */
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        z-index: 20;
        pointer-events: none; /* ã‚¯ãƒªãƒƒã‚¯ã®é‚ªé­”ã‚’ã—ãªã„ */
        font-family: 'Arial Black', sans-serif;
    }

    /* --- ã‚¹ãƒãƒ›ãƒ»ç´°ã„ç”»é¢ç”¨ã®ã‚¹ãƒªãƒ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ --- */
    @media (max-width: 600px) {
        /* 1. å·¦å³ã®ã‚«ãƒ©ãƒ å¹…ã‚’è©°ã‚ã‚‹ */
        .player-zone.col {
            width: 105px !important; /* ãƒœãƒƒã‚¯ã‚¹å¹…ã«åˆã‚ã›ã¦æœ€å°é™ã« */
            z-index: 20;
        }

        /* 2. ãƒœãƒƒã‚¯ã‚¹ã‚’ã‚¹ãƒªãƒ åŒ– */
        .player-zone.col .p-box-new {
            width: 100px !important; /* 140px -> 100px ã«ç´°ãã™ã‚‹ */
            height: auto !important;    /* å›ºå®šã‚’ã‚„ã‚ã¦è‡ªå‹•ã« */
            min-height: 180px;          /* æœ€ä½ã§ã‚‚ã“ã®é«˜ã•ã‚’ç¢ºä¿ */
            padding-bottom: 5px;        /* ä¸‹ç«¯ã®ä½™ç™½ */ 
        }

        /* 3. ä¸­æ®µï¼ˆæ‰‹æœ­æ•°ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰ã‚’ç¸¦ç©ã¿ã« */
        .player-zone.col .p-box-new .p-body {
            flex-direction: column; /* ç¸¦ä¸¦ã³ */
            justify-content: center;
            gap: 8px; /* è©°ã‚ã‚‹ */
            padding: 5px 0;
            flex: 1;         /* ä½™ã£ãŸã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã‚‹ */
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã®ä½ç½®èª¿æ•´ */
        .player-zone.col .p-box-new .p-status-area {
            align-items: center; /* ä¸­å¤®æƒãˆ */
            width: 100%;
        }

        /* 4. ä¸‹æ®µï¼ˆå½¹è·ï¼‰ã®ã‚¨ãƒªã‚¢é«˜ã•ã‚’è‡ªå‹•èª¿æ•´ */
        .player-zone.col .p-box-new .p-role-row {
            height: auto !important; /* å›ºå®šé«˜ã•ã‚’è§£é™¤ */
            min-height: 40px;        /* æœ€ä½é™ã®é«˜ã•ç¢ºä¿ */
            padding: 5px 0;
            display: flex;
            align-items: center;     /* ä¸Šä¸‹ä¸­å¤®å¯„ã› */
            justify-content: center;
            margin-top: auto; /* ä¸€ç•ªä¸‹ã«æŠ¼ã—ä¸‹ã’ã‚‹ */
        }

        /* å½¹è·ãƒãƒƒã‚¸ã®ä¸­èº«ã‚’æŠ˜ã‚Šè¿”ã—ï¼ˆç¸¦ç©ã¿ï¼‰ã«ã™ã‚‹ */
        .player-zone.col .p-box-new .role-badge-pill {
            flex-direction: column; /* ç¸¦ä¸¦ã³ */
            width: 96%;             /* å¹…ã„ã£ã±ã„ */
            padding: 4px 0;
            line-height: 1.2;
            border-radius: 8px;     /* è§’ä¸¸ã‚’å°‘ã—ç·©ã‚ã‚‹ */
        }
        
        /* å½¹è·ã®è£œè¶³ï¼ˆREVERSEãªã©ï¼‰ã®ãƒ‡ã‚¶ã‚¤ãƒ³èª¿æ•´ */
        .player-zone.col .p-box-new .role-sub {
            display: block;        /* æ”¹è¡Œã•ã›ã‚‹ */
            margin-left: 0;
            margin-top: 3px;
            font-size: 9px;        /* å°‘ã—å°ã•ã */
            opacity: 0.9;
        }

        /* å…¬é–‹ã‚«ãƒ¼ãƒ‰ç½®ãå ´ã‚‚å¹…ã‚’åˆã‚ã›ã‚‹ */
        .player-zone.col .p-revealed-container {
            width: 100px !important;
        }
        
        /* ä¸­å¤®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã®éš™é–“ã‚’è©°ã‚ã‚‹ */
        #field-center {
            margin: 0 !important;
        }
        #area-middle {
            gap: 2px !important; /* å·¦å³ãƒœãƒƒã‚¯ã‚¹ã¨ã®éš™é–“ã‚’æœ€å°é™ã« */
        }

    }

    /* --- è¿½åŠ : å…¬é–‹ã‚«ãƒ¼ãƒ‰æƒ…å ±ï¼ˆãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºç”¨ï¼‰ --- */
        .p-revealed-info {
            font-size: 11px;
            margin-top: 5px;     /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨ã®éš™é–“ */
            white-space: nowrap; /* æŠ˜ã‚Šè¿”ã—ãªã— */
            line-height: 1.2;
            /* â˜…ã“ã“ãŒé‡è¦: ã‚²ãƒ¼ãƒ å…¨ä½“ã®ãƒ•ã‚©ãƒ³ãƒˆ(M PLUS Rounded 1c)ã‚’å¼·åˆ¶ã™ã‚‹ */
            font-family: "M PLUS Rounded 1c", "Rounded Mplus 1c", sans-serif !important;
        }

        /* ä½•ã‚‚å…¬é–‹ã•ã‚Œã¦ã„ãªã„æ™‚ (NORMALè¡¨ç¤ºã¨åŒã˜ã‚ˆã†ãªè‰²ã«) */
        .revealed-none {
            color: #546e7a;      /* è–„ã„ã‚°ãƒ¬ãƒ¼ */
            font-weight: bold;
        }

        /* å…¬é–‹ã•ã‚Œã¦ã„ã‚‹æ™‚ (ç›®ç«‹ãŸã›ã‚‹) */
        .revealed-active {
            color: #ffeb3b;      /* é»„è‰² */
            font-weight: bold;
        }
        
        /* å…ƒã€…ã®ç”»åƒè¡¨ç¤ºã‚¨ãƒªã‚¢ã¯å®Œå…¨ã«éè¡¨ç¤ºã«ã™ã‚‹ */
        .p-revealed-container {
            display: none !important;
        }
        
        /* ã‚¹ãƒãƒ›è¡¨ç¤ºã®å¾®èª¿æ•´ */
        @media (max-width: 600px) {
            .p-revealed-info {
                font-size: 10px;
            }
        }

        /* --- ç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾© --- */
        @keyframes blink-text {
            0% { opacity: 1.0; transform: scale(1.0); }
            50% { opacity: 0.5; transform: scale(1.05); } /* åŠé€æ˜ã«ãªã‚Šã¤ã¤å°‘ã—å¤§ãããªã‚‹ */
            100% { opacity: 1.0; transform: scale(1.0); }
        }

    



</style>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
</head>
<body>

    <div id="login-screen">
        <h1>SEKI Online</h1>
        <p>Ver 20.00 (ã»ã¼å®Œæˆ)</p>
        <input type="text" id="roomName" placeholder="åˆè¨€è‘‰ (ä¾‹: seki123)">
        <br>
        <input type="text" id="playerName" placeholder="ã‚ãªãŸã®åå‰">
        <br><br>
        <button id="btn-join" onclick="joinGame()">éƒ¨å±‹ã«å…¥ã‚‹ / ä½œã‚‹</button>
    </div>

    <div id="game-screen" class="hidden">
        <div id="header-info" style="display:flex; justify-content:space-between; align-items:center; padding:0 10px; font-size:12px; height:40px;">
            <div id="room-display"></div>
            <div style="display:flex; gap:10px; align-items:center;">
                <button id="btn-host-settings" class="hidden" onclick="openHostSettings()" 
                    style="padding:5px 12px; font-size:11px; background:#1565c0; color:white; border:1px solid rgba(255,255,255,0.3); border-radius:20px; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.3); display:flex; align-items:center;">
                    âš™ï¸ ãƒ›ã‚¹ãƒˆè¨­å®š
                </button>
                <button id="btn-bgm-toggle" onclick="toggleBgmMute()" style="padding:2px 8px; font-size:16px;">ğŸ”Š</button>
                <button onclick="location.reload()" style="padding:2px 8px; font-size:12px;">é€€å‡º</button>
            </div>
        </div>

        <div id="game-table">
            
            <div id="area-top" class="player-zone row"></div>

            <div id="area-middle">
                <div id="area-left" class="player-zone col"></div>

                <div id="field-center">
                    <img id="indicator" src="./images/reverse_blue.jpg" alt="é †è¡Œ/é€†è¡Œ">
                    
                    <div class="field-zone-container">
                        
                        <div class="field-zone zone-num">
                            <div class="zone-label">æ•°å­—å¢“åœ°</div>
                            
                            <div class="grave-slot" onclick="viewGrave('num')">
                                <div id="graveNum" class="pile"></div>
                            </div>
                            
                            <div class="deck-slot">
                                <div class="deck-icon num"></div>
                                <div id="deckNumCount" class="deck-count">-</div>
                            </div>
                        </div>

                        <div class="field-zone zone-sym">
                            <div class="zone-label">è¨˜å·å¢“åœ°</div>
                            
                            <div class="grave-slot" onclick="viewGrave('sym')">
                                <div id="graveSym" class="pile"></div>
                            </div>
                            
                            <div class="deck-slot">
                                <div class="deck-icon sym"></div>
                                <div id="deckSymCount" class="deck-count">-</div>
                            </div>
                        </div>
                    </div>

                    <div id="exclusion-area" onclick="viewGrave('excl')">
                        <span>ğŸ—‘ï¸é™¤å¤–ï¼š</span>
                        <span id="exclusion-count">0</span>
                    </div>
                    
                    <div id="msg" style="margin-top:2px; color:#ffeb3b; font-weight:bold; font-size:12px; height:18px; line-height:18px; white-space:nowrap;">å¾…æ©Ÿä¸­...</div>
                </div>

                <div id="area-right" class="player-zone col"></div>
            </div>

            <div id="my-area">
                <div id="my-name-bar" class="my-name-plate"></div>
            
                <div id="my-hand"></div>
                <div id="controls" style="margin-top:5px;">
                    <button id="btn-play" onclick="playCard()">æ±ºå®š</button>
                    <button id="btn-pass" onclick="passTurn()" style="background:#546e7a; color:white;">ãƒ‘ã‚¹</button>
                </div>

                <div id="my-role-panel"></div>

            </div>
        </div>
    </div>

    <div id="game-log-bar" onclick="showLogHistory()">ãƒ­ã‚°ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-box">
            <h3 id="modal-title">ã‚¿ã‚¤ãƒˆãƒ«</h3>
            <div id="modal-content">å†…å®¹</div>
            <div id="modal-footer">
                <button onclick="closeModal()" style="background:#90a4ae">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>

    <div id="cut-in-overlay" class="hidden">
        <div id="cut-in-bg"></div>
        <div id="cut-in-content">
            <div id="cut-in-role">ROLE NAME</div>
            <div id="cut-in-player">Player Name</div>
            <div id="cut-in-text">SKILL ACTIVATED!</div>
        </div>
    </div>

    <div id="visual-overlay" style="
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 9999;
    display: none; flex-direction: column; justify-content: center; align-items: center;
    color: white; font-family: 'Arial Black', sans-serif; pointer-events: none;
">
    <div id="squeeze-guess" style="
        position: absolute; top: 10%; 
        font-size: 24px; color: #ffeb3b; text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
    "></div>

    <div style="position: relative; width: 200px; height: 300px; border: 4px solid #fff; border-radius: 10px; overflow: hidden; background: #fff;">
        
        <div id="squeeze-content" style="
            width: 100%; height: 100%; 
            display: flex; justify-content: center; align-items: center;
            font-size: 150px; color: #333; font-weight: bold;
        ">?</div>

        <div id="squeeze-cover" style="
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(45deg, #1a237e, #1a237e 10px, #283593 10px, #283593 20px);
            transition: top 5s ease-in-out; /* 5ç§’ã‹ã‘ã¦ã˜ã‚ã˜ã‚å‹•ã */
        ">
            <div style="color:rgba(255,255,255,0.2); font-size:50px; text-align:center; padding-top:100px;">SEKI</div>
        </div>
    </div>

    <div id="squeeze-result" style="
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
        font-size: 80px; font-weight: bold; text-shadow: 2px 2px 0 #000;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        opacity: 0;
    "></div>
</div>

    <script>
        // ã‚¨ãƒ©ãƒ¼æŠ‘åˆ¶
        window.onerror = function(msg) { 
            // execPassResetã®ã‚¨ãƒ©ãƒ¼ç„¡è¦–è¡Œã‚’å‰Šé™¤ã—ã¾ã—ãŸ
            showInfoModal("ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼", msg); 
        };

        const CARD_IMAGES = {
            "TRADE": "./images/trade.png",
            "DIG UP": "./images/dig up.png",
            "DISCARD": "./images/discard.png",
            "REVERSE": "./images/reverse.png",
        };

        // å½¹è·ç”»åƒã®å®šç¾©ï¼ˆã“ã“ã«è¿½åŠ ã—ã¦ã„ãï¼‰
        const ROLE_IMAGES = {
        "ANGLER": "./images/angler.png",
        "FORTUNE TELLER": "./images/fortuneteller.png",
        "THIEF": "./images/thief.png",
        "HUNTER": "./images/hunter.png",
        "GAMBLER": "./images/gambler.png",
        "MAGICIAN": "./images/magician.png",
        "MILLIONAIRE": "./images/millionaire.png",
        "EMPEROR": "./images/emperor.png",
        "NEW GRAD": "./images/newgrad.png",
        "HACKER": "./images/hacker.png",
        "POLICE OFFICER": "./images/policeofficer.png",
        "ALCHEMIST": "./images/alchemist.png",
        "NECROMANCER": "./images/necromancer.png",
        //ä»–ã‚‚ã‚ã‚Œã°è¿½åŠ 
        };

        /* --- éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ç™»éŒ² --- */
        const SOUND_FILES = {
            // è³­åšå¸«ç”¨
            'DRUM': './sounds/drum.mp3',         // ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«
            'WIN_NORMAL': './sounds/win.mp3',    // æ™®é€šã®å½“ãŸã‚Š
            'WIN_BIG': './sounds/win_big.mp3',   // å¤§å½“ãŸã‚Šï¼
            'LOSE': './sounds/lose.mp3',          // è² ã‘...
            // BGM
            'BGM_LOBBY': './sounds/bgm_lobby.mp3',
            'BGM_BATTLE': './sounds/bgm_battle.mp3',
            // ã‚·ã‚¹ãƒ†ãƒ é€šçŸ¥
            'turn':    './sounds/turn.mp3',  // è‡ªåˆ†ã®ç•ª
            'chat':    './sounds/chat.mp3',  // ãƒãƒ£ãƒƒãƒˆå—ä¿¡
            'WARNING': './sounds/warning.mp3', // ãƒˆãƒ¬ãƒ¼ãƒ‰ã®è¢«å®³
            'DOS': './sounds/dos.mp3',
            'UNO': './sounds/uno.mp3',
            // é †ä½æ±ºå®šéŸ³
            'RANK_1':     './sounds/winner.mp3',  // 1ä½
            'RANK_2_3':   './sounds/normal.mp3',  // 2ä½ãƒ»3ä½
            'RANK_4':     './sounds/loser.mp3',  // 4ä½ï¼ˆæœ€ä¸‹ä½ï¼‰

            // ã‚«ãƒ¼ãƒ‰ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
            'PUT':     './sounds/put.mp3',
            'REVERSE': './sounds/reverse.mp3',
            'TRADE':   './sounds/trade.mp3',
            'DIG UP':  './sounds/digup.mp3',
            'DISCARD': './sounds/discard.mp3',
            // å½¹è·ç™ºå‹•éŸ³
            'SKILL': './sounds/skill_default.mp3',
            'SKILL_ANGLER': "./sounds/skill_angler.mp3",
            'SKILL_FORTUNE TELLER': "./sounds/skill_fortuneteller.mp3",
            'SKILL_THIEF': "./sounds/skill_thief.mp3",
            'SKILL_HUNTER': "./sounds/skill_hunter.mp3",
            'SKILL_GAMBLER': "./sounds/skill_gambler.mp3",
            'SKILL_MAGICIAN': "./sounds/skill_magician.mp3",
            'SKILL_MILLIONAIRE': "./sounds/skill_millionaire.mp3",
            'SKILL_EMPEROR': "./sounds/skill_emperor.mp3",
            'SKILL_NEW GRAD': "./sounds/skill_newgrad.mp3",
            'SKILL_HACKER': "./sounds/skill_hacker.mp3",
            'SKILL_POLICE OFFICER': "./sounds/skill_policeofficer.mp3",
            'SKILL_ALCHEMIST': "./sounds/skill_alchemist.mp3",
            'SKILL_NECROMANCER': "./sounds/skill_necromancer.mp3",
        };
        
        /* ===============================================
           iPhoneå¯¾å¿œç‰ˆ éŸ³å£°ã‚·ã‚¹ãƒ†ãƒ  (Web Audio API)
           =============================================== */
        
        // 1. ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ ã®æœ¬ä½“
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // 2. èª­ã¿è¾¼ã‚“ã éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’è²¯ã‚ã¦ãŠãå ´æ‰€
        const audioBuffers = {};

        // 3. BGMç®¡ç†ç”¨
        let bgmSource = null;
        let bgmGainNode = null;
        let isBgmMuted = false;
        let currentBgmType = null;

        // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹é–¢æ•°
        async function loadSound(key) {
            // ã™ã§ã«èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
            if (audioBuffers[key]) return audioBuffers[key];

            const url = SOUND_FILES[key];
            if (!url) return null;

            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const decodedBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                audioBuffers[key] = decodedBuffer;
                return decodedBuffer;
            } catch (e) {
                console.warn(`éŸ³å£°èª­ã¿è¾¼ã¿å¤±æ•—: ${key}`, e);
                return null;
            }
        }

        /* --- ä¿®æ­£: å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®éŸ³ã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹ --- */
        // SOUND_FILES ã«ã‚ã‚‹ã‚­ãƒ¼ã‚’ã™ã¹ã¦å–å¾—ã—ã¦ã€é †ç•ªã«èª­ã¿è¾¼ã¿ã‚’é–‹å§‹ã™ã‚‹
        Object.keys(SOUND_FILES).forEach(key => {
            loadSound(key);
        });

        /* --- å†ç”Ÿé–¢æ•° (åŠ¹æœéŸ³ç”¨) --- */
        async function playSoundEffect(type) {
            // 1. ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒç„¡åŠ¹ãªã‚‰å†é–‹ã‚’è©¦ã¿ã‚‹
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // 2. ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— (ãªã‘ã‚Œã°ä»Šãƒ­ãƒ¼ãƒ‰ã™ã‚‹)
            let buffer = audioBuffers[type];
            if (!buffer) {
                buffer = await loadSound(type);
                if (!buffer) return;
            }

            // 3. éŸ³æºä½œæˆ
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;

            // 4. éŸ³é‡èª¿æ•´ (iPhoneã§ã‚‚åŠ¹ãã¾ã™)
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.6; // åŠ¹æœéŸ³ã®éŸ³é‡ (0.0ã€œ1.0)

            // 5. æ¥ç¶š: Source -> Gain -> Speaker
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // 6. å†ç”Ÿ
            source.start(0);
        }

        /* --- BGMå†ç”Ÿé–¢æ•° (éŸ³é‡èª¿æ•´å¯¾å¿œ) --- */
        async function playBgm(type) {
            // åŒã˜æ›²ãªã‚‰ä½•ã‚‚ã—ãªã„
            if (currentBgmType === type && bgmSource) return;

            // å‰ã®æ›²ã‚’æ­¢ã‚ã‚‹
            stopBgm();

            if (isBgmMuted) {
                currentBgmType = type; // ã‚¿ã‚¤ãƒ—ã ã‘è¦šãˆã¦ãŠãï¼ˆãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤æ™‚ã«å†ç”Ÿã™ã‚‹ãŸã‚ï¼‰
                return; 
            }

            // ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
            let buffer = audioBuffers[type];
            if (!buffer) {
                buffer = await loadSound(type);
                if (!buffer) return;
            }

            // BGMç”¨ã‚½ãƒ¼ã‚¹ä½œæˆ
            bgmSource = audioCtx.createBufferSource();
            bgmSource.buffer = buffer;
            bgmSource.loop = true;

            // BGMç”¨éŸ³é‡ãƒãƒ¼ãƒ‰
            bgmGainNode = audioCtx.createGain();
            // â˜…ã“ã“ãŒé‡è¦: iPhoneç”¨ã«BGMã‚’ã‹ãªã‚Šå°ã•ãè¨­å®š (0.05ãã‚‰ã„ãŒä¸åº¦ã„ã„ã“ã¨ãŒå¤šã„)
            bgmGainNode.gain.value = 0.05; 

            // æ¥ç¶š
            bgmSource.connect(bgmGainNode);
            bgmGainNode.connect(audioCtx.destination);

            // å†ç”Ÿ
            bgmSource.start(0);
            currentBgmType = type;
        }

        function stopBgm() {
            if (bgmSource) {
                try { bgmSource.stop(); } catch(e){}
                bgmSource = null;
            }
            bgmGainNode = null;
            currentBgmType = null;
        }

        function toggleBgmMute() {
            isBgmMuted = !isBgmMuted;
            const btn = document.getElementById('btn-bgm-toggle');
            
            if (isBgmMuted) {
                btn.innerText = "ğŸ”‡";
                stopBgm(); // åœæ­¢
                // ã‚¿ã‚¤ãƒ—ã¯ä¿æŒã—ã¦ãŠã‹ãªã„ã¨å†é–‹ã§ããªã„ã®ã§ã€stopBgmã§æ¶ˆãˆãŸåˆ†ã‚’æˆ»ã™å·¥å¤«ãŒå¿…è¦ã§ã™ãŒã€
                // ç°¡æ˜“çš„ã«ã€Œä»Šã®çŠ¶æ…‹(gameState)ã€ã‚’è¦‹ã¦å†åˆ¤å®šã™ã‚‹ã®ãŒç¢ºå®Ÿã§ã™ã€‚
            } else {
                btn.innerText = "ğŸ”Š";
                // å†é–‹å‡¦ç†
                if (gameState && gameState.status === 'playing') playBgm('BGM_BATTLE');
                else playBgm('BGM_LOBBY');
            }
        }

        /* --- iPhoneç”¨ã®ãƒ­ãƒƒã‚¯è§£é™¤ (ã‚µã‚¤ãƒ¬ãƒ³ãƒˆç‰ˆ) --- */
        function unlockAudioContext() {
            // 1. ã‚·ã‚¹ãƒ†ãƒ ãŒåœæ­¢ä¸­ãªã‚‰å†é–‹
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            // 2. ã€Œç„¡éŸ³ã€ã®ãƒãƒƒãƒ•ã‚¡ã‚’ä¸€ç¬å†ç”Ÿã—ã¦ã€å†ç”Ÿæ¨©é™ã‚’ç²å¾—ã™ã‚‹
            // (å®Ÿéš›ã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä½¿ã„ã¾ã›ã‚“)
            const emptyBuffer = audioCtx.createBuffer(1, 1, 22050);
            const source = audioCtx.createBufferSource();
            source.buffer = emptyBuffer;
            source.connect(audioCtx.destination);
            source.start(0);

        }
                
        const firebaseConfig = {
            apiKey: "AIzaSyBvdLTIWWv_7UCucT_i0Xiy7CgbGoBWUyo",
            authDomain: "seki-online.firebaseapp.com",
            projectId: "seki-online",
            storageBucket: "seki-online.firebasestorage.app",
            messagingSenderId: "196888255072",
            appId: "1:196888255072:web:0aad0ac1ec1d82485d8105",
            measurementId: "G-NV0Q9LB87B"
        };
        
        let db;
        try {
            if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
            db = firebase.database();
        } catch(e) { alert("Firebaseèª­è¾¼ã‚¨ãƒ©ãƒ¼: " + e.message); }

        const NUMBERS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        const SYMBOLS = ["REVERSE", "TRADE", "DIG UP", "DISCARD"];
        const SYMBOL_COUNTS = {"REVERSE":4, "TRADE":4, "DIG UP":4, "DISCARD":1};
        // ã€ä¿®æ­£ã€‘Ver 2.0æº–æ‹ ã®å½¹è·å®šç¾©
        const ROLES = [
            "ALCHEMIST", "ANGLER", "EMPEROR", "FORTUNE TELLER", 
            "GAMBLER", "HACKER", "HUNTER", "MAGICIAN", 
            "MILLIONAIRE", "NEW GRAD", "POLICE OFFICER", "THIEF", "NECROMANCER"
        ];

        // ã€è¿½åŠ ã€‘å½¹è·ã®æ—¥æœ¬èªåã¨ç°¡æ˜“èª¬æ˜ï¼ˆè¡¨ç¤ºç”¨ï¼‰
        const ROLE_INFO = {
            "ALCHEMIST":      { jp: "éŒ¬é‡‘è¡“å¸«", desc: "æ•°å­—ã‚’åˆæˆã—ã¦æ¨ã¦ã‚‹" },
            "ANGLER":         { jp: "é‡£ã‚Šäºº",   desc: "æ‰‹æœ­ã‚’1æšé™¤å¤–ã—ã¦å¢“åœ°å›å" },
            "EMPEROR":        { jp: "çš‡å¸",     desc: "å…¨å“¡ã®æ‰‹æœ­ã‚’é›†ã‚ã¦å†åˆ†é…" },
            "FORTUNE TELLER": { jp: "å ã„å¸«",   desc: "å…¨å“¡ã®æ‰‹æœ­ã¨å½¹è·ã‚’è¦‹ã‚‹" },
            "GAMBLER":        { jp: "è³­åšå¸«",   desc: "å±±æœ­ã®æ•°å­—ã‚’äºˆæƒ³ã—ã¦å½“ãŸã‚‹ã¨â€¦â€¦" },
            "HACKER":         { jp: "ãƒãƒƒã‚«ãƒ¼", desc: "ç›¸æ‰‹ã®æ‰‹æœ­1æšã‚’ãƒ­ãƒƒã‚¯ã™ã‚‹" },
            "HUNTER":         { jp: "ç‹©äºº",     desc: "æ‰‹æœ­ã®è¨˜å·ã‚’å±±æœ­ã¨äº¤æ›" },
            "MAGICIAN":       { jp: "æ‰‹å“å¸«",   desc: "è¨˜å·ã‚«ãƒ¼ãƒ‰ã®åŠ¹æœã‚’ä½¿ãˆã‚‹" },
            "MILLIONAIRE":    { jp: "å¯Œè±ª",     desc: "æ•°å­—æ‰‹æœ­ã‚’é™¤å¤–ã—ã¦è¨˜å·ã‚’è³¼å…¥" },
            "NEW GRAD":       { jp: "æ–°å’",     desc: "ä»–äººã®å½¹è·ã‚’ã‚³ãƒ”ãƒ¼" },
            "POLICE OFFICER": { jp: "è­¦å¯Ÿå®˜",   desc: "ç›¸æ‰‹ã®æ‰‹æœ­ã‚’1æšå…¬é–‹ã•ã›ã‚‹" },
            "THIEF":          { jp: "ç›—è³Š",     desc: "ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚’2å›ã¾ã§è¡Œãˆã‚‹" },
            "NECEOMANCER":    { jp: "ãƒã‚¯ãƒ­ãƒãƒ³ã‚µãƒ¼",     desc: "æ•°å­—å¢“åœ°ã®ä¸€ç•ªä¸Šã®ã‚«ãƒ¼ãƒ‰ã‚’é™¤å¤–ã™ã‚‹" }
        };

        let myId = localStorage.getItem("seki_uid_v2");
        if (!myId) {
            myId = Date.now().toString() + "_" + Math.random().toString(36).substr(2, 5);
            localStorage.setItem("seki_uid_v2", myId);
        }
        
        let prevHandCounts = {}; // æ‰‹æœ­æšæ•°ã®è¨˜éŒ²ç”¨ï¼ˆSEå†ç”Ÿã«ä½¿ç”¨ï¼‰
        const audioCache = {};
        // â˜…è¿½åŠ : ãƒ›ã‚¹ãƒˆè¨­å®šã®å‰å›å€¤ã‚’è¦šãˆã¦ãŠãå¤‰æ•°
        let lastHostHandMode = 6;

        let currentRoom = null;
        let myName = "";
        let selectedIdx = -1;
        let gameState = null;
        let drawnCardTemp = null;
        let wasMyTurn = false;
        let hasFinished = false;
        let joined = false;
        let lastReadLogTime = 0; // ãƒãƒ£ãƒƒãƒˆæ—¢èª­ç”¨
        let prevActivatedList = {}; // å‰å›ã®ç™ºå‹•çŠ¶æ³ã‚’è¨˜éŒ²ã™ã‚‹
        let prevRevealedRoles = {}; // ã‚«ãƒŸãƒ³ã‚°ã‚¢ã‚¦ãƒˆçŠ¶æ³ã‚’è¨˜éŒ²ã™ã‚‹
    
        let prevSoundId = 0;
        let lastGraveNumCount = -1; // å‰å›ã®æ•°å­—å¢“åœ°ã®æšæ•°
        let lastGraveSymCount = -1; // å‰å›ã®è¨˜å·å¢“åœ°ã®æšæ•°
        // â˜…è¿½åŠ : ãƒãƒƒã‚«ãƒ¼è§£é™¤åˆ¶å¾¡ç”¨ã®å¤‰æ•°
        let lastCleanupTurnIdx = -1;
        let myRankPlayed = false; // â˜…è¿½åŠ : é †ä½æ±ºå®šéŸ³ãŒå†ç”Ÿæ¸ˆã¿ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
        

        const els = {
            login: document.getElementById("login-screen"),
            game: document.getElementById("game-screen"),
            roomName: document.getElementById("roomName"),
            playerName: document.getElementById("playerName"),
            hand: document.getElementById("my-hand"),
            indicator: document.getElementById("indicator"),
            graveNum: document.getElementById("graveNum"),
            graveSym: document.getElementById("graveSym"),
            others: document.getElementById("other-players"),
            msg: document.getElementById("msg"),
            hostCtrl: document.getElementById("host-controls"),
            log: document.getElementById("game-log-bar"),
            modal: document.getElementById("modal-overlay"),
            mTitle: document.getElementById("modal-title"),
            mContent: document.getElementById("modal-content"),
            deckNum: document.getElementById("deckNumCount"),
            deckSym: document.getElementById("deckSymCount"),
            mFooter: document.getElementById("modal-footer"),
            btnJoin: document.getElementById("btn-join"),
            btnChat: document.getElementById("btn-chat-icon")
        };

        // --- ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢æ•° ---
        function openModal(title, html) {
            els.mTitle.innerText = title;
            els.mContent.innerHTML = html;
            els.mFooter.innerHTML = '<button onclick="closeModal()" class="modal-btn">é–‰ã˜ã‚‹</button>';
            els.modal.classList.remove("hidden");
        }
        function showInfoModal(title, msg) {
            els.mTitle.innerText = title;
            els.mContent.innerHTML = `<p>${msg}</p>`;
            els.mFooter.innerHTML = '<button onclick="closeModal()" class="modal-btn primary">OK</button>';
            els.modal.classList.remove("hidden");
        }
        function showConfirmModal(title, msg, yesCallbackStr) {
            els.mTitle.innerText = title;
            els.mContent.innerHTML = `<p>${msg}</p>`;
            els.mFooter.innerHTML = `
                <button onclick="${yesCallbackStr}; closeModal()" class="modal-btn primary">ã¯ã„</button>
                <button onclick="closeModal()" class="modal-btn">ã„ã„ãˆ</button>
            `;
            els.modal.classList.remove("hidden");
        }
        function closeModal() { els.modal.classList.add("hidden"); }

        function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); }
        function sortCards(hand) {
            if(!hand) return [];
            hand.sort((a,b) => {
                if(a.type !== b.type) return a.type === 'num' ? -1 : 1;
                if(a.type === 'num') return a.val - b.val;
                const sOrder = ["REVERSE", "TRADE", "DIG UP", "DISCARD"];
                return sOrder.indexOf(a.val) - sOrder.indexOf(b.val);
            });
            return hand;
        }

        // --- ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ  & è‰²ç”Ÿæˆ ---
        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 70%, 40%)`;
        }

        async function pushLog(text, type='public', targetId=null) {
            if(!currentRoom) return;
            const logEntry = { text: text, type: type, targetId: targetId, timestamp: Date.now() };
            let logs = (gameState && gameState.logs) ? [...gameState.logs] : [];
            logs.push(logEntry);
            if(logs.length > 50) logs.shift(); 
            await db.ref(`rooms/${currentRoom}/logs`).set(logs);
        }

        function renderLogs(logs) {
            if(!logs || logs.length === 0) { els.log.innerText = "ãƒ­ã‚°ãªã—"; return; }
            let lastLog = logs[logs.length-1];
            
            // æœ€æ–°ãƒ­ã‚°è¡¨ç¤º
            let display = "";
            for(let i=logs.length-1; i>=0; i--) {
                let l = logs[i];
                if(l.type === 'public' || l.targetId === myId || l.type === 'chat') {
                    let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit'});
                    display = `${time} ${l.text}`;
                    break;
                }
            }
            els.log.innerText = display + " (ã‚¿ãƒƒãƒ—ã§å±¥æ­´ï¼†ãƒãƒ£ãƒƒãƒˆ)";

            // â˜…ãƒãƒ£ãƒƒãƒˆé€šçŸ¥
            if (lastLog.type === 'chat' && lastLog.targetId !== myId) {
                const match = lastLog.text.match(/^\[(.*?)\]/);
                const senderName = match ? match[1] : "";
                
                if (senderName !== myName && lastLog.timestamp > lastReadLogTime) {
                    // els.btnChat.classList.add("notify-active");
                    els.log.classList.add("notify-bar");
                    if (Date.now() - lastLog.timestamp < 2000) { // 2ç§’ä»¥å†…ã®æ–°ç€ãªã‚‰é³´ã‚‰ã™
                         playSoundEffect('chat');
                    }
                }
            }
        }

        function showLogHistory() {
            if(!gameState) return;
            let logs = gameState.logs || [];
            
            // â˜…æ—¢èª­å‡¦ç†
            lastReadLogTime = Date.now();
            // els.btnChat.classList.remove("notify-active");
            els.log.classList.remove("notify-bar");

            let html = `
                <div id="chat-input-container">
                    <input type="text" id="chat-input" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...">
                    <button id="chat-send-btn" onclick="sendChat()">é€ä¿¡</button>
                </div>
                <div id="log-list-container">
            `;
            
            [...logs].reverse().forEach(l => {
                if(l.type === 'private' && l.targetId !== myId) return;
                let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit', second:'2-digit'});
                let styleClass = '';
                let content = l.text;

                if(l.type === 'private') {
                    styleClass = 'log-private';
                } else if(l.type === 'chat') {
                    styleClass = 'log-chat';
                    const match = content.match(/^\[(.*?)\] (.*)$/);
                    if (match) {
                        const name = match[1];
                        const msg = match[2];
                        const color = stringToColor(name);
                        content = `<span style="color:${color}; font-weight:bold;">[${name}]</span> ${msg}`;
                    }
                }
                html += `<div class="log-entry ${styleClass}"><span class="log-time">${time}</span><span class="log-text">${content}</span></div>`;
            });
            html += `</div>`;
            openModal("ãƒãƒ£ãƒƒãƒˆ & ãƒ­ã‚°", html);
        }

        async function sendChat() {
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if(!msg) return;
            await pushLog(`[${myName}] ${msg}`, 'chat');
            input.value = "";
            lastReadLogTime = Date.now();
            showLogHistory(); 
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å…¥å®¤é †ï¼ˆjoinedAtãŒæ—©ã„é †ï¼‰ã«ä¸¦ã¹ã‚‹é–¢æ•°
        function getSortedPlayerIds(players) {
            return Object.keys(players).sort((a, b) => {
                const tA = players[a].joinedAt || 0;
                const tB = players[b].joinedAt || 0;
                // æ™‚é–“ãŒåŒã˜ãªã‚‰IDé †ã€ã‚ã‚Œã°æ™‚é–“é †
                if (tA === tB) return a.localeCompare(b);
                return tA - tB;
            });
        }

        async function joinGame() {
            unlockAudioContext();
            if(currentRoom) return; 
            els.btnJoin.disabled = true; 
            
            lastReadLogTime = Date.now();

            try {
                const room = els.roomName.value.trim();
                const name = els.playerName.value.trim();
                if (!room || !name) {
                    els.btnJoin.disabled = false;
                    return showInfoModal("å…¥åŠ›ã‚¨ãƒ©ãƒ¼", "éƒ¨å±‹åã¨åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
                }

                // â–¼â–¼â–¼â–¼â–¼ ã“ã“ã‹ã‚‰è¿½åŠ ãƒ»ä¿®æ­£ â–¼â–¼â–¼â–¼â–¼
                
                // 1. ã¾ãšéƒ¨å±‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ç¢ºèªã™ã‚‹
                const checkRef = db.ref(`rooms/${room}`);
                const snapshot = await checkRef.get();

                if (snapshot.exists()) {
                    const data = snapshot.val();
                    const players = data.players || {};
                    const playerCount = Object.keys(players).length;
                    
                    // ã€Œè‡ªåˆ†ãŒã¾ã ãƒªã‚¹ãƒˆã«ã„ãªã„ã€ã‹ã¤ã€Œæ—¢ã«5äººä»¥ä¸Šã„ã‚‹ã€ãªã‚‰ã‚¨ãƒ©ãƒ¼
                    // (ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦æˆ»ã£ã¦ããŸäººã¯å…¥ã‚Œã‚‹ã‚ˆã†ã« !players[myId] ã§åˆ¤å®šã—ã¾ã™)
                    if (!players[myId] && playerCount >= 5) {
                        els.btnJoin.disabled = false;
                        return showInfoModal("æº€å“¡", "ã“ã®éƒ¨å±‹ã¯å®šå“¡(5å)ã«é”ã—ã¦ã„ã¾ã™ã€‚<br>åˆ¥ã®éƒ¨å±‹åã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚");
                    }
                }
                

                myName = name;
                currentRoom = room;

                const updates = {};
                updates[`rooms/${room}/players/${myId}/name`] = name;
                updates[`rooms/${room}/players/${myId}/online`] = true;
                //â˜…å¤‰æ›´ï¼šã‚µãƒ¼ãƒãƒ¼ã®æ­£ç¢ºãªæ™‚é–“ã‚’ä½¿ã£ã¦ã€Œå…¥å®¤æ™‚åˆ»ã€ã‚’è¨˜éŒ²ã™ã‚‹
                updates[`rooms/${room}/players/${myId}/joinedAt`] = firebase.database.ServerValue.TIMESTAMP;


                await db.ref().update(updates);
                joined = true;

                setupEffectListener();
                playBgm('BGM_LOBBY');

                const roomRef = db.ref(`rooms/${room}`);
                roomRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        gameState = data;
                        render(data);
                    } else {
                        if (joined && gameState && gameState.playerOrder) {
                            showInfoModal("çµ‚äº†", "éƒ¨å±‹ãŒè§£æ•£ï¼ˆå‰Šé™¤ï¼‰ã•ã‚Œã¾ã—ãŸã€‚");
                            setTimeout(() => location.reload(), 2000);
                        } else {
                            gameState = { players: { [myId]: { name, online: true } }, logs: [] };
                            render(gameState);
                        }
                    }
                });



                els.login.classList.add("hidden");
                els.game.classList.remove("hidden");
                document.getElementById("room-display").innerText = `éƒ¨å±‹: ${room}`;
            } catch(e) { 
                showInfoModal("é€šä¿¡ã‚¨ãƒ©ãƒ¼", e.message); 
                els.btnJoin.disabled = false;
            }
        }

        function confirmCloseRoom() {
            showConfirmModal("è§£æ•£ç¢ºèª", "æœ¬å½“ã«éƒ¨å±‹ã‚’è§£æ•£ã—ã¾ã™ã‹ï¼Ÿ", "execCloseRoom()");
        }
        async function execCloseRoom() {
            try { await db.ref(`rooms/${currentRoom}`).remove(); location.reload(); } 
            catch(e) { showInfoModal("ã‚¨ãƒ©ãƒ¼", "å‰Šé™¤å¤±æ•—: " + e.message); }
        }

        /* --- ä¿®æ­£ç‰ˆ confirmInitGame --- */
        function confirmInitGame() {
            // showConfirmModalã‚’ä½¿ã†ã¨ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸç¬é–“ã«å¼·åˆ¶çš„ã«é–‰ã˜ã¦ã—ã¾ã„ã€
            // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¾ã§æ¶ˆã—ã¦ã—ã¾ã†ã®ã§ã€æ‰‹å‹•ã§ãƒœã‚¿ãƒ³ã‚’ä½œã‚Šã¾ã™ã€‚
            
            els.mTitle.innerText = "é–‹å§‹ç¢ºèª";
            els.mContent.innerHTML = "<p>ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ï¼ˆãƒªã‚»ãƒƒãƒˆï¼‰ã—ã¾ã™ã‹ï¼Ÿ</p>";
            els.mFooter.innerHTML = `
                <button onclick="closeModal(); execInitGame()" class="modal-btn primary">ã¯ã„</button>
                <button onclick="closeModal()" class="modal-btn">ã„ã„ãˆ</button>
            `;
            els.modal.classList.remove("hidden");
        }
        async function execInitGame(fixedNumCount) {
            try {
                const players = gameState.players || {};

                // 1. å…¥å®¤é †ãƒªã‚¹ãƒˆå–å¾—
                let playerIds = getSortedPlayerIds(players);

                // 2. æœ€ä¸‹ä½ã‚’å…ˆé ­ã¸
                if (gameState.rankings) {
                    let loserId = Object.keys(gameState.rankings).reduce((a, b) => 
                        gameState.rankings[a] > gameState.rankings[b] ? a : b
                    , null);

                    if (loserId && playerIds.includes(loserId)) {
                        playerIds = playerIds.filter(pid => pid !== loserId);
                        playerIds.unshift(loserId);
                    }
                }

                if(playerIds.length < 2) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "æœ€ä½2äººã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¿…è¦ã§ã™ï¼");

                // â˜…ä¿®æ­£: å¼•æ•°ã§æšæ•°ã‚’å—ã‘å–ã‚‹ï¼ˆãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ6ï¼‰
                // (ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®è¦ç´ ã‚’æ¢ã™å‡¦ç†ã¯å‰Šé™¤ã—ã¾ã—ãŸ)
                let numCount = fixedNumCount || 6;

                let deckNum = [];
                NUMBERS.forEach(n => { for(let i=0; i<4; i++) deckNum.push({type:'num', val:n}); });
                let deckSym = [];
                SYMBOLS.forEach(s => { for(let i=0; i<SYMBOL_COUNTS[s]; i++) deckSym.push({type:'sym', val:s}); });
                
                shuffle(deckNum);
                shuffle(deckSym);

                /* --- execInitGameé–¢æ•°å†… --- */
                
                let hands = {};
                let roles = {};
                
                // å½¹è·ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆé‡è¤‡ãªã—ã§é…ã‚‹ãŸã‚ï¼‰
                let availRoles = [...ROLES];
                shuffle(availRoles);
                
      
                playerIds.forEach((pid, i) => {
                    let h = [];
                    // â˜…æšæ•°é¸æŠåæ˜ 
                    for(let k=0; k<numCount; k++) h.push(deckNum.pop());
                    for(let k=0; k<2; k++) h.push(deckSym.pop());
                    h = sortCards(h);
                    hands[pid] = h;
                    roles[pid] = availRoles.pop();
                });

                // â˜…è¿½åŠ : çš‡å¸ã¨æ–°å’ã®ã‚«ãƒŸãƒ³ã‚°ã‚¢ã‚¦ãƒˆåˆ¤å®š
                let revealedRoles = {};
                let coLogs = [];
                
                playerIds.forEach(pid => {
                    const r = roles[pid];
                    if (r === "EMPEROR" || r === "NEW GRAD") {
                        revealedRoles[pid] = true; // æœ€åˆã‹ã‚‰å…¬é–‹çŠ¶æ…‹ã«ã™ã‚‹
                        let rNameJP = (ROLE_INFO[r]) ? ROLE_INFO[r].jp : r;
                        coLogs.push({
                            text: `${players[pid].name} ã¯ [${rNameJP}] ã§ã‚ã‚‹ã“ã¨ã‚’ã‚«ãƒŸãƒ³ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸï¼`,
                            type: 'public',
                            timestamp: Date.now()
                        });
                        
                        // çš‡å¸ãªã‚‰ã‚«ãƒƒãƒˆã‚¤ãƒ³æ¼”å‡ºã‚‚äºˆç´„ï¼ˆinitDataã®ãƒ­ã‚°ã«å…¥ã‚Œã¦ãŠãï¼‰
                        if (r === "EMPEROR") {
                             // ã“ã“ã§ç›´æ¥ã‚«ãƒƒãƒˆã‚¤ãƒ³ã¯å‡ºã›ãªã„ã®ã§ã€ãƒ­ã‚°ã‚’è¦‹ã¦æ¤œçŸ¥ã•ã›ã‚‹ã‹ã€
                             // ã‚·ãƒ³ãƒ—ãƒ«ã«ãƒ­ã‚°é€šçŸ¥ã ã‘ã§æ¸ˆã¾ã›ã‚‹ã®ãŒå®‰å…¨ã§ã™ã€‚
                        }
                    }
                });
                
                // â–²â–²â–² ã“ã“ã¾ã§æŒ¿å…¥ â–²â–²â–²

                const initData = {
                    status: "playing",
                    deckNum,
                    deckSym,
                    graveNum: [],
                    graveSym: [],
                    exclusion: [],
                    isReverse: false,
                    turnIdx: 0,
                    playerOrder: playerIds,
                    passCount: 0,
                    hands, roles, players, rankings: {}, 
                    // ã€è¿½åŠ ã€‘èƒ½åŠ›ä½¿ç”¨æ¸ˆã¿ãƒ•ãƒ©ã‚°ï¼ˆåˆæœŸå€¤ã¯ç©ºï¼‰
                    activatedList: {},
                    revealedRoles: revealedRoles,

                    // â˜…è¿½åŠ : ãƒãƒƒã‚­ãƒ³ã‚°ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã®éš”é›¢æ‰€
                    hackedHands: null,

                    // ãƒ­ã‚°ã«ã‚«ãƒŸãƒ³ã‚°ã‚¢ã‚¦ãƒˆæƒ…å ±ã‚’è¿½åŠ 
                    logs: [
                        {text: `ã‚²ãƒ¼ãƒ é–‹å§‹ï¼(æ•°å­—${numCount}æšãƒ¢ãƒ¼ãƒ‰)`, type: "public", timestamp: Date.now()},
                        ...coLogs 
                    ]
                };

                wasMyTurn = false;
                hasFinished = false;
                await db.ref(`rooms/${currentRoom}`).update(initData);
            } catch(e) { showInfoModal("ã‚¨ãƒ©ãƒ¼", "é–‹å§‹ã‚¨ãƒ©ãƒ¼: " + e.message); }
        }

       function render(data) {
            // 1. è¦ç´ ã®å–å¾—
            let turnIndicator = document.getElementById("turn-indicator");
            let graveContainer = document.getElementById("grave-container");
            let handContainer = document.getElementById("my-hand");
            let hackedContainer = document.getElementById("hacked-area");
            
            // 2. ã‚¯ãƒªã‚¢
            if(handContainer) handContainer.innerHTML = "";
            if(hackedContainer) hackedContainer.innerHTML = "";

            // 3. ãƒ‡ãƒ¼ã‚¿æº–å‚™
            const players = data.players || {};
            const hands = data.hands || {};
            const roles = data.roles || {};
            const hackedHands = data.hackedHands || {};
            const currentAct = data.activatedList || {};
            const currentRev = data.revealedRoles || {};

            // â˜…è¿½åŠ : å®Ÿè³ªçš„ãªãƒ›ã‚¹ãƒˆï¼ˆæ¨©é™è€…ï¼‰ã‚’æ±ºå®šã™ã‚‹
            // é€šå¸¸ã¯å…ˆé ­ã®äººã ãŒã€ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã¯ã€Œæœ€ä¸‹ä½ã®äººã€ã«æ¨©é™ã‚’ç§»ã™
            let pIdsForHost = getSortedPlayerIds(players);
            if (data.playerOrder) pIdsForHost = data.playerOrder;
            
            let effectiveHostId = (pIdsForHost.length > 0) ? pIdsForHost[0] : null;

            if (data.status === "finished" && data.rankings) {
                let loserId = Object.keys(data.rankings).reduce((a, b) => 
                    data.rankings[a] > data.rankings[b] ? a : b
                , null);
                
                if (loserId && players[loserId]) {
                    effectiveHostId = loserId;
                }
            }

            // â†“â†“â†“ ä¿®æ­£: "å±±æœ­: xxæš" ã¨ã„ã†æ–‡å­—ã‚’æ¶ˆã—ã€æ•°å­—ã ã‘å…¥ã‚Œã‚‹ â†“â†“â†“
            if (data.deckNum && els.deckNum) els.deckNum.innerText = data.deckNum.length;
            if (data.deckSym && els.deckSym) els.deckSym.innerText = data.deckSym.length;
            
            // -----------------------------------------------------
            // A. ã‚²ãƒ¼ãƒ é€²è¡Œä¸­ã®æç”»
            // -----------------------------------------------------
            if (data.status === "playing" || data.status === "finished") {
                
                // --- 1. æ‰‹æœ­ã®æç”» (çµ±åˆç‰ˆãƒ»å®‰å…¨å¯¾ç­–æ¸ˆã¿) ---
                if (handContainer) {
                    handContainer.innerHTML = ""; // ã‚¯ãƒªã‚¢

                    let rawHand = hands[myId];
                    let myHand = rawHand ? sortCards(deepCopy(rawHand)) : [];
                    let myLockedHand = hackedHands[myId] || [];
                    
                    const fragment = document.createDocumentFragment();

                    // ã€å¯¾ç­–Aã€‘ ã€Œé€šå¸¸ã®æ‰‹æœ­ã€
                    myHand.forEach((c, i) => {
                        let div = document.createElement("div");
                        let cssClass = `card ${c.type}`;
                        if (c.isOpen) cssClass += " revealed";

                        div.className = cssClass;
                        if(c.val === 0) div.setAttribute("data-val", "0");
                        if(i === selectedIdx) div.classList.add("selected");
                        
                        let valNode = document.createTextNode(c.val);
                        div.appendChild(valNode);
                        
                        let imgUrl = CARD_IMAGES[c.val];
                        if (imgUrl) {
                            div.style.backgroundImage = `url('${imgUrl}')`;
                            div.classList.add('has-img');
                        }

                        if (data.status === "playing" && !data.rankings?.[myId]) {
                            div.onclick = () => {
                                selectedIdx = (selectedIdx === i) ? -1 : i;
                                render(data);
                            };
                        }
                        fragment.appendChild(div);
                    });

                    // ã€å¯¾ç­–Bã€‘ ã€Œéš”é›¢ã‚«ãƒ¼ãƒ‰ã€
                    myLockedHand.forEach(c => {
                        let div = document.createElement("div");
                        div.className = `card ${c.type} locked`; 
                        
                        let imgUrl = CARD_IMAGES[c.val];
                        if (imgUrl) {
                            div.style.backgroundImage = `url('${imgUrl}')`;
                            div.classList.add('has-img');
                        }
                        
                        let valNode = document.createTextNode(c.val);
                        div.appendChild(valNode);
                        if(c.val === 0) div.setAttribute("data-val", "0");

                        div.onclick = () => showInfoModal("ãƒ­ãƒƒã‚¯ä¸­", "ã“ã®ã‚«ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½åœæ­¢ã—ã¦ã„ã¾ã™ã€‚");
                        fragment.appendChild(div);
                    });

                    handContainer.appendChild(fragment);
                }

                // --- 3. å½¹è·ãƒ‘ãƒãƒ«ã®æç”» ---
                const myRole = roles[myId];
                const rInfo = (typeof ROLE_INFO !== 'undefined') ? ROLE_INFO[myRole] : null;
                
                let roleArea = document.getElementById("my-role-panel");
                if(!roleArea && document.getElementById("my-area")) {
                    roleArea = document.createElement("div");
                    roleArea.id = "my-role-panel";
                    let controls = document.getElementById("controls");
                    if(controls) document.getElementById("my-area").insertBefore(roleArea, controls);
                }

                if (roleArea && myRole && rInfo) {
                    let actBtnHtml = "";
                    let isActivated = currentAct[myId];
                    
                    if (isMyTurn() && !isActivated && data.status === "playing") {
                        let funcName = "";
                        // å„å½¹è·ã®ç™ºå‹•é–¢æ•°ãƒãƒƒãƒ”ãƒ³ã‚°
                        if (myRole === "ANGLER") funcName = "activateAngler()";
                        else if (myRole === "FORTUNE TELLER") funcName = "activateFortuneTeller()";
                        else if (myRole === "THIEF") funcName = "activateThief(1)";
                        else if (myRole === "HUNTER") funcName = "activateHunter()";
                        else if (myRole === "GAMBLER") funcName = "activateGambler()";
                        else if (myRole === "MAGICIAN") funcName = "activateMagician()";
                        else if (myRole === "MILLIONAIRE") funcName = "activateMillionaire()";
                        else if (myRole === "EMPEROR") funcName = "activateEmperor()";
                        else if (myRole === "POLICE OFFICER") funcName = "activatePoliceOfficer()";
                        else if (myRole === "HACKER") funcName = "activateHacker()";
                        else if (myRole === "ALCHEMIST") funcName = "activateAlchemist()";
                        else if (myRole === "NEW GRAD") funcName = "activateNewGrad()";
                        //else if (myRole === "NECROMANCER") funcName = "activateNecromancer()";

                        if (funcName) {
                            actBtnHtml = `<button onclick="${funcName}" style="margin-top:8px; padding:6px 12px; font-size:12px; background:#fff; color:#4a148c; border:none; border-radius:15px; font-weight:bold; cursor:pointer; box-shadow:0 2px 4px rgba(0,0,0,0.2);">ã‚¹ã‚­ãƒ«ç™ºå‹•</button>`;
                        }
                    } else if (isActivated) {
                        let statusText = "(ç™ºå‹•æ¸ˆã¿)";
                        if (myRole === "MAGICIAN" && typeof isActivated === 'string') {
                            statusText = `ä½¿ç”¨: ${isActivated}`;
                        }
                        actBtnHtml = `<div style="font-size:11px; color:#ffeb3b; margin-top:5px; font-weight:bold;">${statusText}</div>`;
                    }

                    // èƒŒæ™¯ã‚¹ã‚¿ã‚¤ãƒ«
                    let style = isActivated ? 'filter:grayscale(1); opacity:0.6;' : '';
                    const bgUrl = (typeof ROLE_IMAGES !== 'undefined') ? ROLE_IMAGES[myRole] : null;
                    let bgStyle = "";
                    
                    if (myRole === "EMPEROR") {
                        if (bgUrl) {
                            bgStyle = `background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(0,0,0,0.6)), url('${bgUrl}'); background-size: cover; background-position: center; border: 3px solid #fff; animation: goldPulse 2s infinite alternate;`;
                        } else {
                            bgStyle = `background: linear-gradient(45deg, #FFD700, #FDB931, #FFED86, #FFD700); background-size: 200% 200%; border: 3px solid #fff; animation: goldShine 3s ease infinite, goldPulse 2s infinite alternate; color: #3e2723; text-shadow: none;`;
                        }
                    } else if (bgUrl) {
                        bgStyle = `background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.8)), url('${bgUrl}'); background-size: cover; background-position: center;`;
                    } else {
                        bgStyle = `background: linear-gradient(135deg, #6a1b9a, #4a148c);`;
                    }

                    roleArea.innerHTML = `
                        <div class="role-card" style="${style} ${bgStyle}">
                            <div class="role-name">${myRole}</div>
                            <div class="role-jp">${rInfo.jp}</div>
                            <div class="role-desc">${rInfo.desc}</div>
                            ${actBtnHtml}
                        </div>
                    `;
                }

                // --- 4. æ¼”å‡ºãƒ»éŸ³ãƒ»ã‚«ãƒƒãƒˆã‚¤ãƒ³ ---
                Object.keys(currentAct).forEach(pid => {
                    if (!prevActivatedList[pid] && currentAct[pid]) {
                        const rKey = roles[pid];
                        const rNameJP = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rKey]) ? ROLE_INFO[rKey].jp : rKey;
                        const pName = players[pid].name;
                        
                        if (typeof playCutInAnimation === 'function') playCutInAnimation(rKey, rNameJP, pName);
                        
                        const sndKey = 'SKILL_' + rKey;
                        if (typeof SOUND_FILES !== 'undefined' && SOUND_FILES[sndKey]) playSoundEffect(sndKey);
                        else playSoundEffect('SKILL');
                    }
                });
                
                Object.keys(currentRev).forEach(pid => {
                    if (!prevRevealedRoles[pid] && currentRev[pid]) {
                        const rKey = roles[pid];
                        if (rKey === "EMPEROR" || rKey === "NEW GRAD") {
                            const rNameJP = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rKey]) ? ROLE_INFO[rKey].jp : rKey;
                            const pName = players[pid].name;
                            if (typeof playCutInAnimation === 'function') playCutInAnimation(rKey, rNameJP, pName);
                            const sndKey = 'SKILL_' + rKey;
                            playSoundEffect(typeof SOUND_FILES !== 'undefined' && SOUND_FILES[sndKey] ? sndKey : 'SKILL');
                        }
                    }
                });

                prevActivatedList = deepCopy(currentAct);
                prevRevealedRoles = deepCopy(currentRev);

                // --- 5. BGM & ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º ---
                // â˜…ä¿®æ­£: ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã¯ãƒ­ãƒ“ãƒ¼BGMï¼ˆã¾ãŸã¯åœæ­¢ï¼‰ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
                if (data.status === "playing") {
                    playBgm('BGM_BATTLE');
                } else {
                    playBgm('BGM_LOBBY'); 
                    // â€»ã‚‚ã—ç„¡éŸ³ãŒè‰¯ã‘ã‚Œã° stopBgm(); ã«ã—ã¦ãã ã•ã„
                }

                const areaTop = document.getElementById("area-top");
                const areaLeft = document.getElementById("area-left");
                const areaRight = document.getElementById("area-right");
                if(areaTop) areaTop.innerHTML = "";
                if(areaLeft) areaLeft.innerHTML = "";
                if(areaRight) areaRight.innerHTML = "";

                let pIds = getSortedPlayerIds(players); 
                if(data.playerOrder) pIds = data.playerOrder;
                
                // ãƒªã‚»ãƒƒãƒˆæ¨©ã®æŒã¡ä¸»
                let resetHolder = null;
                if (data.graveNum && data.graveNum.length > 0) resetHolder = data.graveNum[data.graveNum.length-1].owner;

                // è‡ªåˆ†ã‚¨ãƒªã‚¢ã®æ¼”å‡ºå‡¦ç†
                const myAreaEl = document.getElementById("my-area");
                if (myAreaEl) {
                    let myHand = hands[myId] || [];
                    let myLocked = hackedHands[myId] || [];
                    let myCount = myHand.length + myLocked.length;
                    myAreaEl.classList.remove("current-turn", "warning-1", "warning-2");
                    if (pIds[data.turnIdx] === myId) {
                        myAreaEl.classList.add("current-turn");
                    }
                }

                // é…ç½®è¨ˆç®—
                let relativeOrder = [];
                let myIndex = pIds.indexOf(myId);
                if (myIndex !== -1) {
                    for (let i = 1; i < pIds.length; i++) {
                        let idx = (myIndex + i) % pIds.length;
                        relativeOrder.push(pIds[idx]);
                    }
                } else {
                    relativeOrder = pIds; // è¦³æˆ¦ç”¨
                }

                let layoutMap = [];
                let total = relativeOrder.length; 
                if (total === 2) { 
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaRight }];
                } else if (total === 3) {
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaTop }, { pid: relativeOrder[2], area: areaRight }];
                } else if (total === 4) {
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaTop }, { pid: relativeOrder[2], area: areaTop }, { pid: relativeOrder[3], area: areaRight }];
                } else {
                    relativeOrder.forEach(pid => layoutMap.push({pid: pid, area: areaTop}));
                }

                // â– â– â–  æç”»ãƒ«ãƒ¼ãƒ— (3æ®µå›ºå®šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç‰ˆ) â– â– â– 
                layoutMap.forEach(item => {
                    let pid = item.pid;
                    let area = item.area;
                    if (!area) return;

                    let isTurn = (pIds[data.turnIdx] === pid);
                    let isRanked = (data.rankings && data.rankings[pid]);
                    let pHand = hands[pid] || [];
                    let lockedHand = hackedHands[pid] || []; 
                    let handCount = pHand.length + lockedHand.length;

                    // ã‚¯ãƒ©ã‚¹è¨­å®š
                    let boxClass = "p-box-new";
                    if (isTurn) boxClass += " current";
                    if (isRanked) boxClass += " passed";

                    // --- 1. æ‰‹æœ­æšæ•°ã®è‰²ã‚¹ã‚¿ã‚¤ãƒ« ---
                    let countStyle = ""; 
                    if (!isRanked) { 
                        if (handCount === 1) {
                            boxClass += " warning-1";
                            countStyle = "color:#ff1744; text-shadow:0 0 10px #ff1744; animation: blink-text 0.6s infinite;"; 
                        } else if (handCount === 2) {
                            boxClass += " warning-2";
                            countStyle = "color:#ffeb3b; text-shadow:0 0 10px #ffeb3b; animation: blink-text 1.2s infinite;";
                        }
                    } else {
                        // ã‚ãŒã£ãŸäººã¯æšæ•°0ã§ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ
                        countStyle = "color:#78909c;";
                    }

                    // --- 2. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º (NORMAL / RESET / RANK) ---
                    let statusHtml = `<span class="status-text status-normal">NORMAL</span>`;
                    
                    if (isRanked) {
                        // é †ä½ãŒã¤ã„ã¦ã„ã‚‹å ´åˆ
                        let rank = data.rankings[pid];
                        let suffix = ["st","nd","rd"][rank-1] || "th"; // 1st, 2nd...
                        statusHtml = `<span class="status-text status-rank">ğŸ† ${rank}${suffix}</span>`;
                    } else if (pid === resetHolder) {
                        // ãƒªã‚»ãƒƒãƒˆæ¨©ã‚’æŒã£ã¦ã„ã‚‹å ´åˆ
                        statusHtml = `<span class="status-text status-reset">ğŸ‘‘ RESET</span>`;
                    }

                    // --- 3. å½¹è·è¡¨ç¤º (??? / ROLE NAME) ---
                    let isRevealed = currentAct[pid] || isRanked || currentRev[pid];
                    let roleHtml = `<span class="role-unknown">ROLE: ???</span>`; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                    
                    if (isRevealed) {
                        let rName = roles[pid];
                        let rJp = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rName]) ? ROLE_INFO[rName].jp : rName;
                        // æ‰‹å“å¸«ã®ç‰¹æ®Šè¡¨ç¤º
                        if (rName === "MAGICIAN" && typeof currentAct[pid] === 'string') {
                            roleHtml = `<div class="role-badge-pill">æ‰‹å“å¸«: ${currentAct[pid]}</div>`;
                        } else {
                            roleHtml = `<div class="role-badge-pill">${rJp}</div>`;
                        }
                    }

                    // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³
                    let hostMark = (pid === effectiveHostId) ? "<span class='p-host-mark'>â˜…</span>" : "";
                    
                    // --- 4. å…¬é–‹ã‚«ãƒ¼ãƒ‰æƒ…å ±ã®ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ (ã“ã“ãŒå¤‰æ›´ç‚¹) ---
                    // æ‰‹æœ­ãƒ‡ãƒ¼ã‚¿(hands)ã®ä¸­ã§ isOpen ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ã‚‹ã‚‚ã®ã‚’æ¢ã™
                    let openFromHand = pHand.filter(c => c.isOpen);
                    
                    // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ¥é€”ãƒªã‚¹ãƒˆãŒé€ã‚‰ã‚Œã¦ãã‚‹å ´åˆï¼ˆå¿µã®ãŸã‚å®‰å…¨ç­–ï¼‰
                    let openFromServer = (data.revealedCards && data.revealedCards[pid]) ? data.revealedCards[pid] : [];
                    
                    // ä¸¡æ–¹ã‚’ãƒãƒ¼ã‚¸
                    let allOpenCards = [...openFromHand, ...openFromServer];
                    let revealedTextHtml = "";

                    if (allOpenCards.length > 0) {
                        // æ–‡å­—åˆ—ãƒªã‚¹ãƒˆã‚’ä½œæˆ (ä¾‹: ["1", "REV"])
                        let textList = allOpenCards.map(c => {
                            let v = c.val; 
                            // æ•°å­—(0-9)ãŒã‚ã‚Œã°ãã®ã¾ã¾è¿”ã™
                            if (v !== undefined && v !== null && !isNaN(v)) {
                                return v;
                            }
                            
                            // è¨˜å·ã‚«ãƒ¼ãƒ‰ã®ç•¥ç§°å¤‰æ›
                            let name = String(v).toUpperCase();
                            if (name.includes('REVERSE')) return 'REV';
                            if (name.includes('TRADE'))   return 'TRD';
                            if (name.includes('DIG'))     return 'DIG';
                            if (name.includes('DISCARD')) return 'DIS';
                            
                            return "?"; 
                        });
                        
                        // é‡è¤‡ã‚’é™¤å»ã—ã¦çµåˆ
                        let uniqueText = [...new Set(textList)].join(', ');
                        revealedTextHtml = `å…¬é–‹: <span class="revealed-active">${uniqueText}</span>`;
                    } else {
                        // ãªã— (ã‚°ãƒ¬ãƒ¼æ–‡å­—)
                        revealedTextHtml = `<span class="revealed-none">å…¬é–‹: NONE</span>`;
                    }
                    let pName = players[pid].name;


                    // â˜… HTMLçµ„ã¿ç«‹ã¦ â˜…
                    let html = `
                        <div class="${boxClass}">
                            <div class="p-header">${hostMark}${pName}</div>
                            
                            <div class="p-body">
                                <div class="p-hand-count" style="${countStyle}">
                                    <span class="p-hand-icon">ğŸƒÃ—</span>${handCount}
                                </div>

                                <div class="p-status-area">
                                    ${statusHtml}
                                    <div class="p-revealed-info">
                                        ${revealedTextHtml}
                                    </div>
                                </div>
                            </div>

                            <div class="p-role-row">
                                ${roleHtml}
                            </div>
                        </div>
                    `;
                    
                    let wrapper = document.createElement("div");
                    wrapper.style.display = "flex";
                    wrapper.style.flexDirection = "column";
                    wrapper.style.alignItems = "center";
                    wrapper.innerHTML = html;
                    area.appendChild(wrapper);
                });

                // --- 6. å ´ã®æƒ…å ±æ›´æ–° ---
                if (els.indicator) {
                    let targetSrc = data.isReverse ? "./images/reverse_red.jpg" : "./images/reverse_blue.jpg";
                    if (els.indicator.getAttribute('src') !== targetSrc) els.indicator.src = targetSrc;
                }
                if (els.graveNum) els.graveNum.innerHTML = renderPile(data.graveNum);
                if (els.graveSym) els.graveSym.innerHTML = renderPile(data.graveSym);
                if (document.getElementById("exclusion-count")) document.getElementById("exclusion-count").innerText = (data.exclusion || []).length;

                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                let isMyTurnNow = (pIds[data.turnIdx] === myId);
                if (data.status === "finished") {
                     els.msg.innerText = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼`;
                     document.getElementById("btn-play").disabled = true;
                     document.getElementById("btn-pass").disabled = true;
                } else if (data.rankings && data.rankings[myId]) {
                    els.msg.innerText = `ã‚ãªãŸã¯ ${data.rankings[myId]}ä½ ã§ã‚ãŒã‚Šã¾ã—ãŸï¼`;
                    document.getElementById("btn-play").disabled = true;
                    document.getElementById("btn-pass").disabled = true;
                } else {
                    let activeCount = getActiveCount(data);
                    let isInheritedReset = (data.rankings && data.rankings[resetHolder] && data.passCount >= activeCount);
                    let isOwnerReset = (resetHolder === myId && (data.graveNum||[]).length > 0);
                    let canReset = isOwnerReset || isInheritedReset;
                    
                    if (isMyTurnNow) {
                        if (!wasMyTurn) playSoundEffect('turn');
                        if (data.turnIdx !== lastCleanupTurnIdx) {
                            lastCleanupTurnIdx = data.turnIdx;
                            if (typeof checkHackerCleanup === 'function') checkHackerCleanup();
                        }
                        els.msg.innerText = canReset ? "ãƒªã‚»ãƒƒãƒˆå¯èƒ½ã§ã™ï¼ˆãƒ‘ã‚¹ã§ç™ºå‹•ï¼‰" : "ã‚ãªãŸã®ç•ªã§ã™";
                        document.getElementById("btn-play").disabled = false;
                        document.getElementById("btn-pass").disabled = false;
                    } else {
                        lastCleanupTurnIdx = -1;
                        let curP = players[pIds[data.turnIdx]];
                        els.msg.innerText = `${curP ? curP.name : 'ç›¸æ‰‹'} ã®ã‚¿ãƒ¼ãƒ³`;
                        document.getElementById("btn-play").disabled = true;
                        document.getElementById("btn-pass").disabled = true;
                    }
                }
                wasMyTurn = isMyTurnNow;

            } else {
                // å¾…æ©Ÿä¸­ (Lobby)
                els.msg.innerText = `å¾…æ©Ÿä¸­... ${Object.keys(players).length}äººãŒå‚åŠ `;
                playBgm('BGM_LOBBY');
                prevActivatedList = {};
                prevRevealedRoles = {};
                if(handContainer) handContainer.innerHTML = "";
                if(document.getElementById("my-role-panel")) document.getElementById("my-role-panel").innerHTML = "";
            }

            // å…±é€š: ãƒ­ã‚°æ›´æ–°
            renderLogs(data.logs);

            // ãƒ›ã‚¹ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« (â˜…å¤‰æ›´ç‚¹: effectiveHostIdã‚’ä½¿ç”¨)
            // â†“â†“â†“ renderé–¢æ•°å†…ã®ã€Œãƒ›ã‚¹ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã€éƒ¨åˆ†ã‚’æ›¸ãæ›ãˆ â†“â†“â†“
            // ãƒ›ã‚¹ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« (â˜…å¤‰æ›´ç‚¹: æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º/éè¡¨ç¤ºã«ã™ã‚‹)
            const isHost = (effectiveHostId === myId);
            const btnHost = document.getElementById("btn-host-settings");
            
            if (isHost && btnHost) {
                btnHost.classList.remove("hidden");
            } else if (btnHost) {
                btnHost.classList.add("hidden");
            }

            // â†“â†“â†“ renderé–¢æ•°å†…ã®ã€Œé€šçŸ¥ãƒã‚§ãƒƒã‚¯ã€ã®ä¸Šã‚ãŸã‚Šã«è¿½åŠ  â†“â†“â†“
            // --- 7. è‡ªåˆ†ã®é †ä½æ±ºå®šéŸ³ (æ•—è€…ã‚‚å«ã‚€) ---
            if (data.rankings && data.rankings[myId]) {
                if (!myRankPlayed) {
                    let rank = data.rankings[myId];
                    let total = data.playerOrder.length;
                    
                    if (rank === 1) playSoundEffect('RANK_1');     // 1ä½
                    else if (rank === total) playSoundEffect('RANK_4'); // â˜…æœ€ä¸‹ä½(æ•—è€…)
                    else playSoundEffect('RANK_2_3');              // ãã‚Œä»¥å¤–
                    
                    myRankPlayed = true; // å†ç”Ÿæ¸ˆã¿ã«ã™ã‚‹
                }
            } else {
                // ã¾ã é †ä½ãŒã¤ã„ã¦ã„ãªã„ï¼ˆã¾ãŸã¯ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ï¼‰ã¯ãƒªã‚»ãƒƒãƒˆ
                myRankPlayed = false;
            }

            // â†‘â†‘â†‘ æ›¸ãæ›ãˆã“ã“ã¾ã§ â†‘â†‘â†‘
            // é€šçŸ¥ãƒã‚§ãƒƒã‚¯
            const myPlayer = players[myId] || {};
            if (myPlayer.notification) {
                playSoundEffect('WARNING');
                const note = myPlayer.notification;
                const getNotifDisplay = (val) => {
                    if (CARD_IMAGES[val]) return `<img src="${CARD_IMAGES[val]}" style="height:80px; width:auto; display:block; margin:0 auto;">`;
                    let style = "font-size:32px; font-weight:bold; line-height:80px;";
                    if (val == 0) style += "color:#8e24aa;";
                    return `<div style="${style}">${val}</div>`;
                };
                let html = `
                    <div style="text-align:center;">
                        <p style="font-size:16px; font-weight:bold; color:#d32f2f;">${note.fromName} ã«ãƒˆãƒ¬ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸï¼</p>
                        <div style="display:flex; justify-content:space-around; align-items:center; margin:10px 0;">
                            <div style="width:100px;"><div style="font-size:10px; color:#888;">ç›—ã¾ã‚ŒãŸ</div>${getNotifDisplay(note.lostVal)}</div>
                            <div style="font-size:20px; color:#ccc;">â¡</div>
                            <div style="width:100px;"><div style="font-size:10px; color:#888;">æ¸¡ã•ã‚ŒãŸ</div>${getNotifDisplay(note.gotVal)}</div>
                        </div>
                    </div>`;
                openModal("âš ï¸ ãƒˆãƒ¬ãƒ¼ãƒ‰è­¦å‘Š", html);
                firebase.database().ref(`rooms/${currentRoom}/players/${myId}/notification`).remove();
            }

            // â†“â†“â†“ è¿½åŠ : è‡ªåˆ†ã®åå‰ãƒãƒ¼ã®æ›´æ–° â†“â†“â†“
            // â– â– â–  è‡ªåˆ†ã‚¨ãƒªã‚¢ï¼ˆåå‰ãƒ»å½¹è·ãƒ»é †ä½ï¼‰ã®è¡¨ç¤ºå‡¦ç† â– â– â– 
            const nameBar = document.getElementById("my-name-bar");
            if (nameBar && players[myId]) {

                // â˜…ä¿®æ­£: å¤‰æ•°åã‚’ã€ŒrHolderã€ã«å¤‰ãˆã¦ã€ã“ã“ã§å†å®šç¾©ã—ã¾ã™
                // (ã“ã‚Œã§ä¸Šã«ã‚ã‚‹ã‚„ã¤ã¨å–§å˜©ã›ãšã€ç¢ºå®Ÿã«å‹•ãã¾ã™)
                let rHolder = null;
                if (data.graveNum && data.graveNum.length > 0) {
                    rHolder = data.graveNum[data.graveNum.length-1].owner;
                }

                let myPName = players[myId].name;
                
                // 1. å½¹è·ã®HTMLç”Ÿæˆ
                let myRoleHtml = "";
                if (roles[myId]) {
                    const rKey = roles[myId];
                    const rInfo = (typeof ROLE_INFO !== 'undefined') ? ROLE_INFO[rKey] : null;
                    const jpName = rInfo ? rInfo.jp : rKey;
                    
                    // ã‚¹ã‚­ãƒ«ä½¿ç”¨æ¸ˆã¿ãªã‚‰ç°è‰²ã€æœªä½¿ç”¨ãªã‚‰ç´«
                    const isUsed = currentAct[myId];
                    const textColor = isUsed ? "#616161" : "#e040fb"; 
                    
                    // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚„å¤ªã•ã®æŒ‡å®šã‚’æ¶ˆã—ã¦ã€åå‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãã®ã¾ã¾å¼•ãç¶™ãã‚ˆã†ã«ã—ã¾ã—ãŸ
                    myRoleHtml = `<span style="color:${textColor}; margin-left:10px;">ã€å½¹è·ã€‘${jpName}</span>`;
                }

                let resetBadge = "";
                // â˜…ã“ã“ã‚‚ rHolder ã‚’ä½¿ã£ã¦åˆ¤å®šã—ã¾ã™
                if (rHolder === myId) {
                    // status-resetã‚¯ãƒ©ã‚¹ã‚’ãã®ã¾ã¾åˆ©ç”¨ï¼ˆä½ç½®èª¿æ•´ã®ãŸã‚styleã‚’è¿½åŠ ï¼‰
                    resetBadge = `<span class="status-reset" style="margin-left:10px; font-size:12px; vertical-align:middle; display:inline-block;">ğŸ‘‘ RESET</span>`;
                }

                // 2. ãƒ›ã‚¹ãƒˆãªã‚‰â˜…ã‚’è¡¨ç¤º
                let hostIcon = (effectiveHostId === myId) ? "<span style='color:#ffd700; margin-right:4px;'>â˜…</span>" : "";

                // 3. é †ä½ãŒã¤ã„ã¦ã„ã‚‹ãªã‚‰è¡¨ç¤º
                let rankText = (data.rankings && data.rankings[myId]) ? `<span style="color:#ffd700; margin-left:10px;">ğŸ†${data.rankings[myId]}ä½</span>` : "";

                // â˜…å…¨éƒ¨ã¾ã¨ã‚ã¦ã‚»ãƒƒãƒˆï¼
                nameBar.innerHTML = `${hostIcon}${myPName}${myRoleHtml}${resetBadge}${rankText}`;
            }

            // éŸ³å†ç”Ÿ
            const soundData = data.lastSound;
            if (soundData && soundData.id !== prevSoundId) {
                if (Array.isArray(soundData.type)) {
                    soundData.type.forEach(t => playSoundEffect(t));
                } else {
                    playSoundEffect(soundData.type);
                }
                prevSoundId = soundData.id;
            }
        }

        function getTotalHandCount(pid) {
            let h1 = (gameState.hands[pid] || []).length;
            let h2 = (gameState.hackedHands && gameState.hackedHands[pid]) ? gameState.hackedHands[pid].length : 0;
            return h1 + h2;
        }

        function viewGrave(type) {
            let list;
            let title;
            if (type === 'num') { list = gameState.graveNum; title = "æ•°å­—å¢“åœ°"; }
            else if (type === 'sym') { list = gameState.graveSym; title = "è¨˜å·å¢“åœ°"; }
            else if (type === 'excl') { list = gameState.exclusion; title = "é™¤å¤–å ´"; }

            if (!list || list.length === 0) return showInfoModal(title, "ç©ºã§ã™");
            
            let html = '<div class="modal-list">';
            list.slice().reverse().forEach(c => {
                let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
                let imgUrl = CARD_IMAGES[c.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                html += `<div class="card ${c.type}" style="${style} ${imgStyle}">${c.val}</div>`;
            });
            html += '</div>';
            openModal(title, html);
        }

        function renderPile(arr) {
            if (!arr || arr.length === 0) return "";
            let c = arr[arr.length-1];
            let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
            let imgUrl = CARD_IMAGES[c.val];
            let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
            return `<div class="card ${c.type}" style="${style} ${imgStyle}">${c.val}</div>`;
        }

        // --- Action Logic ---
        function passTurn() {
            if (!isMyTurn()) return;
            
            let activeCount = getActiveCount(gameState);
            let top = getTop(gameState.graveNum);
            let resetHolder = top ? top.owner : null;

            let isOwnerReset = (resetHolder === myId && (gameState.graveNum||[]).length > 0);
            let isInheritedReset = (resetHolder && gameState.rankings && gameState.rankings[resetHolder] && gameState.passCount >= activeCount);

            if (isOwnerReset || isInheritedReset) {
                openModal("ãƒ‘ã‚¹ (ãƒªã‚»ãƒƒãƒˆæ¨©è¡Œä½¿)", "å±±æœ­ã‹ã‚‰ãƒ‰ãƒ­ãƒ¼ã—ã¾ã™ã‹ï¼Ÿ<br><br><span style='color:#ef5350; font-weight:bold;'>â€»ãƒªã‚»ãƒƒãƒˆæ¨©ã‚’è¡Œä½¿ã—ã¾ã™ï¼ˆå ´ãŒæµã‚Œã€è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ãŒç¶šãã¾ã™ï¼‰</span><br><br><button class='modal-btn primary' onclick='execPassDraw(true)'>ãƒ‰ãƒ­ãƒ¼ã™ã‚‹</button><button class='modal-btn' onclick='execPassNoDraw(true)'>ã—ãªã„</button>");
                return;
            }

            openModal("ãƒ‘ã‚¹", "å±±æœ­ã‹ã‚‰ãƒ‰ãƒ­ãƒ¼ã—ã¾ã™ã‹ï¼Ÿ<br><br><button class='modal-btn primary' onclick='execPassDraw(false)'>ãƒ‰ãƒ­ãƒ¼ã™ã‚‹</button><button class='modal-btn' onclick='execPassNoDraw(false)'>ã—ãªã„</button>");
        }

        async function execPassNoDraw(isReset) {
            closeModal();
            let updates = {};
            
            if(isReset) {
                let excl = [...(gameState.exclusion || []), ...(gameState.graveNum || [])];
                updates[`rooms/${currentRoom}/exclusion`] = excl;
                updates[`rooms/${currentRoom}/graveNum`] = [];
                updates[`rooms/${currentRoom}/passCount`] = 0;
                await pushLog(`${myName}ãŒãƒ‰ãƒ­ãƒ¼ã›ãšãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ`, 'public');
            } else {
                updates[`rooms/${currentRoom}/passCount`] = (gameState.passCount || 0) + 1;
                await pushLog(`${myName}ãŒãƒ‰ãƒ­ãƒ¼ã›ãšãƒ‘ã‚¹ã—ã¾ã—ãŸ`, 'public');
                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            }
            
            await db.ref().update(updates);
        }

        // â†“â†“â†“ execPassDrawé–¢æ•°ã‚’ä¸¸ã”ã¨ã“ã‚Œã«ç½®ãæ›ãˆã¦ãã ã•ã„ â†“â†“â†“
        async function execPassDraw(isReset) {
            closeModal();
            let updates = {};
            let deck = [...(gameState.deckNum || [])];
            
            // å±±æœ­ãŒç©ºã®å ´åˆã®è£œå……å‡¦ç†
            if (deck.length === 0) {
                let excl = [...(gameState.exclusion || [])];
                let newDeck = excl.filter(c => c.type === 'num');
                let remainingExcl = excl.filter(c => c.type !== 'num');

                if (newDeck.length > 0) {
                    shuffle(newDeck);
                    deck = newDeck;
                    updates[`rooms/${currentRoom}/exclusion`] = remainingExcl;
                    await pushLog("é™¤å¤–å ´ã‹ã‚‰æ•°å­—å±±æœ­ã‚’è£œå……ã—ã¾ã—ãŸ", 'public');
                } else {
                    showInfoModal("é€šçŸ¥", "å±±æœ­ã‚‚é™¤å¤–å ´ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‰ãƒ­ãƒ¼ãªã—ã§ãƒ‘ã‚¹ã—ã¾ã™ã€‚");
                    execPassNoDraw(isReset);
                    return;
                }
            }
            
            // ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã
            let card = deck.pop();
            const top = getTop(gameState.graveNum);
            // ãƒªã‚»ãƒƒãƒˆæ™‚ã§ãªã‘ã‚Œã°ã€å‡ºã›ã‚‹ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹
            const playable = !isReset && (card.type === 'num' && canPlay(card, top, gameState.isReverse));
            
            drawnCardTemp = card;
            updates[`rooms/${currentRoom}/deckNum`] = deck;
            await db.ref().update(updates);

            if (playable) {
                // å‡ºã›ã‚‹å ´åˆï¼šé¸æŠè‚¢ã‚’è¡¨ç¤º
                let imgUrl = CARD_IMAGES[card.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                let cardHtml = `<div class="card ${card.type}" style="display:inline-flex; ${imgStyle}">${card.val}</div>`;
                
                let html = `å¼•ã„ãŸã‚«ãƒ¼ãƒ‰: ${cardHtml}<br>ã“ã‚Œã‚’å‡ºã—ã¾ã™ã‹ï¼Ÿ<br><br>
                            <button class='modal-btn primary' onclick='execPassPlay()'>å‡ºã™</button>
                            <button class='modal-btn' onclick='execPassKeep()'>æ‰‹æœ­ã«å…¥ã‚Œã‚‹</button>`;
                
                openModal("ãƒ‰ãƒ­ãƒ¼çµæœ", html);

                // â˜…ä¿®æ­£: ã“ã“ã§ãƒ•ãƒƒã‚¿ãƒ¼ï¼ˆé–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼‰ã‚’æ¶ˆå»ã—ã¦ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸å¯ã«ã™ã‚‹
                if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }

            } else {
                // å‡ºã›ãªã„å ´åˆï¼ˆã¾ãŸã¯ãƒªã‚»ãƒƒãƒˆæ™‚ï¼‰ï¼šè‡ªå‹•çš„ã«æ‰‹æœ­ã¸
                let msg = isReset ? "(ãƒªã‚»ãƒƒãƒˆã®ãŸã‚æ‰‹æœ­ã«å…¥ã‚Œã¾ã™)" : "(å‡ºã›ãªã„ã®ã§æ‰‹æœ­ã«å…¥ã‚Œã¾ã™)";
                await pushLog(`[${card.val}] ã‚’å¼•ãã¾ã—ãŸ ${msg}`, 'private', myId);
                execPassKeep(isReset);
            }
        }

        async function execPassPlay() {
            closeModal();
            let card = drawnCardTemp;
            if(!card) return;
            
            let updates = {};
            let gn = [...(gameState.graveNum || [])];
            gn.push({ ...card, owner: myId });
            updates[`rooms/${currentRoom}/graveNum`] = gn;
            updates[`rooms/${currentRoom}/passCount`] = 0;
            
            await pushLog(`${myName}ãŒãƒ‘ã‚¹ãƒ‰ãƒ­ãƒ¼ã‹ã‚‰ [${card.val}] ã‚’å‡ºã—ã¾ã—ãŸ`, 'public');
            
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await db.ref().update(updates);
            drawnCardTemp = null;
        }

        async function execPassKeep(isReset = false) {
            closeModal(); 
            let card = drawnCardTemp;
            if(!card) return;

            let updates = {};
            let hand = [...gameState.hands[myId]];
            hand.push(card);
            hand = sortCards(hand);
            updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            
            if(isReset) {
                let excl = [...(gameState.exclusion || []), ...(gameState.graveNum || [])];
                updates[`rooms/${currentRoom}/exclusion`] = excl;
                updates[`rooms/${currentRoom}/graveNum`] = [];
                updates[`rooms/${currentRoom}/passCount`] = 0;
                await pushLog(`${myName}ãŒãƒªã‚»ãƒƒãƒˆã—ã¦1æšå¼•ãã¾ã—ãŸ`, 'public');
            } else {
                updates[`rooms/${currentRoom}/passCount`] = (gameState.passCount || 0) + 1;
                if(gameState.lastLog !== `${myName}ãŒãƒ‰ãƒ­ãƒ¼ã›ãšãƒ‘ã‚¹ã—ã¾ã—ãŸ`) {
                     await pushLog(`${myName}ãŒãƒ‘ã‚¹ã—ã¦1æšå¼•ãã¾ã—ãŸ`, 'public');
                }
                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            }

            await db.ref().update(updates);
            drawnCardTemp = null;
        }

        async function playCard() {
            if (selectedIdx === -1) return;
            if (!isMyTurn()) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "ã‚ãªãŸã®ç•ªã§ã¯ã‚ã‚Šã¾ã›ã‚“");

            let currentHand = sortCards(deepCopy(gameState.hands[myId]));
            const card = currentHand[selectedIdx];
            
            if (card.type === 'num') {
                if (Number(card.val) === 0 && currentHand.length === 1) {
                    return showInfoModal("ç¦æ­¢ã‚ãŒã‚Š", "æœ€å¾Œã®ä¸€æšãŒã€Œ0ã€ã§ã‚ãŒã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚");
                }

                const top = getTop(gameState.graveNum);
                
                if (!canPlay(card, top, gameState.isReverse)) {
                    return showInfoModal("ã‚¨ãƒ©ãƒ¼", "ãã®ã‚«ãƒ¼ãƒ‰ã¯å‡ºã›ã¾ã›ã‚“");
                }
                
                let updates = {};
                let newHand = [...currentHand];
                newHand.splice(selectedIdx, 1);
                updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;

                // â˜…æ®‹ã‚Šæšæ•°ã‚’è¨ˆç®—ã—ã¦ã€é³´ã‚‰ã™éŸ³ã‚’æ±ºå®šã™ã‚‹
                // â˜…éŸ³ã®ã‚»ãƒƒãƒˆã‚’ä½œæˆï¼ˆåŸºæœ¬ã¯PUTï¼‰
                let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
                let nextTotal = newHand.length + myHackedCount;
                
                let soundList = ['PUT']; 
                if (nextTotal === 1) soundList.push('UNO');
                else if (nextTotal === 2) soundList.push('DOS');

                // ã‚»ãƒƒãƒˆã§é€ä¿¡
                updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

                let newGraveNum = [...(gameState.graveNum || [])];
                
        
                
                let playCardData = { ...card, owner: myId };
                newGraveNum.push(playCardData);

                updates[`rooms/${currentRoom}/graveNum`] = newGraveNum;
                updates[`rooms/${currentRoom}/passCount`] = 0;
                
                await pushLog(`${myName}ãŒ [${card.val}] ã‚’å‡ºã—ã¾ã—ãŸ`, 'public');

                /* --- playCard é–¢æ•°å†…ã®ä¿®æ­£ (æ¨å¥¨ç‰ˆ) --- */

                // æ‰‹æœ­(newHand)ãŒ0æšã€ã‹ã¤ã€éš”é›¢ã‚¨ãƒªã‚¢(hackedHands)ã‚‚0æšãªã‚‰ã‚ãŒã‚Š
                // â˜…ã“ã“ã‚’æ›¸ãæ›ãˆ
                if (newHand.length === 0 && myHackedCount === 0) {
                    let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                    // ... (ä»¥ä¸‹ã€ã‚ãŒã‚Šå‡¦ç†ã¯ãã®ã¾ã¾)
                    updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                    await pushLog(`${myName}ãŒ ${currentRank}ä½ ã§ã‚ãŒã‚Šã¾ã—ãŸï¼`, 'public');

                    let totalPlayers = gameState.playerOrder.length;
                    if (currentRank >= totalPlayers - 1) {
                         updates[`rooms/${currentRoom}/status`] = "finished";
                         await pushLog(`å…¨é †ä½ãŒç¢ºå®šã—ã¾ã—ãŸï¼`, 'public');
                         let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                         if(loserId) updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                    }
                }
                
                let tempRankings = {...(gameState.rankings || {})};
                if(newHand.length === 0) tempRankings[myId] = 99;

                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

                await db.ref().update(updates);
                selectedIdx = -1;

            } else { handleSymbol(card, selectedIdx, currentHand); }
        }

        async function handleSymbol(card, idx, currentHand) {
            if (currentHand.length === 1) return showInfoModal("ç¦æ­¢ã‚ãŒã‚Š", "è¨˜å·ã§ã‚ãŒã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚");
            //ã“ã“ã‚’ãƒãƒƒã‚«ãƒ¼ã®ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã‚‹ã‚«ãƒ¼ãƒ‰ã¨åˆã‚ã›ã¦è¨ˆç®—ã™ã‚Œã°ã‚ˆã•ãã†
            
            if (card.val === "DIG UP") {
                const hasNum = currentHand.some((c, i) => i !== idx && c.type === 'num');
                if (!hasNum) return showInfoModal("ä½¿ç”¨ä¸å¯", "æ‰‹æœ­ã«æ•°å­—ã‚«ãƒ¼ãƒ‰ãŒãªã„ãŸã‚ã€DIG UPã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚");
                let gn = gameState.graveNum || [];
                if (gn.length === 0) return showInfoModal("ä½¿ç”¨ä¸å¯", "æ•°å­—å¢“åœ°ãŒãªã„ãŸã‚ä½¿ç”¨ã§ãã¾ã›ã‚“");
                
                let top = gn[gn.length-1];
                let imgUrl = CARD_IMAGES[top.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                let topCardHtml = `<div class="card ${top.type}" style="${imgStyle} display:inline-flex;">${top.val}</div>`;

                let html = `<p>å¢“åœ°ã® ${topCardHtml} ã‚’æ‰‹æœ­ã«å…¥ã‚Œã¾ã™ã€‚<br>ä»£ã‚ã‚Šã«å ´ã«åŸ‹ã‚ã‚‹ã‚«ãƒ¼ãƒ‰(æ‰‹æœ­)ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
                currentHand.forEach((c, i) => {
                    if (i === idx) return; 
                    if (c.type !== 'num') return; 
                    let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
                    let cImg = CARD_IMAGES[c.val];
                    if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                    html += `<div class="card ${c.type}" style="${style}" onclick="execDigUp(${idx}, ${i})">${c.val}</div>`;
                });
                html += `</div>`;
                openModal("DIG UP: äº¤æ›", html);
                return;
            }
            if (card.val === "TRADE") {
                let pIds = gameState.playerOrder;
                let html = `<p>ãƒˆãƒ¬ãƒ¼ãƒ‰ç›¸æ‰‹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>`;
                pIds.forEach(pid => {
                    if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
                    let p = gameState.players[pid];
                    let count = gameState.hands[pid] ? gameState.hands[pid].length : 0;
                    if (count > 0) {
                        html += `<button class="modal-btn" onclick="tradeStep2('${pid}', ${idx})">${p.name} (æ‰‹æœ­${count})</button>`;
                    }
                });
                openModal("TRADE: ç›¸æ‰‹é¸æŠ", html);
                return;
            }
            if (card.val === "DISCARD") {
                let newHand = [...currentHand];
                let discardable = newHand.filter((_, i) => i !== idx);
                if (discardable.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "æ¨ã¦ã‚‹æ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“");

                let html = `<p>æ¨ã¦ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
                discardable.forEach((c, i) => {
                    let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
                    let cImg = CARD_IMAGES[c.val];
                    if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                    html += `<div class="card ${c.type}" style="${style}" onclick="execDiscard(${idx}, ${i})">${c.val}</div>`;
                });
                html += `</div>`;
                openModal("DISCARD: æ‰‹æœ­ç ´æ£„", html);
                return;
            }

            // â†“â†“â†“ handleSymbolé–¢æ•°å†…ã® lastSound é€ä¿¡éƒ¨åˆ†ã‚’ã“ã‚Œã«æ›¸ãæ›ãˆ â†“â†“â†“
            // ---------------------------------------------------------
            // â˜…ä¿®æ­£: REVERSEãªã©ã®å³æ™‚ç™ºå‹•ã‚«ãƒ¼ãƒ‰å‡¦ç†
            // ---------------------------------------------------------
            // 1. ã¾ãšæ‰‹æœ­ã‹ã‚‰å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã‚’å–ã‚Šé™¤ã (ã“ã“ã§ newHand ã‚’å®šç¾©ï¼)
            let updates = {};
            let newHand = [...currentHand];
            newHand.splice(idx, 1);

            // 2. æ®‹ã‚Šæšæ•°ã‚’è¨ˆç®—ã—ã¦ã€éŸ³ã®ã‚»ãƒƒãƒˆã‚’ä½œæˆ
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = newHand.length + myHackedCount;

            let soundList = [card.val]; // ä¾‹: ['REVERSE']
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            // 3. ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
            updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;
            let newGraveSym = [...(gameState.graveSym || [])];
            newGraveSym.push(card);
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;

            let logMsg = `${myName}ãŒ [${card.val}] ã‚’ä½¿ç”¨`;
            if (card.val === "REVERSE") {
                updates[`rooms/${currentRoom}/isReverse`] = !gameState.isReverse;
                logMsg += " (å¼·å¼±é€†è»¢)";
            }

            await pushLog(logMsg, 'public');

            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await db.ref().update(updates);
            selectedIdx = -1;
        }

        // â†“â†“â†“ execDigUpé–¢æ•°ã‚’ä¸¸ã”ã¨ã“ã‚Œã«ç½®ãæ›ãˆã¦ãã ã•ã„ â†“â†“â†“
        async function execDigUp(digUpIdx, returnIdx) {
            closeModal();
            let updates = {};
            let newHand = sortCards(deepCopy(gameState.hands[myId]));
            let gn = [...gameState.graveNum];
            
            // å‡¦ç†
            let top = gn.pop(); 
            let usedDigUp = newHand.splice(digUpIdx, 1)[0]; 
            let newGraveSym = [...(gameState.graveSym || []), usedDigUp];
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª¿æ•´
            let actualReturnIdx = (returnIdx > digUpIdx) ? returnIdx - 1 : returnIdx;
            let retCard = newHand.splice(actualReturnIdx, 1)[0];
            newHand.push(top);
            
            gn.push({ ...retCard, owner: myId }); 
            newHand = sortCards(newHand);
            
            updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;
            
            // â˜…ä¿®æ­£: UNO/DOSéŸ³ã®è¿½åŠ 
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = newHand.length + myHackedCount;

            let soundList = ['DIG UP'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            updates[`rooms/${currentRoom}/graveNum`] = gn;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await pushLog(`${myName}ãŒ DIG UP ã‚’ä½¿ç”¨`, 'public');
            
            await db.ref().update(updates);
            selectedIdx = -1;
        }

        /* --- é€šå¸¸ã®TRADEæ”¹ä¿® (ç‹™ã„æ’ƒã¡å¯¾å¿œ) --- */

        // å…ƒã® tradeStep2 ã‚’ã€Œå¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠã€ã«ä¸Šæ›¸ã
        // (handleSymbol ã‹ã‚‰ã¯ã“ã‚ŒãŒå‘¼ã°ã‚Œã¾ã™)
        /* --- ä¿®æ­£ç‰ˆ: tradeStep2 (ãƒ•ã‚©ãƒ³ãƒˆãƒãƒ¬é˜²æ­¢) --- */
        function tradeStep2(targetId, tradeCardIdx) {
            let targetHand = deepCopy(gameState.hands[targetId] || []);
            
            // å…ƒã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨˜éŒ²ã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            targetHand.forEach((c, i) => c.originalIndex = i);
            shuffle(targetHand);

            let html = `<p>ç›¸æ‰‹ã®æ‰‹æœ­ã‹ã‚‰<strong>æ¬²ã—ã„ã‚«ãƒ¼ãƒ‰</strong>ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚<br>
                        <span style="font-size:11px;">(é€šå¸¸ã¯è£å‘ãã§ã™ãŒã€å…¬é–‹ã‚«ãƒ¼ãƒ‰ã¯è¦‹ãˆã¾ã™)</span></p>
                        <div class="modal-list">`;

            targetHand.forEach(c => {
                let content = "?";
                let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
                let cssClass = "card"; // â˜…ä¿®æ­£: åˆæœŸå€¤ã¯ãŸã ã®card

                // å…¬é–‹ã‚«ãƒ¼ãƒ‰ãªã‚‰ä¸­èº«ã‚’è¡¨ç¤º
                // â˜…ãƒãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯
                if (c.isHacked) {
                    cssClass += " hacked";
                    style = "cursor:not-allowed; border:1px solid #555; background:#333;";
                    content = "ğŸ”’"; // è£å‘ãã§ã‚‚ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã¯ã‚ã‹ã‚‹
                    onClick = ""; // ã‚¯ãƒªãƒƒã‚¯ç„¡åŠ¹
                }
                // å…¬é–‹ã‚«ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯ (ãƒãƒƒã‚¯ã•ã‚Œã¦ãŸã‚‰ãƒ­ãƒƒã‚¯å„ªå…ˆ)
                else if (c.isOpen) {
                    cssClass = `card ${c.type}`;
                    content = c.val;
                    style = "cursor:pointer; ";
                    let cImg = CARD_IMAGES[c.val];
                    if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                    else if(c.val===0) style += `border:2px solid #ab47bc; color:#8e24aa; background:#f3e5f5;`;
                }

                html += `<div class="${cssClass}" style="${style}" 
                        onclick="tradeStep3('${targetId}', ${tradeCardIdx}, ${c.originalIndex})">
                        ${content}
                        </div>`;
            });
            
            html += `</div>`;
            openModal("TRADE: ç•¥å¥ªé¸æŠ", html);
        }

        // æ–°è¨­: è‡ªåˆ†ã®æ¸¡ã™ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶ (æ—§ tradeStep2 ã®ä¸­èº«)
        function tradeStep3(targetId, tradeCardIdx, takeIdx) {
            let myHand = sortCards(deepCopy(gameState.hands[myId]));
            let html = `<p>ç›¸æ‰‹ã«æ¸¡ã™ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
            
            myHand.forEach((c, i) => {
                if (i === tradeCardIdx) return; // ã‚³ã‚¹ãƒˆã¨ã—ã¦æ‰•ã†TRADEã‚«ãƒ¼ãƒ‰ã¯é¸ã¹ãªã„
                
                let style = "";
                let cImg = CARD_IMAGES[c.val];
                if (cImg) {
                    style = `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                } else if (c.val === 0) {
                    style = `border:2px solid #ab47bc; color:#8e24aa; background:#f3e5f5;`;
                }

                // å®Ÿè¡Œ (execTrade ã« takeIdx ã‚’æ¸¡ã™)
                html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                        onclick="execTrade('${targetId}', ${tradeCardIdx}, ${i}, ${takeIdx})">${c.val}</div>`;
            });
            
            html += `</div>`;
            openModal("TRADE: è­²æ¸¡é¸æŠ", html);
        }

        // å®Ÿè¡Œå‡¦ç† (å¼•æ•° takeIdx ã‚’è¿½åŠ )
        // â†“â†“â†“ execTradeé–¢æ•°ã‚’ä¸¸ã”ã¨ã“ã‚Œã«ç½®ãæ›ãˆã¦ãã ã•ã„ â†“â†“â†“
        async function execTrade(targetId, tradeCardIdx, giveCardIdx, takeIdx) {
            closeModal();
            let updates = {};
            let myHand = sortCards(deepCopy(gameState.hands[myId]));
            let targetHand = sortCards(deepCopy(gameState.hands[targetId]));
            
            // ã‚³ã‚¹ãƒˆæ”¯æ‰•ã„
            let usedTrade = myHand.splice(tradeCardIdx, 1)[0];
            let newGraveSym = [...(gameState.graveSym || []), usedTrade];
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª¿æ•´
            let actualGiveIdx = (giveCardIdx > tradeCardIdx) ? giveCardIdx - 1 : giveCardIdx;
            
            // äº¤æ›å®Ÿè¡Œ
            let giveCard = myHand.splice(actualGiveIdx, 1)[0];
            let receiveCard = targetHand.splice(takeIdx, 1)[0];
            
            myHand.push(receiveCard);
            targetHand.push(giveCard);
            myHand = sortCards(myHand);
            targetHand = sortCards(targetHand);
            
            updates[`rooms/${currentRoom}/hands/${myId}`] = myHand;
            updates[`rooms/${currentRoom}/hands/${targetId}`] = targetHand;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            
            await pushLog(`${myName}ãŒ ${gameState.players[targetId].name} ã¨ [TRADE] ã—ã¾ã—ãŸ`, 'public');
            await pushLog(`${gameState.players[targetId].name}ã‹ã‚‰ [${receiveCard.val}] ã‚’å¥ªã„ã€[${giveCard.val}] ã‚’æ¸¡ã—ã¾ã—ãŸã€‚`, 'private', myId);
            await pushLog(`${gameState.players[myId].name}ã« [${receiveCard.val}] ã‚’å¥ªã‚ã‚Œã€ [${giveCard.val}] ã‚’æ¸¡ã•ã‚Œã¾ã—ãŸã€‚`, 'private', targetId);

            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
                fromName: myName + "(TRADE)",
                lostVal: receiveCard.val,
                gotVal: giveCard.val
            };

            // â˜…ä¿®æ­£: UNO/DOSéŸ³ã®è¿½åŠ 
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = myHand.length + myHackedCount;

            let soundList = ['TRADE'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };
            
            await db.ref().update(updates);
            selectedIdx = -1;
        }

        // â†“â†“â†“ execDiscardé–¢æ•°ã‚’ä¸¸ã”ã¨ã“ã‚Œã«ç½®ãæ›ãˆã¦ãã ã•ã„ â†“â†“â†“
        async function execDiscard(useCardIdx, targetIdx) {
            closeModal();
            let updates = {};
            let currentHand = sortCards(deepCopy(gameState.hands[myId]));
            
            // 1. ã‚³ã‚¹ãƒˆã¨ã—ã¦ä½¿ã†ã€ŒDISCARDã€ã‚«ãƒ¼ãƒ‰è‡ªä½“
            let usedCard = currentHand.splice(useCardIdx, 1)[0];
            let newGraveSym = [...(gameState.graveSym || []), usedCard];
            
            // 2. æ¨ã¦ã‚‰ã‚Œã‚‹ã‚«ãƒ¼ãƒ‰
            // (UIã®ä»•çµ„ã¿ä¸Šã€spliceå¾Œã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒæ¸¡ã£ã¦ãã‚‹ã®ã§ãã®ã¾ã¾ä½¿ãˆã¾ã™)
            let discardCard = currentHand.splice(targetIdx, 1)[0];
            
            // â˜…ã“ã“ãŒä¿®æ­£ãƒã‚¤ãƒ³ãƒˆï¼šç¨®é¡ã«ã‚ˆã£ã¦é€ã‚Šå…ˆã‚’å¤‰ãˆã‚‹
            let newGraveNum = [...(gameState.graveNum || [])];
            
            if (discardCard.type === 'num') {
                // æ•°å­—ãªã‚‰ã€Œæ•°å­—å¢“åœ°ã€ã¸ï¼ˆã“ã‚Œã§å ´ã®ãƒˆãƒƒãƒ—ãŒæ›´æ–°ã•ã‚Œã€ãƒã‚°ãŒç›´ã‚‹ï¼ï¼‰
                // ownerã‚’è‡ªåˆ†ã«ã™ã‚‹ã“ã¨ã§ã€è²¬ä»»ã®æ‰€åœ¨ã‚’æ˜ç¢ºã«ã™ã‚‹
                newGraveNum.push({ ...discardCard, owner: myId });
            } else {
                // è¨˜å·ãªã‚‰ã€Œè¨˜å·å¢“åœ°ã€ã¸
                newGraveSym.push(discardCard);
            }
            
            currentHand = sortCards(currentHand);
            
            // éŸ³ã®ã‚»ãƒƒãƒˆã‚’ä½œæˆ
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = currentHand.length + myHackedCount;

            let soundList = ['DISCARD'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };
            
            // å¢“åœ°æƒ…å ±ã‚’æ›´æ–°ï¼ˆé™¤å¤–å ´ exclusion ã¸ã®è¿½åŠ ã¯å‰Šé™¤ï¼‰
            updates[`rooms/${currentRoom}/graveNum`] = newGraveNum;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            updates[`rooms/${currentRoom}/hands/${myId}`] = currentHand;
        
            await pushLog(`${myName}ãŒ [DISCARD] ã§ [${discardCard.val}] ã‚’æ¨ã¦ã¾ã—ãŸï¼ï¼`, 'public');

            updates[`rooms/${currentRoom}/passCount`] = 0;

            // ã‚ãŒã‚Šåˆ¤å®š
            if (currentHand.length === 0 && myHackedCount === 0) {
                let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                await pushLog(`${myName}ãŒ ${currentRank}ä½ ã§ã‚ãŒã‚Šã¾ã—ãŸï¼`, 'public');

                let totalPlayers = gameState.playerOrder.length;
                if (currentRank >= totalPlayers - 1) {
                     updates[`rooms/${currentRoom}/status`] = "finished";
                     await pushLog(`å…¨é †ä½ãŒç¢ºå®šã—ã¾ã—ãŸï¼`, 'public');
                     let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     if(loserId) updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                }
            }

            let tempRankings = {...(gameState.rankings || {})};
            if(currentHand.length === 0) tempRankings[myId] = 99;

            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await db.ref().update(updates);
            selectedIdx = -1;
        }

        function isMyTurn() {
            if (!gameState || !gameState.playerOrder) return false;
            return gameState.playerOrder[gameState.turnIdx] === myId;
        }
        function getTop(arr) { return (arr && arr.length > 0) ? arr[arr.length-1] : null; }
        function canPlay(card, topCard, isRev) {
            if (!topCard) return true;
            if (card.val === 0 || topCard.val === 0) return true;
            return isRev ? (card.val < topCard.val) : (card.val > topCard.val);
        }
        function shuffle(arr) { for(let i=arr.length-1; i>0; i--){ let j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
        function renderPile(arr) {
            if (!arr || arr.length === 0) return "";
            let c = arr[arr.length-1];
            let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
            let imgUrl = CARD_IMAGES[c.val];
            let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
            return `<div class="card ${c.type}" style="${style} ${imgStyle}">${c.val}</div>`;
        }

        function getActiveCount(data) {
            if(!data || !data.playerOrder) return 0;
            let finishedCount = Object.keys(data.rankings || {}).length;
            return Math.max(1, data.playerOrder.length - finishedCount);
        }

        function getNextActivePlayerIndex(currentIdx, playerOrder, rankings) {
            let next = (currentIdx + 1) % playerOrder.length;
            let loop = 0;
            while (rankings && rankings[playerOrder[next]] && loop < playerOrder.length) {
                next = (next + 1) % playerOrder.length;
                loop++;
            }
            return next;
        }
	// è¿½åŠ : ãƒªã‚»ãƒƒãƒˆå‡¦ç†ã®å®Ÿä½“
        async function execPassReset() {
            // æ—¢å­˜ã®ã€Œãƒ‰ãƒ­ãƒ¼ãªã—ã§ãƒªã‚»ãƒƒãƒˆã€ã™ã‚‹å‡¦ç†ã¸å§”è­²ã—ã¾ã™
            return execPassNoDraw(true);
        }
/* --- ANGLER (é‡£ã‚Šäºº) ã®å®Ÿè£… --- */

// ã‚¹ãƒ†ãƒƒãƒ—1: æ‰‹æœ­ã‹ã‚‰é™¤å¤–ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶
function activateAngler() {
    let hand = gameState.hands[myId] || [];
    if(hand.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "æ‰‹æœ­ãŒãªã„ãŸã‚ç™ºå‹•ã§ãã¾ã›ã‚“");
    
    // å¢“åœ°ãŒç©ºã£ã½ã‹ç¢ºèªï¼ˆæ‹¾ã†ã‚‚ã®ãŒãªã„ã¨æã™ã‚‹ã ã‘ãªã®ã§è­¦å‘Šã€ã§ã‚‚ãƒ«ãƒ¼ãƒ«ä¸Šã¯ç™ºå‹•ã§ããã†ã ãŒä¸€å¿œãƒã‚§ãƒƒã‚¯ï¼‰
    let gn = gameState.graveNum || [];
    let gs = gameState.graveSym || [];
    if(gn.length === 0 && gs.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "å¢“åœ°ã«ã‚«ãƒ¼ãƒ‰ãŒãªã„ãŸã‚é‡£ã‚Œã¾ã›ã‚“");

    let html = `<p>ã‚¨ã‚µã¨ã—ã¦é™¤å¤–ã™ã‚‹æ‰‹æœ­ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
    hand.forEach((c, i) => {
        // ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºç”¨ã®å…±é€šå‡¦ç†ï¼ˆç”»åƒãªã©ï¼‰
        let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // ã‚¯ãƒªãƒƒã‚¯ã§ã‚¹ãƒ†ãƒƒãƒ—2ã¸
        html += `<div class="card ${c.type}" style="${style}" onclick="anglerStep2(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("é‡£ã‚Šäºº: ã‚¨ã‚µé¸æŠ", html);
}

// ã‚¹ãƒ†ãƒƒãƒ—2: å¢“åœ°ã‹ã‚‰æ‹¾ã†ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶
function anglerStep2(excludeIdx) {
    let gn = gameState.graveNum || [];
    let gs = gameState.graveSym || [];
    
    let html = `<p>å¢“åœ°ã‹ã‚‰é‡£ã‚Šä¸Šã’ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list" style="justify-content:flex-start;">`;
    
    // æ•°å­—å¢“åœ°
    gn.forEach((c, i) => {
        let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
        html += `<div class="card num" style="${style}" onclick="execAngler(${excludeIdx}, 'num', ${i})">${c.val}<span style="font-size:8px; display:block;"></span></div>`;
    });
    // è¨˜å·å¢“åœ°
    gs.forEach((c, i) => {
        let cImg = CARD_IMAGES[c.val];
        let style = cImg ? `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;` : '';
        html += `<div class="card sym" style="${style}" onclick="execAngler(${excludeIdx}, 'sym', ${i})">${c.val}</div>`;
    });
    
    html += `</div>`;
    openModal("é‡£ã‚Šäºº: é‡£é­šé¸æŠ", html);
}

// ã‚¹ãƒ†ãƒƒãƒ—3: å®Ÿè¡Œ
async function execAngler(excludeIdx, targetType, targetGraveIdx) {
    closeModal();
    let updates = {};
    
    // ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let gn = [...(gameState.graveNum || [])];
    let gs = [...(gameState.graveSym || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 1. æ‰‹æœ­ã‚’é™¤å¤–
    let excludedCard = hand.splice(excludeIdx, 1)[0];
    excl.push(excludedCard);

    // 2. å¢“åœ°ã‹ã‚‰å›å
    let pickedCard;
    if (targetType === 'num') {
        pickedCard = gn.splice(targetGraveIdx, 1)[0];
    } else {
        pickedCard = gs.splice(targetGraveIdx, 1)[0];
    }
    hand.push(pickedCard);
    hand = sortCards(hand); // æ‰‹æœ­æ•´ç†

    // 3. ãƒ‡ãƒ¼ã‚¿æ›´æ–°æº–å‚™
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    updates[`rooms/${currentRoom}/graveNum`] = gn;
    updates[`rooms/${currentRoom}/graveSym`] = gs;
    
    // ä½¿ç”¨æ¸ˆã¿ãƒ•ãƒ©ã‚°ON
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ãƒ­ã‚°
    await pushLog(`${myName}ãŒ[é‡£ã‚Šäºº]ã‚’ç™ºå‹•ï¼æ‰‹æœ­ã‚’é™¤å¤–ã—ã¦å¢“åœ°ã® [${pickedCard.val}] ã‚’é‡£ã‚Šä¸Šã’ã¾ã—ãŸ`, 'public');
    //playSoundEffect('SKILL'); 

    // 4. ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- FORTUNE TELLER (å ã„å¸«) ã®å®Ÿè£… --- */
// ä¿®æ­£ç‰ˆ: ãƒ­ã‚°ã«è©³ç´°ã‚’æ®‹ã™æ©Ÿèƒ½ã‚’è¿½åŠ 

async function activateFortuneTeller() {
    // 1. ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æƒ…å ±ã‚’åé›†
    let html = `<div style="text-align:left;">`;
    let logText = ``; // â˜…ãƒ­ã‚°ä¿å­˜ç”¨ã®ãƒ†ã‚­ã‚¹ãƒˆ
    
    const pIds = gameState.playerOrder;
    
    pIds.forEach(pid => {
        if (pid === myId) return; // è‡ªåˆ†ã¯ã‚¹ã‚­ãƒƒãƒ—

        const pName = gameState.players[pid].name;
        const pRole = gameState.roles[pid];
        const pRoleJP = (ROLE_INFO[pRole]) ? ROLE_INFO[pRole].jp : pRole;
        const pHand = gameState.hands[pid] || [];

        // æ‰‹æœ­ã®å†…å®¹ï¼ˆè¡¨ç¤ºç”¨HTMLï¼‰
        let handHtml = pHand.map(c => {
             // ç”»åƒãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
             let imgUrl = CARD_IMAGES[c.val];
             
             // å…±é€šã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå°ã•ã‚ã®ã‚«ãƒ¼ãƒ‰ã«ã™ã‚‹ï¼‰
             let baseStyle = "display:inline-block; width:30px; height:45px; border-radius:4px; margin:2px; vertical-align:middle; line-height:45px; text-align:center; font-weight:bold; border:1px solid #ccc; background:#fafafa; color:#333; position:relative;";
             
             // ç”»åƒãŒã‚ã‚‹å ´åˆï¼ˆè¨˜å·ãªã©ï¼‰ï¼šèƒŒæ™¯ç”»åƒã«ã—ã¦æ–‡å­—ã‚’æ¶ˆã™
             if (imgUrl) {
                 return `<span class="card ${c.type}" style="${baseStyle} background-image:url('${imgUrl}'); background-size:cover; color:transparent; border:none;">${c.val}</span>`;
             }
             
             // ç”»åƒãŒãªã„å ´åˆï¼ˆæ•°å­—ãªã©ï¼‰ï¼šæ•°å­—ã‚’è¡¨ç¤º
             // æ•°å­—ã®ã€Œ0ã€ã ã‘ã¯ç´«è‰²ã«ã™ã‚‹
             if (c.val == 0) {
                 return `<span class="card ${c.type}" style="${baseStyle} border:2px solid #ab47bc; color:#8e24aa; background:#f3e5f5;">${c.val}</span>`;
             }
             
             // æ™®é€šã®æ•°å­—
             return `<span class="card ${c.type}" style="${baseStyle}">${c.val}</span>`;
        }).join("");

        // æ‰‹æœ­ã®å†…å®¹ï¼ˆãƒ­ã‚°ä¿å­˜ç”¨ã®ç°¡æ˜“ãƒ†ã‚­ã‚¹ãƒˆï¼‰
        let handText = pHand.map(c => c.val).join(", ");

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨HTMLä½œæˆ
        html += `
            <div style="margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
                <div style="font-weight:bold; color:#fdd835;">${pName}</div>
                <div style="font-size:12px;">å½¹è·: <span style="color:#e1bee7;">${pRoleJP}</span></div>
                <div style="font-size:12px;">æ‰‹æœ­: ${handHtml}</div>
            </div>
        `;

        // â˜…ãƒ­ã‚°ç”¨ãƒ†ã‚­ã‚¹ãƒˆä½œæˆï¼ˆæ”¹è¡Œã‚’å…¥ã‚Œã¦è¦‹ã‚„ã™ãï¼‰
        logText += `[${pName}] å½¹è·:${pRoleJP} / æ‰‹æœ­:${handText}<br>`;
    });

    html += `</div><p style="font-size:12px; color:#aaa;">â€»ã“ã®å†…å®¹ã¯ãƒ­ã‚°(ãƒãƒ£ãƒƒãƒˆå±¥æ­´)ã«ã‚‚ä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚</p>`;

    // 2. ã‚µãƒ¼ãƒãƒ¼æ›´æ–°
    let updates = {};
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true; // ä½¿ç”¨æ¸ˆã¿ã«ã™ã‚‹
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    
    // å…¨å“¡ã¸ã®é€šçŸ¥ï¼ˆä¸­èº«ã¯è¨€ã‚ãªã„ï¼‰
    await pushLog(`${myName}ãŒ[å ã„å¸«]ã‚’ç™ºå‹•ï¼æ°´æ™¶ç‰ã‚’è¦—ãè¾¼ã¿ã¾ã—ãŸ...`, 'public');
    
    // â˜…è‡ªåˆ†ã ã‘ã®ãƒ¡ãƒ¢ã¨ã—ã¦è©³ç´°ã‚’ä¿å­˜ï¼ˆã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼ï¼‰
    // type='private', targetId=myId ã«ã™ã‚‹ã“ã¨ã§è‡ªåˆ†ã«ã—ã‹è¦‹ãˆã¾ã›ã‚“
    await pushLog(`ã€å ã„çµæœãƒ¡ãƒ¢ã€‘<br>${logText}`, 'private', myId);
    
    //playSoundEffect('SKILL'); 
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ›´æ–°
    await db.ref().update(updates);

    // 3. ãƒ¢ãƒ¼ãƒ€ãƒ«ã§æƒ…å ±ã‚’è¡¨ç¤º
    openModal("å ã„å¸«: åƒé‡Œçœ¼", html);
}

/* --- THIEF (ç›—è³Š) ã®å®Ÿè£… (ä¿®æ­£ç‰ˆ) --- */
// ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚’2å›ã¾ã§è¡Œãˆã‚‹ (1å›ã§ã‚„ã‚ã¦ã‚‚OK)

// 1. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
/* --- THIEF (ç›—è³Š) ã®å®Ÿè£… (ãƒãƒæŠœãå½¢å¼) --- */
// 1. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ -> 2. å¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠ(New) -> 3. æ¸¡ã™ã‚«ãƒ¼ãƒ‰é¸æŠ -> 4. å®Ÿè¡Œ

// 1. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
function activateThief(count = 1) {
    let html = `<p><strong>ã€ç›—è³Šã‚¹ã‚­ãƒ« ${count}/2å›ç›®ã€‘</strong><br>ãƒˆãƒ¬ãƒ¼ãƒ‰ã™ã‚‹ç›¸æ‰‹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>`;
    
    const pIds = gameState.playerOrder;
    pIds.forEach(pid => {
        if (pid === myId) return; 
        if (gameState.rankings && gameState.rankings[pid]) return; 

        const pName = gameState.players[pid].name;
        // å…¬é–‹æƒ…å ±ã®è¡¨ç¤ºï¼ˆè­¦å¯Ÿå®˜ãªã©ã§ãƒãƒ¬ã¦ã„ã‚‹å ´åˆï¼‰
        const hand = gameState.hands[pid] || [];
        const handLen = hand.length;
        let revealed = hand.filter(c => c.isOpen).map(c => c.val).join(", ");
        let revealedInfo = revealed ? `<br><span style="font-size:11px; color:#000000;">(å…¬é–‹: ${revealed})</span>` : "";

        html += `<button onclick="thiefSelectTake('${pid}', ${count})" style="display:block; width:100%; margin:5px 0; padding:10px;">
            ${pName} (æ‰‹æœ­${handLen}æš)${revealedInfo}
        </button>`;
    });

    openModal(`ç›—è³Š: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ (${count}å›ç›®)`, html);
}

// 2. â˜…è¿½åŠ : å¥ªã†ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶ï¼ˆè£å‘ãã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼‰
/* --- ä¿®æ­£ç‰ˆ: ç›—è³Š (ãƒãƒƒã‚«ãƒ¼å¯¾å¿œ) --- */

// å¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠ
function thiefSelectTake(targetId, count) {
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p>ç›¸æ‰‹ã®æ‰‹æœ­ã‹ã‚‰<strong>å¥ªã†ã‚«ãƒ¼ãƒ‰</strong>ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚<br>
                <span style="font-size:11px;">(å…¬é–‹ã‚«ãƒ¼ãƒ‰ã¯è¦‹ãˆã¾ã™)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "?";
        let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        let cssClass = "card"; 
        let onClick = `onclick="thiefSelectGive('${targetId}', ${c.originalIndex}, ${count})"`;

        // â˜…ãƒãƒƒã‚«ãƒ¼å¯¾å¿œ
        if (c.isHacked) {
            cssClass += " hacked";
            style = "cursor:not-allowed; border:1px solid #555; background:#333;";
            content = "ğŸ”’"; 
            onClick = "";
        }
        else if (c.isOpen) {
            cssClass = `card ${c.type}`;
            content = c.val;
            style = "cursor:pointer; "; 
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
            else if (c.val === 0) style += `border:2px solid #ab47bc; color:#8e24aa; background:#f3e5f5;`;
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });
    
    openModal(`ç›—è³Š: ç•¥å¥ªé¸æŠ (${count}å›ç›®)`, html);
}

// æ¸¡ã™ã‚«ãƒ¼ãƒ‰é¸æŠ
function thiefSelectGive(targetId, takeIdx, count) {
    const myHand = sortCards(deepCopy(gameState.hands[myId] || []));

    let html = `<p>ç›¸æ‰‹ã«æŠ¼ã—ä»˜ã‘ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
    
    myHand.forEach((c, idx) => {
        let style = "";
        if (c.val === 0) style = 'color:#6a1b9a; border-color:#6a1b9a;';
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execThiefTrade('${targetId}', ${idx}, ${takeIdx}, ${count})"`;

        // â˜…ãƒãƒƒã‚«ãƒ¼å¯¾å¿œ
        if (c.isHacked) {
            cssClass += " hacked";
            onClick = "";
        }

        html += `<div class="${cssClass}" style="${style} cursor:pointer;" ${onClick}>${c.val}</div>`;
    });
    
    html += `</div>`;
    html += `<div style="margin-top:15px;"><button onclick="thiefSelectTake('${targetId}', ${count})" style="background:#90a4ae; padding:8px 16px; font-size:12px;">æˆ»ã‚‹</button></div>`;

    openModal(`ç›—è³Š: è­²æ¸¡é¸æŠ (${count}å›ç›®)`, html);
}

// 3. è‡ªåˆ†ã®æ‰‹æœ­ã‹ã‚‰ã€ŒæŠ¼ã—ä»˜ã‘ã‚‹ã‚«ãƒ¼ãƒ‰ã€ã‚’é¸ã¶
function thiefSelectGive(targetId, takeIdx, count) {
    const myHand = sortCards(deepCopy(gameState.hands[myId] || []));

    let html = `<p>ç›¸æ‰‹ã«æŠ¼ã—ä»˜ã‘ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
    
    myHand.forEach((c, idx) => {
        let style = "";
        if (c.val === 0) style = 'color:#6a1b9a; border-color:#6a1b9a;';
        
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // å®Ÿè¡Œé–¢æ•°ã¸ (takeIdx ã‚‚æ¸¡ã™)
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                      onclick="execThiefTrade('${targetId}', ${idx}, ${takeIdx}, ${count})">
                      ${c.val}
                 </div>`;
    });
    
    html += `</div>`;
    // æˆ»ã‚‹ãƒœã‚¿ãƒ³
    html += `<div style="margin-top:15px;"><button onclick="thiefSelectTake('${targetId}', ${count})" style="background:#90a4ae; padding:8px 16px; font-size:12px;">æˆ»ã‚‹</button></div>`;

    openModal(`ç›—è³Š: è­²æ¸¡é¸æŠ (${count}å›ç›®)`, html);
}

// 4. ãƒˆãƒ¬ãƒ¼ãƒ‰å®Ÿè¡Œå‡¦ç† (ãƒ©ãƒ³ãƒ€ãƒ ã§ã¯ãªãæŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§)
async function execThiefTrade(targetId, giveIdx, takeIdx, count) {
    closeModal();
    const updates = {};
    
    let myHand = [...(gameState.hands[myId] || [])];
    let targetHand = [...(gameState.hands[targetId] || [])]; // ç›¸æ‰‹ã®æ‰‹æœ­(ã‚½ãƒ¼ãƒˆæ¸ˆã¿)
    
    if (targetHand.length === 0) {
        showInfoModal("ã‚¨ãƒ©ãƒ¼", "ç›¸æ‰‹ã®æ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“ï¼");
        return;
    }

    // --- ãƒˆãƒ¬ãƒ¼ãƒ‰å®Ÿè¡Œ ---
    // è‡ªåˆ†ãŒå‡ºã™ã‚«ãƒ¼ãƒ‰
    const giveCard = myHand.splice(giveIdx, 1)[0]; 
    // ç›¸æ‰‹ã‹ã‚‰å¥ªã†ã‚«ãƒ¼ãƒ‰ (æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹)
    const receiveCard = targetHand.splice(takeIdx, 1)[0]; 
    
    myHand.push(receiveCard); 
    targetHand.push(giveCard); 

    // ã‚«ãƒ¼ãƒ‰ç§»å‹•å¾Œã®æ•´ç†
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);
    
    const targetName = gameState.players[targetId].name;
    
    // ãƒ­ã‚°å‡ºåŠ›
    await pushLog(`${myName}ãŒ[ç›—è³Š]ã§${targetName}ã¨ãƒˆãƒ¬ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼(${count}å›ç›®)`, 'public');
    await pushLog(`${targetName}ã‹ã‚‰ [${receiveCard.val}] ã‚’ç›—ã¿ã€ [${giveCard.val}] ã‚’å¥ªã„ã¾ã—ãŸã€‚`, 'private', myId);
    await pushLog(`${myName}ã« [${receiveCard.val}] ã‚’ç›—ã¾ã‚Œã€ [${giveCard.val}] ã‚’æ¸¡ã•ã‚Œã¾ã—ãŸã€‚`, 'private', targetId);

    // é€šçŸ¥
    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(ç›—è³Š)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };

    // éŸ³ï¼ˆ2å›ç›®ã¯å°‚ç”¨éŸ³ï¼‰
    if (count === 2) {
         const skillSound = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_THIEF']) ? 'SKILL_THIEF' : 'SKILL';
         updates[`rooms/${currentRoom}/lastSound`] = { type: skillSound, id: Date.now() };
    }

    // 1å›ç›®ãªã‚‰ä½¿ç”¨æ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    if (count === 1) {
        let actList = {...(gameState.activatedList || {})};
        actList[myId] = true; 
        updates[`rooms/${currentRoom}/activatedList`] = actList;
    }

    await db.ref().update(updates);

    // æ¬¡ã®è¡Œå‹•ç¢ºèª
    if (count === 1) {
        let confirmHtml = `
            <p>1å›ç›®ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸã€‚<br>
            <strong>å¥ªã£ãŸã‚«ãƒ¼ãƒ‰: ${receiveCard.val}</strong><br>
            ç¶šã‘ã¦2å›ç›®ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚’è¡Œã„ã¾ã™ã‹ï¼Ÿ
            </p>
            <button onclick="activateThief(2)" style="width:100%; padding:15px; background:#d32f2f; color:white; font-weight:bold; margin-bottom:10px;">
                ã¯ã„ (ã‚‚ã†ä¸€åº¦ç›—ã‚€)
            </button>
            <button onclick="endThiefTurn()" style="width:100%; padding:15px; background:#444; color:white;">
                ã„ã„ãˆ (ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã™ã‚‹)
            </button>
        `;
        openModal("ç›—è³Š: è¿½æ’ƒã®é¸æŠ", confirmHtml);
    } else {
        endThiefTurn();
    }
}
// 4. ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†
async function endThiefTurn() {
    closeModal();
    
    // â˜…ä¿®æ­£: gameState.turnIdx ã‚’ä½¿ã†ã‚ˆã†ã«å¤‰æ›´ï¼ˆå¿µã®ãŸã‚ï¼‰
    let currentTurnIdx = (typeof turnIdx !== 'undefined') ? turnIdx : gameState.turnIdx;
    let nextIdx = (currentTurnIdx + 1) % gameState.playerOrder.length;
    
    let updates = {};
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
    updates[`rooms/${currentRoom}/passCount`] = 0; 
    updates[`rooms/${currentRoom}/lastAction`] = "THIEF_END";

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await db.ref().update(updates);
    await pushLog(`${myName}ã®ç›—è³Šã‚¿ãƒ¼ãƒ³ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚`, 'public');
}

/* --- HUNTER (ç‹©äºº) ã®å®Ÿè£… (UIæ”¹å–„ç‰ˆ) --- */

function activateHunter() {
    let deckSym = gameState.deckSym || [];
    let hand = gameState.hands[myId] || [];
    
    if (deckSym.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "è¨˜å·å±±æœ­ãŒç©ºã§ã™ã€‚");

    let html = `
        <p style="font-size:12px;">
            è¨˜å·å±±æœ­ã®ä¸­èº«ã‚’ã™ã¹ã¦ç¢ºèªã§ãã¾ã™ã€‚<br>
            äº¤æ›ã—ãŸã„ã‚«ãƒ¼ãƒ‰ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã€<strong>ã€Œæ‰‹æœ­ã€ã¨ã€Œå±±æœ­ã€ã‚’åŒã˜æšæ•°</strong>ã«ã—ã¦ãã ã•ã„ã€‚<br>
            <span style="color:#d32f2f;">â€»ã“ã®ç”»é¢ã‚’é–‹ã„ãŸæ™‚ç‚¹ã§ã‚¹ã‚­ãƒ«ä½¿ç”¨æ¸ˆã¿ã¨ãªã‚Šã¾ã™ã€‚</span>
        </p>
        
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
            <div style="width:48%; background:rgba(0,0,0,0.05); border-radius:8px; padding:5px;">
                <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; font-size:12px;">è‡ªåˆ†ã®æ‰‹æœ­ (é™¤å¤–)</div>
                <div id="hunter-hand-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>
            </div>

            <div style="width:48%; background:rgba(0,0,0,0.05); border-radius:8px; padding:5px;">
                <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; font-size:12px;">è¨˜å·å±±æœ­ (å…¥æ‰‹)</div>
                <div id="hunter-deck-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>
            </div>
        </div>

        <div style="margin-top:15px; text-align:center;">
            <p id="hunter-msg" style="color:#d32f2f; font-size:12px; font-weight:bold;">æšæ•°ãŒä¸€è‡´ã—ã¦ã„ã¾ã›ã‚“</p>
            
            <button onclick="execHunterSwap()" id="btn-hunter-exec" disabled 
                style="background:#ccc; color:#fff; padding:10px 30px; font-weight:bold; border-radius:20px;">äº¤æ›ã—ã¦çµ‚äº†</button>
            <br>
            <button onclick="execHunterSwap(true)" style="background:#546e7a; color:#fff; margin-top:10px; padding:8px 20px; font-size:12px; border-radius:20px;">
                äº¤æ›ã›ãšã«çµ‚äº†
            </button>
        </div>
    `;

    openModal("ç‹©äºº: æ­¦å™¨ã®é¸å®š", html);
    document.getElementById("modal-footer").innerHTML = ""; // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³å‰Šé™¤

    // --- ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆç”Ÿæˆé–¢æ•° ---
    const createCardDiv = (c, i, type) => {
        let imgUrl = CARD_IMAGES[c.val];
        // åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ«
        let style = "width:40px; height:60px; font-size:10px; cursor:pointer; transition:transform 0.1s; border:1px solid #999;";
        if (imgUrl) style += `background-image:url('${imgUrl}'); color:transparent; border:none;`;
        
        // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ: toggleHunterSelect(è¦ç´ , ã‚¿ã‚¤ãƒ—, ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹)
        return `<div class="card ${c.type} hunter-item" id="hunter-${type}-${i}" 
                    data-idx="${i}" data-type="${type}"
                    style="${style}" 
                    onclick="toggleHunterSelect(this)">
                    ${c.val}
                </div>`;
    };

    // 1. æ‰‹æœ­ãƒªã‚¹ãƒˆ (è¨˜å·ã®ã¿)
    let handHtml = "";
    hand.forEach((c, i) => {
        if (c.type === 'sym') handHtml += createCardDiv(c, i, 'hand');
    });
    document.getElementById("hunter-hand-list").innerHTML = handHtml;

    // 2. å±±æœ­ãƒªã‚¹ãƒˆ (ã™ã¹ã¦)
    let deckHtml = "";
    deckSym.forEach((c, i) => {
        deckHtml += createCardDiv(c, i, 'deck');
    });
    document.getElementById("hunter-deck-list").innerHTML = deckHtml;
}

// ã‚«ãƒ¼ãƒ‰é¸æŠã®åˆ‡ã‚Šæ›¿ãˆ & ãƒã‚§ãƒƒã‚¯
function toggleHunterSelect(el) {
    // ã‚¯ãƒ©ã‚¹ "selected-hunter" ã‚’ã¤ã‘å¤–ã—ã™ã‚‹
    if (el.classList.contains('selected-hunter')) {
        el.classList.remove('selected-hunter');
        el.style.border = el.style.backgroundImage ? "none" : "1px solid #999";
        el.style.transform = "scale(1)";
        el.style.boxShadow = "none";
    } else {
        el.classList.add('selected-hunter');
        // é¸æŠæ™‚ã®è¦‹ãŸç›® (ã‚ªãƒ¬ãƒ³ã‚¸è‰²ã®å¤ªæ  + å°‘ã—æ‹¡å¤§)
        el.style.border = "3px solid #ff9800";
        el.style.transform = "scale(1.1)";
        el.style.boxShadow = "0 0 5px rgba(255, 152, 0, 0.8)";
    }
    
    checkHunterCount(); // ãƒœã‚¿ãƒ³çŠ¶æ…‹æ›´æ–°
}

// æšæ•°ãƒã‚§ãƒƒã‚¯é–¢æ•°
function checkHunterCount() {
    // ã‚¯ãƒ©ã‚¹åã§é¸æŠã•ã‚Œã¦ã„ã‚‹è¦ç´ ã‚’æ•°ãˆã‚‹
    let handSel = document.querySelectorAll('#hunter-hand-list .selected-hunter').length;
    let deckSel = document.querySelectorAll('#hunter-deck-list .selected-hunter').length;
    
    let btn = document.getElementById('btn-hunter-exec');
    let msg = document.getElementById('hunter-msg');

    if (handSel > 0 && handSel === deckSel) {
        btn.disabled = false;
        btn.style.background = "#e65100"; // ç‹©äººã£ã½ã„ã‚ªãƒ¬ãƒ³ã‚¸
        msg.innerText = `OK! (${handSel}æšäº¤æ›)`;
        msg.style.color = "#e65100";
    } else {
        btn.disabled = true;
        btn.style.background = "#ccc";
        if (handSel === 0 && deckSel === 0) {
            msg.innerText = "äº¤æ›ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„";
        } else {
            msg.innerText = `æšæ•°ãŒä¸€è‡´ã—ã¦ã„ã¾ã›ã‚“ (æ‰‹æœ­:${handSel} vs å±±æœ­:${deckSel})`;
        }
        msg.style.color = "#d32f2f";
    }
}

// å®Ÿè¡Œå‡¦ç†ï¼ˆå±±æœ­å¾ªç’°ãƒ»ã‚·ãƒ£ãƒƒãƒ•ãƒ«è¿½åŠ ç‰ˆï¼‰
async function execHunterSwap(isSkip = false) {
    closeModal();
    
    let updates = {};
    let actList = {...(gameState.activatedList || {})};

    if (!isSkip) {
        // é¸æŠã•ã‚ŒãŸè¦ç´ ã‚’å–å¾—
        let handEls = document.querySelectorAll('#hunter-hand-list .selected-hunter');
        let deckEls = document.querySelectorAll('#hunter-deck-list .selected-hunter');

        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–ã‚Šå‡ºã—ã¦é™é †ã‚½ãƒ¼ãƒˆ
        let handIndices = Array.from(handEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);
        let deckIndices = Array.from(deckEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);

        let hand = sortCards(deepCopy(gameState.hands[myId]));
        let deckSym = [...(gameState.deckSym || [])];
        let excl = [...(gameState.exclusion || [])]; // ä»Šå›ã¯ä½¿ã„ã¾ã›ã‚“ãŒå¿µã®ãŸã‚

        let outNames = [];
        let inNames = [];

        // 1. æ‰‹æœ­ã‹ã‚‰å‡ºã™ï¼ˆå±±æœ­ã«æˆ»ã™ï¼‰
        handIndices.forEach(idx => {
            let c = hand.splice(idx, 1)[0];
            // excl.push(c); // â† å…ƒã®ã€Œé™¤å¤–ã€å‡¦ç†
            deckSym.push(c); // â˜…å¤‰æ›´: è¨˜å·å±±æœ­ã«è¿½åŠ ï¼
            outNames.push(c.val);
        });

        // 2. å±±æœ­ã‹ã‚‰å–ã‚‹
        deckIndices.forEach(idx => {
            let c = deckSym.splice(idx, 1)[0];
            hand.push(c);
            inNames.push(c.val);
        });
        
        // â˜…è¿½åŠ : å±±æœ­ã®ä¸­èº«ãŒå¤‰ã‚ã£ãŸã®ã§ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹
        // (ã“ã‚Œã‚’ã—ãªã„ã¨ã€æˆ»ã—ãŸã‚«ãƒ¼ãƒ‰ãŒä¸€ç•ªä¸‹ã‚„ä¸Šã«å›ºã¾ã£ã¦ã—ã¾ã†ãŸã‚)
        shuffle(deckSym);

        // æ‰‹æœ­ã‚’æ•´ç†
        hand = sortCards(hand);

        updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
        updates[`rooms/${currentRoom}/deckSym`] = deckSym; 
        // updates[`rooms/${currentRoom}/exclusion`] = excl; // é™¤å¤–å ´ã¯å¤‰ã‚ã‚‰ãªã„ã®ã§æ›´æ–°ä¸è¦ï¼ˆã¾ãŸã¯ãã®ã¾ã¾æ›´æ–°ã—ã¦ã‚‚OKï¼‰
        
        await pushLog(`${myName}ãŒ[ç‹©äºº]ã‚’ç™ºå‹•ï¼æ‰‹æœ­ [${handIndices.length}] æšã‚’è¨˜å·å±±æœ­ã¨äº¤æ›ã—ã¾ã—ãŸã€‚`, 'public');
        await pushLog(`ã€ç‹©ã‚Šã®æˆæœã€‘<br>ä½¿ç”¨æ­¦å™¨(å±±æœ­ã¸): ${outNames.join(', ')}<br>ç²ç‰©: ${inNames.join(', ')}`, 'private', myId);

    } else {
        await pushLog(`${myName}ãŒ[ç‹©äºº]ã‚’ç™ºå‹•ï¼äº¤æ›ã›ãšã«çµ‚äº†ã—ã¾ã—ãŸã€‚`, 'public');
        await pushLog(`ã€ç‹©ã‚Šã®æˆæœã€‘<br>ãªã—`, 'private', myId);
    }

    // å…±é€šå‡¦ç†
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    //playSoundEffect('SKILL');
    await db.ref().update(updates);
}

/* --- GAMBLER (è³­åšå¸«) ã®å®Ÿè£… --- */
// åŠ¹æœ: å±±æœ­ã®æ•°å­—ã‚’äºˆæƒ³ã—ã€å½“ãŸã‚Œã°æ‰‹æœ­ã‚’æ¨ã¦ã€å¤–ã‚Œã‚Œã°ãƒšãƒŠãƒ«ãƒ†ã‚£ã€‚

// 1. äºˆæƒ³ã‚’é¸æŠã™ã‚‹ç”»é¢
function activateGambler() {
    let deck = gameState.deckNum || [];
    if (deck.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "æ•°å­—å±±æœ­ãŒã‚ã‚Šã¾ã›ã‚“");

    let html = `
        <p>æ•°å­—å±±æœ­ã®ä¸€ç•ªä¸Šã‚’äºˆæƒ³ã—ã¦ãã ã•ã„ã€‚<br>
        <span style="font-size:12px; color:#666;">â€»å®Ÿè¡Œã™ã‚‹ã¨å…¨å“¡ã«é€šçŸ¥ã•ã‚Œã¾ã™</span>
        </p>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <button onclick="execGamblerGuess('A')" style="padding:15px; background:#4fc3f7; color:#01579b; font-weight:bold; border-radius:8px;">
                A: å°ã•ã„ (1, 2, 3, 4)<br>
                <span style="font-size:10px;">çš„ä¸­: æ‰‹æœ­1æšæ¨ã¦ / å¤–ã‚Œ: ãã®ã‚«ãƒ¼ãƒ‰ç²å¾—</span>
            </button>
            <button onclick="execGamblerGuess('B')" style="padding:15px; background:#ffb74d; color:#e65100; font-weight:bold; border-radius:8px;">
                B: å¤§ãã„ (6, 7, 8, 9)<br>
                <span style="font-size:10px;">çš„ä¸­: æ‰‹æœ­1æšæ¨ã¦ / å¤–ã‚Œ: ãã®ã‚«ãƒ¼ãƒ‰ç²å¾—</span>
            </button>
            <button onclick="execGamblerGuess('C')" style="padding:15px; background:#ba68c8; color:#4a148c; font-weight:bold; border-radius:8px;">
                C: å‘½çŸ¥ã‚‰ãš (0, 5)<br>
                <span style="font-size:10px;">çš„ä¸­: æ‰‹æœ­2æšæ¨ã¦ / å¤–ã‚Œ: ç²å¾— + 1ãƒ‰ãƒ­ãƒ¼</span>
            </button>
        </div>
    `;
    openModal("è³­åšå¸«: é‹å‘½ã®é¸æŠ", html);
}

// --- è³­åšå¸«ï¼šé€ä¿¡å‡¦ç†ï¼ˆã‚¹ã‚¯ã‚¤ãƒ¼ã‚ºå¯¾å¿œç‰ˆï¼‰ ---
async function execGamblerGuess(type) {
    closeModal();
    let updates = {};
    let deck = [...(gameState.deckNum || [])];
    
    let card = deck.pop(); 
    let val = card.val;
    let win = false;

    // åˆ¤å®š
    let guessText = "";
    if (type === 'A') {
        if ([1,2,3,4].includes(val)) win = true;
        guessText = "å°ã•ã„ [1-4]";
    } else if (type === 'B') {
        if ([6,7,8,9].includes(val)) win = true;
        guessText = "å¤§ãã„ [6-9]";
    } else if (type === 'C') {
        if ([0,5].includes(val)) win = true;
        guessText = "å‘½çŸ¥ã‚‰ãš [0, 5]";
    }

    // --- â˜…æ¼”å‡ºãƒ‡ãƒ¼ã‚¿é€ä¿¡ ---
    updates[`rooms/${currentRoom}/effect`] = {
        guessTitle: guessText,
        cardVal: val,
        sub: win ? "WIN!!" : "LOSE...",
        color: win ? "#d50000" : "#333",
        isWin: win,
        guessType: type, // â˜…è¿½åŠ : ã“ã‚Œã§ã€Œå¤§å½“ãŸã‚Šã€ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹
        timestamp: firebase.database.ServerValue.TIMESTAMP
    };
    // ------------------------

    await pushLog(`${myName}ãŒ[è³­åšå¸«]ã‚’ç™ºå‹•ï¼: ${guessText} -> çµæœã¯...?`, 'public');

    // ãƒ‡ãƒ¼ã‚¿æ›´æ–°
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/deckNum`] = deck;

    //playSoundEffect('SKILL'); // æ¼”å‡ºé–‹å§‹ã®åˆå›³éŸ³

    // DBæ›´æ–°ï¼ˆã“ã‚Œã§å…¨å“¡ã®ç”»é¢ã§æ¼”å‡ºãŒå§‹ã¾ã‚‹ï¼‰
    await db.ref().update(updates);

    // çµæœå‡¦ç†ã®åˆ†å²ï¼ˆæ¼”å‡ºæ™‚é–“ã®5ç§’+ä½™éŸ»3ç§’ = 8ç§’å¾…ã£ã¦ã‹ã‚‰ç”»é¢ã‚’å‡ºã™ï¼‰
    if (win) {
        let discardCount = (type === 'C') ? 2 : 1;
        setTimeout(() => {
            gamblerSelectDiscard(discardCount);
        }, 6000); // çµæœã‚¹ã‚¿ãƒ³ãƒ—ãŒå‡ºãŸ1ç§’å¾Œãã‚‰ã„ã«æ“ä½œç”»é¢ã¸

    } else {
        // ãƒã‚ºãƒ¬å‡¦ç†
        let hand = sortCards(deepCopy(gameState.hands[myId]));
        hand.push(card);
        if (type === 'C' && deck.length > 0) {
            let penaltyCard = deck.pop();
            hand.push(penaltyCard);
            updates[`rooms/${currentRoom}/deckNum`] = deck;
        }
        hand = sortCards(hand);
        
        // é…å»¶æ›´æ–°ã®ãŸã‚ã«å†åº¦updatesã‚’ä½œã‚‹å¿…è¦ãŒã‚ã‚‹
        // ï¼ˆæœ€åˆã®updateã§DBã¯æ›¸ãæ›ã‚ã£ã¦ã„ã‚‹ã®ã§ã€ã“ã“ã¯è¿½åŠ å‡¦ç†ï¼‰
        setTimeout(async () => {
            let finalUpdates = {};
            finalUpdates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            finalUpdates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            finalUpdates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await db.ref().update(finalUpdates);
            await pushLog(`çµæœ: [${val}] ã§ã—ãŸã€‚ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’å—ã‘ã¾ã™ã€‚`, 'public');
        }, 6000);
    }
}

// 3. (å‹åˆ©æ™‚) æ¨ã¦ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶ç”»é¢
function gamblerSelectDiscard(count) {
    let hand = sortCards(deepCopy(gameState.hands[myId] || []));
    
    // æ¨ã¦ã‚‹æšæ•°ãŒæ‰‹æœ­ã‚ˆã‚Šå¤šã„å ´åˆã®ã‚±ã‚¢
    if (hand.length < count) count = hand.length;

    let html = `
        <p style="font-size:14px; font-weight:bold; color:#2e7d32;">
            ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼<br>
            æ‰‹æœ­ã‹ã‚‰ <span style="font-size:18px;">${count}æš</span> é¸ã‚“ã§æ¨ã¦ã¦ãã ã•ã„ã€‚
        </p>
        
        <div id="gambler-hand-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>

        <div style="margin-top:15px; text-align:center;">
             <p id="gambler-msg" style="font-size:12px;">ã‚ã¨ ${count} æšé¸ã‚“ã§ãã ã•ã„</p>
            <button onclick="execGamblerDiscard(${count})" id="btn-gambler-exec" disabled 
                style="background:#ccc; color:#fff; padding:10px 30px; border-radius:20px;">æ±ºå®š</button>
        </div>
    `;

    openModal("è³­åšå¸«: å‹åˆ©ã®å ±é…¬", html);
    document.getElementById("modal-footer").innerHTML = ""; 

    // ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆç”Ÿæˆ (ç‹©äººã¨åŒã˜UIã‚’ä½¿ç”¨)
    let handHtml = "";
    hand.forEach((c, i) => {
        let imgUrl = CARD_IMAGES[c.val];
        let style = "width:40px; height:60px; font-size:10px; cursor:pointer; transition:transform 0.1s; border:1px solid #999;";
        if (imgUrl) style += `background-image:url('${imgUrl}'); color:transparent; border:none;`;
        else if(c.val==0) style += `border:2px solid #ab47bc; color:#8e24aa; background:#f3e5f5;`;

        handHtml += `<div class="card ${c.type} gambler-item" data-idx="${i}" 
                    style="${style}" 
                    onclick="toggleGamblerSelect(this, ${count})">
                    ${c.val}
                </div>`;
    });
    document.getElementById("gambler-hand-list").innerHTML = handHtml;
}

// é¸æŠåˆ‡ã‚Šæ›¿ãˆå‡¦ç†
function toggleGamblerSelect(el, maxCount) {
    if (el.classList.contains('selected-gambler')) {
        el.classList.remove('selected-gambler');
        el.style.border = (el.style.backgroundImage) ? "none" : (el.innerText=="0" ? "2px solid #ab47bc" : "1px solid #999");
        el.style.transform = "scale(1)";
    } else {
        // é¸æŠå¯èƒ½æšæ•°ãƒã‚§ãƒƒã‚¯
        let currentSel = document.querySelectorAll('.selected-gambler').length;
        if (currentSel >= maxCount) return; // ã“ã‚Œä»¥ä¸Šé¸ã¹ãªã„

        el.classList.add('selected-gambler');
        el.style.border = "3px solid #2e7d32"; // ç·‘æ 
        el.style.transform = "scale(1.1)";
    }

    // ãƒœã‚¿ãƒ³åˆ¶å¾¡
    let selCount = document.querySelectorAll('.selected-gambler').length;
    let btn = document.getElementById('btn-gambler-exec');
    let msg = document.getElementById('gambler-msg');

    if (selCount === maxCount) {
        btn.disabled = false;
        btn.style.background = "#2e7d32";
        msg.innerText = "OK!";
        msg.style.color = "#2e7d32";
    } else {
        btn.disabled = true;
        btn.style.background = "#ccc";
        msg.innerText = `ã‚ã¨ ${maxCount - selCount} æšé¸ã‚“ã§ãã ã•ã„`;
        msg.style.color = "#333";
    }
}

// 4. (å‹åˆ©æ™‚) æ¨ã¦ã‚‹å®Ÿè¡Œå‡¦ç†
// â†“â†“â†“ execGamblerDiscardé–¢æ•°ã‚’ä¸¸ã”ã¨ã“ã‚Œã«ç½®ãæ›ãˆã¦ãã ã•ã„ â†“â†“â†“
        async function execGamblerDiscard(count) {
            closeModal();
            let updates = {};
            
            let handEls = document.querySelectorAll('.selected-gambler');
            let indices = Array.from(handEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);
            
            let hand = sortCards(deepCopy(gameState.hands[myId]));
            let graveNum = [...(gameState.graveNum || [])];
            let graveSym = [...(gameState.graveSym || [])];
            
            let discardedNames = [];

            // æ‰‹æœ­ã‹ã‚‰æ¨ã¦ã¦ã€ãã‚Œãã‚Œã®å¢“åœ°ã¸
            indices.forEach(idx => {
                let c = hand.splice(idx, 1)[0];
                discardedNames.push(c.val);
                
                if (c.type === 'num') graveNum.push({...c, owner:myId});
                else graveSym.push(c);
            });

            hand = sortCards(hand);

            updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            updates[`rooms/${currentRoom}/graveNum`] = graveNum;
            updates[`rooms/${currentRoom}/graveSym`] = graveSym;
            updates[`rooms/${currentRoom}/passCount`] = 0;

            let tempRankings = {...(gameState.rankings || {})};
            if (hand.length === 0) tempRankings[myId] = 99; 

            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await pushLog(`${myName}ãŒ[è³­åšå¸«]ã®å ±é…¬ã§ [${discardedNames.join(', ')}] ã‚’æ¨ã¦ã¾ã—ãŸï¼`, 'public');
            
            // â˜…é‡è¤‡ã‚¨ãƒ©ãƒ¼å¯¾ç­– & åŒæ™‚å†ç”Ÿå¯¾å¿œ
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = hand.length + myHackedCount;

            let soundList = ['DISCARD'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            // ã‚ãŒã‚Šåˆ¤å®š
            if (hand.length === 0 && myHackedCount === 0) {
                let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                await pushLog(`${myName}ãŒ ${currentRank}ä½ ã§ã‚ãŒã‚Šã¾ã—ãŸï¼`, 'public');
                
                let totalPlayers = gameState.playerOrder.length;
                if (currentRank >= totalPlayers - 1) {
                     updates[`rooms/${currentRoom}/status`] = "finished";
                     await pushLog(`å…¨é †ä½ãŒç¢ºå®šã—ã¾ã—ãŸï¼`, 'public');
                     let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     if(loserId) updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                }
            }

            await db.ref().update(updates);
        }


/* --- ãƒã‚«ãƒ©é¢¨ã‚¹ã‚¯ã‚¤ãƒ¼ã‚ºæ¼”å‡º --- */
function showVisualEffect(data) {
    let overlay = document.getElementById('visual-overlay');
    let guessDiv = document.getElementById('squeeze-guess');
    let contentDiv = document.getElementById('squeeze-content');
    let coverDiv = document.getElementById('squeeze-cover');
    let resultDiv = document.getElementById('squeeze-result');

    // åˆæœŸåŒ–
    guessDiv.innerHTML = `è³­åšå¸«ã®äºˆæƒ³: <br><span style="font-size:32px;">${data.guessTitle}</span>`;
    contentDiv.innerText = data.cardVal;
    
    coverDiv.style.transition = "none";
    coverDiv.style.top = "0%";
    
    resultDiv.style.transform = "translate(-50%, -50%) scale(0)";
    resultDiv.style.opacity = "0";
    resultDiv.innerText = data.sub;
    resultDiv.style.color = data.color;
    resultDiv.style.border = `4px solid ${data.color}`;
    resultDiv.style.padding = "10px 40px";
    resultDiv.style.borderRadius = "10px";
    resultDiv.style.background = "rgba(255,255,255,0.9)";

    // è¡¨ç¤º
    overlay.style.display = "flex";
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
    setTimeout(() => {
        // â˜…è¿½åŠ : ã“ã“ã§ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«é–‹å§‹ï¼
        playSoundEffect('DRUM');

        coverDiv.style.transition = "top 5s ease-in-out"; 
        coverDiv.style.top = "100%";
    }, 500);

    // çµæœãƒ‰ãƒ³ï¼
    setTimeout(() => {
        resultDiv.style.opacity = "1";
        resultDiv.style.transform = "translate(-50%, -50%) scale(1)";
        
        // â˜…è¿½åŠ : çµæœã«å¿œã˜ãŸéŸ³ã‚’é³´ã‚‰ã™
        if (data.isWin) {
            // C(0,5)ãªã‚‰å¤§å½“ãŸã‚Šã€ãã‚Œä»¥å¤–ãªã‚‰æ™®é€šå½“ãŸã‚Š
            if (data.guessType === 'C') {
                playSoundEffect('WIN_BIG'); 
            } else {
                playSoundEffect('WIN_NORMAL');
            }
        } else {
            playSoundEffect('LOSE');
        }

    }, 5000); // 5ç§’å¾Œ (ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«ãŒçµ‚ã‚ã‚‹é ƒ)

    // çµ‚äº†
    setTimeout(() => {
        overlay.style.display = "none";
    }, 8000);
}

/* --- MAGICIAN (æ‰‹å“å¸«) ã®å®Ÿè£… --- */
// æ¦‚è¦: ãƒ‘ãƒãƒ«è‡ªä½“ã‚’ã€ŒREVERSEã€ã€ŒTRADEã€ã€ŒDIG UPã€ã®ã„ãšã‚Œã‹ã¨ã—ã¦ä½¿ã†

// 1. ç™ºå‹•ï¼šåŠ¹æœã‚’é¸æŠã™ã‚‹
function activateMagician() {
    let html = `
        <p>ã©ã®ãƒã‚¸ãƒƒã‚¯ã‚’è¡Œã„ã¾ã™ã‹ï¼Ÿ<br>
        <span style="font-size:12px; color:#888;">â€»æ‰‹æœ­ã®ã‚«ãƒ¼ãƒ‰ã¯æ¶ˆè²»ã—ã¾ã›ã‚“ï¼ˆã‚³ã‚¹ãƒˆã¨ã—ã¦å¿…è¦ãªå ´åˆã‚’é™¤ãï¼‰</span>
        </p>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <button onclick="execMagicianReverse()" style="padding:15px; background:#e91e63; color:white; font-weight:bold; border-radius:8px;">
                <span style="font-size:18px;">ğŸ”„ REVERSE</span><br>
                <span style="font-size:11px;">å¤©åœ°ã‚’ã²ã£ãã‚Šè¿”ã™ï¼</span>
            </button>
            <button onclick="activateMagicianTrade()" style="padding:15px; background:#ffb74d; color:#e65100; font-weight:bold; border-radius:8px;">
                <span style="font-size:18px;">ğŸ¤ TRADE</span><br>
                <span style="font-size:11px;">ã“ã£ãã‚Šã‚«ãƒ¼ãƒ‰ã‚’äº¤æ›ã™ã‚‹ï¼</span>
            </button>
            <button onclick="activateMagicianDigUp()" style="padding:15px; background:#8d6e63; color:white; font-weight:bold; border-radius:8px;">
                <span style="font-size:18px;">â› DIG UP</span><br>
                <span style="font-size:11px;">ã‚«ãƒ¼ãƒ‰ã‚’æ‹¾ã£ã¦ã™ã‚Šæ›¿ãˆã‚‹ï¼</span>
            </button>
        </div>
    `;
    openModal("æ‰‹å“å¸«: ãƒã‚¸ãƒƒã‚¯é¸æŠ", html);
}

// --- A: REVERSE (é©å‘½) ---
async function execMagicianReverse() {
    closeModal();
    let updates = {};
    
    // é©å‘½ãƒ•ãƒ©ã‚°åè»¢
    updates[`rooms/${currentRoom}/isReverse`] = !gameState.isReverse;
    
    // â˜…ãƒã‚¤ãƒ³ãƒˆ: ä½¿ç”¨æ¸ˆã¿ãƒªã‚¹ãƒˆã«ã€Œä½•ã‚’ä½¿ã£ãŸã‹ã€ã‚’æ›¸ãè¾¼ã‚€
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "REVERSE"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ãƒ­ã‚°ãªã©
    await pushLog(`${myName}ãŒ[æ‰‹å“å¸«]ã§REVERSEã‚’ç™ºå‹•ï¼`, 'public');
    //playSoundEffect('SKILL');
    //playSoundEffect('REVERSE');
    
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'REVERSE', id: Date.now() };
    // ã‚¿ãƒ¼ãƒ³é€²è¡Œ
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

// --- B: TRADE (äº¤æ›) ---
/* --- ä¿®æ­£ç‰ˆ: æ‰‹å“å¸« (ãƒãƒƒã‚«ãƒ¼ & å…¬é–‹å¯¾å¿œ) --- */

// B: TRADE (äº¤æ›) - ç›¸æ‰‹é¸æŠ
function activateMagicianTrade() {
    let hand = gameState.hands[myId] || [];
    // è‡ªåˆ†ã®æ‰‹æœ­ãŒå…¨ã¦ãƒãƒƒã‚­ãƒ³ã‚°ã•ã‚Œã¦ã„ãŸã‚‰äº¤æ›ã«å‡ºã›ã‚‹ã‚«ãƒ¼ãƒ‰ãŒãªã„
    let availableHand = hand.filter(c => !c.isHacked);
    
    if (hand.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "æ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“");
    if (availableHand.length === 0) return showInfoModal("ãƒ­ãƒƒã‚¯ä¸­", "ãƒãƒƒã‚­ãƒ³ã‚°ã•ã‚Œã¦ã„ãªã„æ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“");

    let html = `<p>ãƒˆãƒ¬ãƒ¼ãƒ‰ç›¸æ‰‹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>`;
    gameState.playerOrder.forEach(pid => {
        if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
        let p = gameState.players[pid];
        let count = gameState.hands[pid] ? gameState.hands[pid].length : 0;
        
        // â˜…å¤‰æ›´: æ¬¡ã¯ã€Œå¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠ (magicianSelectTake)ã€ã¸
        if (count > 0) {
            html += `<button class="modal-btn" onclick="magicianSelectTake('${pid}')">${p.name} (æ‰‹æœ­${count})</button>`;
        }
    });
    openModal("æ‰‹å“å¸«(TRADE): ç›¸æ‰‹é¸æŠ", html);
}

// â˜…æ–°è¨­: å¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠ (ãƒãƒƒã‚«ãƒ¼ & å…¬é–‹å¯¾å¿œ)
function magicianSelectTake(targetId) {
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p>ç›¸æ‰‹ã®æ‰‹æœ­ã‹ã‚‰<strong>å¥ªã†ã‚«ãƒ¼ãƒ‰</strong>ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚<br>
                <span style="font-size:11px;">(å…¬é–‹ã‚«ãƒ¼ãƒ‰ã¯è¦‹ãˆã¾ã™)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "?";
        let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        let cssClass = "card"; 
        let onClick = `onclick="magicianSelectGive('${targetId}', ${c.originalIndex})"`;

        // â˜…ãƒãƒƒã‚«ãƒ¼å¯¾å¿œ
        if (c.isHacked) {
            cssClass += " hacked";
            style = "cursor:not-allowed; border:1px solid #555; background:#333;";
            content = "ğŸ”’"; 
            onClick = "";
        }
        // â˜…å…¬é–‹å¯¾å¿œ
        else if (c.isOpen) {
            cssClass = `card ${c.type}`;
            content = c.val;
            style = "cursor:pointer; ";
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
            else if (c.val === 0) style += `border:2px solid #ab47bc; color:#8e24aa; background:#f3e5f5;`;
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });

    html += `</div>`;
    openModal("æ‰‹å“å¸«(TRADE): ç•¥å¥ªé¸æŠ", html);
}

// æ¸¡ã™ã‚«ãƒ¼ãƒ‰é¸æŠ (åå‰å¤‰æ›´: SelectTradeCard -> SelectGive)
function magicianSelectGive(targetId, takeIdx) {
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>ç›¸æ‰‹ã«æ¸¡ã™ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚<br><span style="font-size:11px;">(æ‰‹å“å¸«ã®åŠ¹æœãªã®ã§TRADEã‚«ãƒ¼ãƒ‰è‡ªä½“ã¯ä¸è¦ã§ã™)</span></p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execMagicianTrade('${targetId}', ${i}, ${takeIdx})"`;

        // â˜…ãƒãƒƒã‚«ãƒ¼å¯¾å¿œ
        if (c.isHacked) {
            cssClass += " hacked";
            onClick = "";
        }
        
        html += `<div class="${cssClass}" style="${style}" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;
    openModal("æ‰‹å“å¸«(TRADE): è­²æ¸¡é¸æŠ", html);
}

// å®Ÿè¡Œå‡¦ç† (å¼•æ•° takeIdx ã‚’è¿½åŠ )
async function execMagicianTrade(targetId, giveIdx, takeIdx) {
    closeModal();
    let updates = {};
    let myHand = sortCards(deepCopy(gameState.hands[myId]));
    let targetHand = sortCards(deepCopy(gameState.hands[targetId]));

    // äº¤æ›å‡¦ç†
    let giveCard = myHand.splice(giveIdx, 1)[0]; // è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰
    // â˜…å¤‰æ›´: æŒ‡å®šã—ãŸã‚«ãƒ¼ãƒ‰ã‚’å¥ªã†
    let receiveCard = targetHand.splice(takeIdx, 1)[0]; // ç›¸æ‰‹ã®ã‚«ãƒ¼ãƒ‰
    
    myHand.push(receiveCard);
    targetHand.push(giveCard);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);

    // ä½¿ç”¨æ¸ˆã¿è¨˜éŒ²: TRADE
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "TRADE"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'TRADE', id: Date.now() };

    const targetName = gameState.players[targetId].name;

    await pushLog(`${myName}ãŒ[æ‰‹å“å¸«]ã§TRADEã‚’ç™ºå‹•ï¼`, 'public');
    await pushLog(`${targetName}ã‹ã‚‰ [${receiveCard.val}] ã‚’ç›—ã¿ã€[${giveCard.val}] ã‚’æ¸¡ã—ã¾ã—ãŸã€‚`, 'private', myId);
    await pushLog(`${myName}ã®æ‰‹å“ã§ [${receiveCard.val}] ã‚’ç›—ã¾ã‚Œã€[${giveCard.val}] ã‚’æ¸¡ã•ã‚Œã¾ã—ãŸã€‚`, 'private', targetId);

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(æ‰‹å“å¸«)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };
    
    await db.ref().update(updates);
}

// --- C: DIG UP (ç™ºæ˜) ---
function activateMagicianDigUp() {
    let gn = gameState.graveNum || [];
    if (gn.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "æ•°å­—å¢“åœ°ãŒãªã„ãŸã‚æ‹¾ãˆã¾ã›ã‚“");

    let hand = gameState.hands[myId] || [];
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "åŸ‹ã‚ã‚‹ãŸã‚ã®æ•°å­—ã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«ã‚ã‚Šã¾ã›ã‚“");

    // åŸ‹ã‚ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶
    let html = `<p>å¢“åœ°ã®ä¸€ç•ªä¸Šã‚’æ‹¾ã„ã¾ã™ã€‚<br>ä»£ã‚ã‚Šã«åŸ‹ã‚ã‚‹ã‚«ãƒ¼ãƒ‰(æ•°å­—)ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
    hand.forEach((c, i) => {
        if (c.type !== 'num') return; // æ•°å­—ä»¥å¤–ã¯åŸ‹ã‚ã‚‰ã‚Œãªã„ãƒ«ãƒ¼ãƒ«
        let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
        html += `<div class="card ${c.type}" style="${style}" onclick="execMagicianDigUp(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("æ‰‹å“å¸«(DIG UP): åŸ‹è‘¬é¸æŠ", html);
}

async function execMagicianDigUp(buryIdx) {
    closeModal();
    let updates = {};
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let gn = [...(gameState.graveNum || [])];
    
    // å‡¦ç†: å¢“åœ°ãƒˆãƒƒãƒ—å–å¾— â†’ æ‰‹æœ­åŸ‹ã‚ â†’ æ‰‹æœ­å…¥ã‚Œæ›¿ãˆ
    let top = gn.pop(); 
    let buryCard = hand.splice(buryIdx, 1)[0];
    hand.push(top);
    gn.push({...buryCard, owner:myId});

    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(hand);
    updates[`rooms/${currentRoom}/graveNum`] = gn;

    // â˜…ä½¿ç”¨æ¸ˆã¿è¨˜éŒ²: DIG UP
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "DIG UP"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await pushLog(`${myName}ãŒ[æ‰‹å“å¸«]ã§DIG UPã‚’ç™ºå‹•ï¼`, 'public');
    //playSoundEffect('SKILL');
    //playSoundEffect('DIG UP');

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- MILLIONAIRE (å¯Œè±ª) ã®å®Ÿè£… --- */
function activateMillionaire() {
    let hand = gameState.hands[myId] || [];
    let deckSym = gameState.deckSym || [];

    // é™¤å¤–ã§ãã‚‹æ•°å­—ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "é™¤å¤–ã§ãã‚‹æ•°å­—ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“");
    
    if (deckSym.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "è¨˜å·å±±æœ­ãŒç©ºã§ã™");

    let html = `<p>ã‚³ã‚¹ãƒˆã¨ã—ã¦é™¤å¤–ã™ã‚‹æ•°å­—ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚<br><span style="font-size:11px;">(è¨˜å·å±±æœ­ã‹ã‚‰1æšå¼•ãã¾ã™)</span></p><div class="modal-list">`;
    hand.forEach((c, i) => {
        if (c.type !== 'num') return; 
        
        let style = (c.val === 0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" onclick="execMillionaire(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("å¯Œè±ª: è³‡ç”£é‹ç”¨", html);
}

async function execMillionaire(excludeIdx) {
    closeModal();
    let updates = {};
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deckSym = [...(gameState.deckSym || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 1. æ‰‹æœ­ã‚’é™¤å¤–
    let excludedCard = hand.splice(excludeIdx, 1)[0];
    excl.push(excludedCard);
    
    // éŸ³ã‚·ã‚°ãƒŠãƒ«é€ä¿¡ (PUTéŸ³)
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'PUT', id: Date.now() };

    // 2. è¨˜å·å±±æœ­ã‹ã‚‰ãƒ‰ãƒ­ãƒ¼
    let drawnCard = deckSym.pop();
    hand.push(drawnCard);
    hand = sortCards(hand);

    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckSym`] = deckSym;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await pushLog(`${myName}ãŒ[å¯Œè±ª]ã‚’ç™ºå‹•ï¼æ‰‹æœ­ã®[${excludedCard.val}]ã‚’æ”¯æ‰•ã£ã¦è¨˜å·ã‚«ãƒ¼ãƒ‰ã‚’è²·ã„ã¾ã—ãŸ`, 'public');
    await pushLog(`ã€å¯Œè±ªã®è²·ã„ç‰©ã€‘è²·ã£ãŸã‚«ãƒ¼ãƒ‰: ${drawnCard.val}`, 'private', myId);

    await db.ref().update(updates);
}

/* --- EMPEROR (çš‡å¸) ã®å®Ÿè£… --- */

// 1. ã‚¹ã‚­ãƒ«ç™ºå‹•ï¼šå…¨ã‚«ãƒ¼ãƒ‰å›åï¼†é¸æŠç”»é¢
function activateEmperor() {
    // å…¨å“¡ã®æ‰‹æœ­ã‚’å›åã—ã¦ã€ã‚½ãƒ¼ãƒˆã—ã¦è¡¨ç¤ºã™ã‚‹
    let allCards = [];
    let pIds = gameState.playerOrder;
    
    // å…¨å›å
    pIds.forEach(pid => {
        let h = gameState.hands[pid] || [];
        allCards = allCards.concat(h);
    });

    if (allCards.length === 0) return showInfoModal("ã‚¨ãƒ©ãƒ¼", "ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“");

    // â˜…ã”å¸Œæœ›ã®ã‚½ãƒ¼ãƒˆå‡¦ç†
    // æ•°å­—ã¯å°ã•ã„é †ã€è¨˜å·ã¯åå‰é †
    allCards.sort((a, b) => {
        // ã‚¿ã‚¤ãƒ—ãŒé•ã†ãªã‚‰æ•°å­—ãŒå…ˆ
        if (a.type !== b.type) return a.type === 'num' ? -1 : 1;
        
        // æ•°å­—åŒå£«ãªã‚‰å€¤ã®å°ã•ã„é †
        if (a.type === 'num') return a.val - b.val;
        
        // è¨˜å·åŒå£«ãªã‚‰åå‰é † (DIG UP, DISCARD, REVERSE, TRADE)
        return a.val.localeCompare(b.val);
    });

    // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
    let html = `
        <p style="font-size:14px;">
            æ°‘ã®æ‰‹æœ­ã‚’ã™ã¹ã¦å›åã—ã¾ã—ãŸã€‚<br>
            <strong>ã‚ãªãŸãŒæ¬²ã—ã„ã€Œæœ€å¼·ã®1æšã€ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</strong><br>
            <span style="font-size:11px; color:#888;">æ®‹ã‚Šã¯è‡ªå‹•çš„ã«å†åˆ†é…ã•ã‚Œã¾ã™ã€‚</span>
        </p>
        <div class="modal-list">
    `;

    allCards.forEach((c, i) => {
        // é€šå¸¸ã®ã‚«ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«ç”Ÿæˆ
        let style = "";
        
        // â˜…0ã¯ã„ã¤ã‚‚ã®ç´«è‰²
        if (c.val === 0) {
            style = 'color:#6a1b9a; border-color:#6a1b9a; background:#f3e5f5;';
        }
        
        // ç”»åƒãŒã‚ã‚‹ãªã‚‰èƒŒæ™¯ã«ã‚»ãƒƒãƒˆ
        let cImg = CARD_IMAGES[c.val];
        if (cImg) {
            style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        }
        
        // ã‚¯ãƒªãƒƒã‚¯ã§å®Ÿè¡Œï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¸¡ã™ï¼‰
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                      onclick="execEmperorSelect(${i})">
                      ${c.val}
                 </div>`;
    });

    html += `</div>`;
    openModal("çš‡å¸: å¾´åã¨é¸å®š", html);
    document.getElementById("modal-footer").innerHTML = ""; // æˆ»ã‚‹ãƒœã‚¿ãƒ³ãªã—
}

// 2. é¸æŠå®Ÿè¡Œï¼†å†åˆ†é…
async function execEmperorSelect(selectedIdx) {
    closeModal();
    let updates = {};

    // 1. ã‚‚ã†ä¸€åº¦å…¨ã‚«ãƒ¼ãƒ‰ã‚’å›åãƒ»ã‚½ãƒ¼ãƒˆï¼ˆé¸æŠã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã‚’ç‰¹å®šã™ã‚‹ãŸã‚ï¼‰
    let pIds = gameState.playerOrder;
    let handCounts = {}; // å…ƒã®æšæ•°ã‚’è¨˜éŒ²
    let allCards = [];
    
    pIds.forEach(pid => {
        let h = gameState.hands[pid] || [];
        handCounts[pid] = h.length;
        allCards = allCards.concat(h);
    });

    // ã‚½ãƒ¼ãƒˆï¼ˆactivateã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
    allCards.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'num' ? -1 : 1;
        if (a.type === 'num') return a.val - b.val;
        return a.val.localeCompare(b.val);
    });

    // 2. çš‡å¸ãŒé¸ã‚“ã ã‚«ãƒ¼ãƒ‰ã‚’ç¢ºä¿
    let emperorCard = allCards.splice(selectedIdx, 1)[0];

    // 3. æ®‹ã‚Šã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    shuffle(allCards);

    // 4. å†åˆ†é… (çš‡å¸ã®æ¬¡ã®äººã‹ã‚‰é…ã‚‹)
    // ã¾ãšçš‡å¸ã«é¸ã‚“ã 1æšã‚’æŒãŸã›ã‚‹
    let newHands = {};
    pIds.forEach(pid => newHands[pid] = []);
    newHands[myId].push(emperorCard);
    
    // ç¾åœ¨ã®çš‡å¸ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    let myTurnIdx = gameState.turnIdx; 
    let totalPlayers = pIds.length;
    
    // ã‚«ãƒ¼ãƒ‰ã‚’é…ã‚‹ãƒã‚¤ãƒ³ã‚¿
    let cardPtr = 0;
    
    // ã€Œçš‡å¸ã®æ¬¡ã®äººã€ã‹ã‚‰é †ã«ã€å…ƒã®æšæ•°ã«ãªã‚‹ã¾ã§é…ã‚‹
    // ãƒ«ãƒ¼ãƒ—ã¯æœ€å¤§ã§ã‚‚ (äººæ•° * æœ€å¤§æ‰‹æœ­æšæ•°) å›ç¨‹åº¦ãªã®ã§å®‰å…¨
    for (let i = 1; i <= totalPlayers; i++) {
        let targetIdx = (myTurnIdx + i) % totalPlayers;
        let targetPid = pIds[targetIdx];
        
        // ãã®äººãŒæœ¬æ¥æŒã¤ã¹ãæšæ•°ã«ãªã‚‹ã¾ã§å±±ã‹ã‚‰è£œå……
        while (newHands[targetPid].length < handCounts[targetPid] && cardPtr < allCards.length) {
            newHands[targetPid].push(allCards[cardPtr]);
            cardPtr++;
        }
    }

    // 5. æ‰‹æœ­ã‚’ã‚½ãƒ¼ãƒˆã—ã¦ã‚»ãƒƒãƒˆ
    pIds.forEach(pid => {
        newHands[pid] = sortCards(newHands[pid]);
        updates[`rooms/${currentRoom}/hands/${pid}`] = newHands[pid];
    });

    // 6. ãƒ­ã‚°ã¨æ¼”å‡º
    await pushLog(`${myName}ãŒ[çš‡å¸]ã‚’ç™ºå‹•ï¼æ‰‹æœ­ã‚’å…¨ã¦å›åã—ã€å†åˆ†é…ã—ã¾ã—ãŸã€‚`, 'public');


    // 7. ã‚¿ãƒ¼ãƒ³çµ‚äº†
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    // ä½¿ç”¨æ¸ˆã¿ã«ã™ã‚‹
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await db.ref().update(updates);
}

/* --- POLICE OFFICER (è­¦å¯Ÿå®˜) å®Œæˆç‰ˆ --- */
// 1. å…¨å“¡ã®æ‰‹æœ­ã‚’1æšãšã¤å…¬é–‹ (å³åº§ã«ã‚«ãƒƒãƒˆã‚¤ãƒ³) -> 3ç§’å¾…æ©Ÿ -> 2. å¼·åˆ¶ãƒˆãƒ¬ãƒ¼ãƒ‰

// ã‚¹ãƒ†ãƒƒãƒ—1: ä¸€æ–‰æœæŸ»
async function activatePoliceOfficer() {
    let updates = {};
    let logs = [];
    
    // â˜…ä¿®æ­£1: ç™ºå‹•ã—ãŸç¬é–“ã«ã€Œä½¿ç”¨æ¸ˆã¿ã€ã«ã™ã‚‹
    // ã“ã‚Œã«ã‚ˆã‚Šã€renderé–¢æ•°ãŒåå¿œã—ã¦ã€Œã‚«ãƒƒãƒˆã‚¤ãƒ³ã€ã¨ã€ŒéŸ³ã€ãŒè‡ªå‹•ã§æµã‚Œã¾ã™
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // å…¨å“¡ã®æ‰‹æœ­ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å…¬é–‹ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    gameState.playerOrder.forEach(pid => {
        if (pid === myId) return; 
        if (gameState.rankings && gameState.rankings[pid]) return; 

        let hand = deepCopy(gameState.hands[pid] || []);
        let hiddenIndices = [];
        hand.forEach((c, i) => { if (!c.isOpen) hiddenIndices.push(i); });

        if (hiddenIndices.length > 0) {
            let rand = Math.floor(Math.random() * hiddenIndices.length);
            let targetIdx = hiddenIndices[rand];
            
            hand[targetIdx].isOpen = true; // å…¬é–‹ï¼
            updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
            
            let pName = gameState.players[pid].name;
            logs.push(`${pName}ã®[${hand[targetIdx].val}]`);
        }
    });

    if (logs.length > 0) {
        await pushLog(`${myName}ãŒ[è­¦å¯Ÿå®˜]ã§ä¸€æ–‰æœæŸ»ï¼ ${logs.join('ã€')} ã‚’å…¬é–‹ã•ã›ã¾ã—ãŸï¼`, 'public');
        // éŸ³ã¯renderé–¢æ•°ãŒã€ŒactivatedListã€ã®å¤‰åŒ–ã‚’æ¤œçŸ¥ã—ã¦é³´ã‚‰ã™ã®ã§ã€ã“ã“ã§ã¯é³´ã‚‰ã—ã¾ã›ã‚“ï¼ˆäºŒé‡å†ç”Ÿé˜²æ­¢ï¼‰
    } else {
        await pushLog(`${myName}ãŒ[è­¦å¯Ÿå®˜]ã‚’ç™ºå‹•ã—ã¾ã—ãŸãŒã€æ–°ãŸãªè¨¼æ‹ ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`, 'public');
    }

    await db.ref().update(updates);

    // â˜…ä¿®æ­£2: ã‚«ãƒƒãƒˆã‚¤ãƒ³æ¼”å‡ºã®ä½™éŸ»ï¼ˆ3ç§’ï¼‰ã‚’å¾…ã£ã¦ã‹ã‚‰ã€å¼·åˆ¶çš„ã«ãƒˆãƒ¬ãƒ¼ãƒ‰ç”»é¢ã¸
    setTimeout(() => {
        policeTradeStart();
    }, 3000); 
}

/* --- è­¦å¯Ÿå®˜ã®ãƒˆãƒ¬ãƒ¼ãƒ‰æ”¹ä¿® (ç‹™ã„æ’ƒã¡å¯¾å¿œ) --- */

// ã‚¹ãƒ†ãƒƒãƒ—2: ãƒˆãƒ¬ãƒ¼ãƒ‰ç›¸æ‰‹é¸æŠ
function policeTradeStart() {

    // â–¼â–¼â–¼ 1. è‡ªåˆ†ã®æ‰‹æœ­ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®HTMLç”Ÿæˆ â–¼â–¼â–¼
    let myHand = sortCards(deepCopy(gameState.hands[myId] || []));
    let myHandHtml = `<div style="display:flex; justify-content:center; gap:5px; margin-bottom:15px; flex-wrap:wrap;">`;
    
    myHand.forEach(c => {
        let style = "width:40px; height:60px; font-size:12px; border:1px solid #999; cursor:default;";
        let cssClass = `card ${c.type}`;
        
        // å…¬é–‹ãƒ»ãƒãƒƒã‚¯çŠ¶æ…‹ã®åæ˜ 
        if (c.isOpen) cssClass += " revealed";
        if (c.isHacked) {
            cssClass += " locked";
            style += "filter:grayscale(1); border:1px dashed red;";
        }

        // ç”»åƒãƒ»è‰²è¨­å®š
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:none;`;
        else if (Number(c.val) === 0) style += `border:1px solid #ab47bc; background:#f3e5f5; color:#8e24aa;`;
        
        myHandHtml += `<div class="${cssClass}" style="${style}">${c.val}</div>`;
    });
    myHandHtml += `</div>`;
    // â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²

    let html = `
        <p><strong>ã€æœæŸ»å”åŠ›ã®è¦è«‹ã€‘</strong><br>ç¶šã‘ã¦ãƒˆãƒ¬ãƒ¼ãƒ‰(äº¤æ›)ã‚’è¡Œã„ã¾ã™ã‹ï¼Ÿ<br>
        <span style="font-size:11px; color:#666;">(ä»»æ„: è¡Œã‚ãªã„å ´åˆã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã§çµ‚äº†)</span>
        </p>
        
        <div style="background:rgba(0,0,0,0.05); padding:5px; border-radius:5px;">
            <div style="font-size:10px; font-weight:bold; color:#333; margin-bottom:5px;">ã‚ãªãŸã®æ‰‹æœ­</div>
            ${myHandHtml}
        </div>

        <p style="margin-top:10px;">ç›¸æ‰‹ã‚’é¸ã‚“ã§ãã ã•ã„</p>
    `;

    // ç›¸æ‰‹ãƒªã‚¹ãƒˆç”Ÿæˆ
    gameState.playerOrder.forEach(pid => {
        if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
        let p = gameState.players[pid];
        let hand = gameState.hands[pid] || [];
        let count = hand.length;
        
        // å…¬é–‹æƒ…å ±ã®è¡¨ç¤º
        let revealed = hand.filter(c => c.isOpen).map(c => c.val).join(", ");
        let revealedInfo = revealed ? `<br><span style="font-size:11px; color:#000000;">(å…¬é–‹: ${revealed})</span>` : "";

        if (count > 0) {
            html += `<button class="modal-btn" onclick="policeSelectTake('${pid}')">
                        ${p.name} (æ‰‹æœ­${count})${revealedInfo}
                     </button>`;
        }
    });
    
    // â–¼â–¼â–¼ ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ï¼ˆãƒˆãƒ¬ãƒ¼ãƒ‰ã—ãªã„ï¼‰ã‚’è¿½åŠ  â–¼â–¼â–¼
    html += `
        <div style="margin-top:20px; border-top:1px solid #ccc; padding-top:10px;">
            <button onclick="endPoliceTurn()" style="background:#78909c; color:white; padding:10px 20px; border-radius:20px;">
                æœæŸ»ã‚’çµ‚äº†ã™ã‚‹ (ãƒˆãƒ¬ãƒ¼ãƒ‰ã—ãªã„)
            </button>
        </div>
    `;

    openModal("è­¦å¯Ÿå®˜: æœæŸ»å¯¾è±¡ã®é¸æŠ", html);
    document.getElementById("modal-footer").innerHTML = ""; // æ¨™æº–ã®é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã¯æ¶ˆã—ã€è‡ªå‰ã®çµ‚äº†ãƒœã‚¿ãƒ³ã‚’ä½¿ã‚ã›ã‚‹
}

// â˜…è¿½åŠ : ãƒˆãƒ¬ãƒ¼ãƒ‰ã›ãšã«çµ‚äº†ã™ã‚‹é–¢æ•°
async function endPoliceTurn() {
    closeModal();
    let updates = {};

    // ãƒ­ã‚°
    await pushLog(`${myName}ãŒ[è­¦å¯Ÿå®˜]ã®æœæŸ»ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚(ãƒˆãƒ¬ãƒ¼ãƒ‰ãªã—)`, 'public');

    // ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- ä¿®æ­£ç‰ˆ: policeSelectTake (ãƒ•ã‚©ãƒ³ãƒˆãƒãƒ¬é˜²æ­¢) --- */
/* --- ä¿®æ­£ç‰ˆ: è­¦å¯Ÿå®˜ (ãƒãƒƒã‚«ãƒ¼å¯¾å¿œ) --- */

// å¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠ
function policeSelectTake(targetId) {
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p><strong>æŠ¼åã™ã‚‹ã‚«ãƒ¼ãƒ‰</strong>ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚<br>
                <span style="font-size:11px;">(å…¬é–‹ã‚«ãƒ¼ãƒ‰ã¯è¦‹ãˆã¾ã™)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "";
        let style = "cursor:pointer; ";
        let cssClass = "card"; 
        let onClick = `onclick="policeSelectGive('${targetId}', ${c.originalIndex})"`;

        if (c.isOpen) {
            cssClass = `card ${c.type}`; 
            content = c.val;
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
            else if (c.val === 0) style += `border:2px solid #ab47bc; color:#8e24aa; background:#f3e5f5;`;
        } else {
            content = "?";
            style += "background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });

    html += `</div>`;
    openModal("è­¦å¯Ÿå®˜: æŠ¼åå“é¸æŠ", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// æ¸¡ã™ã‚«ãƒ¼ãƒ‰é¸æŠ
function policeSelectGive(targetId, takeIdx) {
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>ç›¸æ‰‹ã«æ¸¡ã™ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execPoliceTrade('${targetId}', ${i}, ${takeIdx})"`;

        html += `<div class="${cssClass}" style="${style} cursor:pointer;" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;
    openModal("è­¦å¯Ÿå®˜: æå‡º", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// ã‚¹ãƒ†ãƒƒãƒ—3: è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰é¸æŠ (å¼•æ•°ã« takeIdx ã‚’è¿½åŠ )
function policeSelectGive(targetId, takeIdx) {
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>ç›¸æ‰‹ã«æ¸¡ã™ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = (c.val===0) ? 'style="color:#6a1b9a; border-color:#6a1b9a;"' : '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // execPoliceTrade ã« takeIdx ã‚‚æ¸¡ã™
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                  onclick="execPoliceTrade('${targetId}', ${i}, ${takeIdx})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("è­¦å¯Ÿå®˜: æå‡º", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// ã‚¹ãƒ†ãƒƒãƒ—4: ãƒˆãƒ¬ãƒ¼ãƒ‰å®Ÿè¡Œ (ãƒ©ãƒ³ãƒ€ãƒ ã§ã¯ãªãæŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§äº¤æ›)
async function execPoliceTrade(targetId, giveIdx, takeIdx) {
    closeModal();
    let updates = {};
    let myHand = sortCards(deepCopy(gameState.hands[myId]));
    let targetHand = sortCards(deepCopy(gameState.hands[targetId])); // ç›¸æ‰‹ã®æ‰‹æœ­ã¯ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®çŠ¶æ…‹ã‹ã‚‰å–ã‚‹

    // äº¤æ›å®Ÿè¡Œ
    let giveCard = myHand.splice(giveIdx, 1)[0];
    // â˜…å¤‰æ›´: ãƒ©ãƒ³ãƒ€ãƒ ã§ã¯ãªãã€æŒ‡å®šã•ã‚ŒãŸ takeIdx ã®ã‚«ãƒ¼ãƒ‰ã‚’å¥ªã†
    let receiveCard = targetHand.splice(takeIdx, 1)[0];
    const targetName = gameState.players[targetId].name;
    
    myHand.push(receiveCard);
    targetHand.push(giveCard);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);

    updates[`rooms/${currentRoom}/lastSound`] = { type: 'TRADE', id: Date.now() };
    await pushLog(`${myName}ãŒ[è­¦å¯Ÿå®˜]ã¨ã—ã¦${targetName}ã¨ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã—ãŸã€‚`, 'public');
    await pushLog(`${targetName}ã‹ã‚‰ [${receiveCard.val}] ã‚’æŠ¼åã—ã€[${giveCard.val}] ã‚’æ¸¡ã—ã¾ã—ãŸã€‚`, 'private', myId);
    await pushLog(`${myName}ã« [${receiveCard.val}] ã‚’æŠ¼åã•ã‚Œã€[${giveCard.val}] ã‚’æ¸¡ã•ã‚Œã¾ã—ãŸã€‚`, 'private', targetId);
    
    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(è­¦å¯Ÿå®˜)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- NEW GRAD (æ–°å’) ã®å®Ÿè£… --- */
// åŠ¹æœ: ã™ã§ã«ä½¿ç”¨ã•ã‚ŒãŸä»–ã®äººã®ã‚¹ã‚­ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ï¼ˆå°±è·ã™ã‚‹ï¼‰

function activateNewGrad() {
    // 1. å°±è·å¯èƒ½ãªï¼ˆã‚³ãƒ”ãƒ¼ã§ãã‚‹ï¼‰å½¹è·ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const actList = gameState.activatedList || {};
    const usedRoles = new Set(); 
    
    gameState.playerOrder.forEach(pid => {
        // è‡ªåˆ†è‡ªèº«ã¯ã‚³ãƒ”ãƒ¼ã§ããªã„
        if (pid === myId) return;
        
        // ã‚¹ã‚­ãƒ«ä½¿ç”¨æ¸ˆã¿ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹ã‹ï¼Ÿ
        // â€»æ‰‹å“å¸«ã®å ´åˆã¯ "REVERSE" ç­‰ã®æ–‡å­—åˆ—ãŒå…¥ã£ã¦ã„ã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã®ã§ã€truthyãªã‚‰OK
        if (actList[pid]) {
            const role = gameState.roles[pid];
            // çš‡å¸ (EMPEROR) ã¯ã‚³ãƒ”ãƒ¼ä¸å¯ï¼ˆãƒ«ãƒ¼ãƒ«å®šç¾©ï¼‰
            if (role !== "EMPEROR") {
                usedRoles.add(role);
            }
        }
    });

    // ã¾ã èª°ã‚‚ä½¿ã£ã¦ã„ãªã„ï¼ˆå°±è·å…ˆãŒãªã„ï¼‰å ´åˆ
    if (usedRoles.size === 0) {
        return showInfoModal("å°±è·é›£", "ã¾ã å…ˆè¼©ãŸã¡ãŒåƒã„ã¦ã„ã¾ã›ã‚“ã€‚<br>ï¼ˆã‚³ãƒ”ãƒ¼ã§ãã‚‹å½¹è·ãŒã‚ã‚Šã¾ã›ã‚“ï¼‰");
    }

    // 2. é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
    let html = `<p>å°±è·å…ˆï¼ˆã‚³ãƒ”ãƒ¼ã™ã‚‹å½¹è·ï¼‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>
                <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">`;

    usedRoles.forEach(role => {
        // æ—¥æœ¬èªåã‚’å–å¾—
        const rInfo = ROLE_INFO[role];
        const rName = rInfo ? rInfo.jp : role;
        const rDesc = rInfo ? rInfo.desc : "";

        // ãƒœã‚¿ãƒ³ç”Ÿæˆ
        html += `
            <button onclick="execNewGradCopy('${role}')" style="padding:12px; background:#5c6bc0; color:white; font-weight:bold; border-radius:8px; text-align:left; box-shadow:0 2px 5px rgba(0,0,0,0.2);">
                <span style="font-size:16px;">${rName}</span><br>
                <span style="font-size:10px; opacity:0.8;">${rDesc}</span>
            </button>
        `;
    });
    
    html += `</div>`;
    openModal("æ–°å’: åˆåŒèª¬æ˜ä¼š", html);
}

// å°±è·ï¼ˆã‚³ãƒ”ãƒ¼ï¼‰å®Ÿè¡Œå‡¦ç†
async function execNewGradCopy(targetRole) {
    const rInfo = ROLE_INFO[targetRole];
    const rName = rInfo ? rInfo.jp : targetRole;

    // 1. å°±è·ãƒ­ã‚°ã‚’è¡¨ç¤ºï¼
    await pushLog(`${myName}ãŒ [${rName}] ã«å°±è·ã—ã¾ã—ãŸï¼`, 'public');

    // 2. ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    closeModal();

    // 3. æ–°å’ã¨ã—ã¦ã®ä½¿ç”¨æ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    // (ã‚³ãƒ”ãƒ¼å…ˆã®å½¹è·ã§ã•ã‚‰ã«ä¸Šæ›¸ãã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ãŒã€ã¾ãšã¯ã€Œæ–°å’ã‚’ä½¿ã£ãŸã€äº‹å®Ÿã‚’è¨˜éŒ²)
    let updates = {};
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    
    // ã‚¹ã‚­ãƒ«ç™ºå‹•éŸ³ (æ–°å’ç”¨)
    const soundKey = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_NEW GRAD']) ? 'SKILL_NEW GRAD' : 'SKILL';
    updates[`rooms/${currentRoom}/lastSound`] = { type: soundKey, id: Date.now() };
    
    await db.ref().update(updates);

    // 4. ãã®å½¹è·ã®æ¥­å‹™ï¼ˆé–¢æ•°ï¼‰ã‚’é–‹å§‹ã™ã‚‹
    // å°‘ã—ã‚¦ã‚§ã‚¤ãƒˆã‚’å…¥ã‚Œã¦ã€ãƒ­ã‚°ã‚„éŸ³ãŒæµã‚ŒãŸå¾Œã«ç”»é¢ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
    setTimeout(() => {
        if (targetRole === "THIEF") {
            activateThief(1);
        } else if (targetRole === "ANGLER") {
            activateAngler();
        } else if (targetRole === "FORTUNE TELLER") {
            activateFortuneTeller();
        } else if (targetRole === "HUNTER") {
            activateHunter();
        } else if (targetRole === "GAMBLER") {
            activateGambler();
        } else if (targetRole === "MAGICIAN") {
            activateMagician();
        } else if (targetRole === "MILLIONAIRE") {
            activateMillionaire();
        } else if (targetRole === "POLICE OFFICER") {
            activatePoliceOfficer();
        } else if (targetRole === "HACKER") {
            activateHacker();
        } else if (targetRole === "ALCHEMIST") {
            activateAlchemist();
        } else {
            showInfoModal("ã‚¨ãƒ©ãƒ¼", `[${rName}] ã®æ¥­å‹™å†…å®¹ã¯æœªå®šç¾©ã§ã™`);
        }
    }, 800);
}

/* --- HACKER (ãƒãƒƒã‚«ãƒ¼) Ver 4.0 [éš”é›¢ãƒªã‚¹ãƒˆæ–¹å¼] --- */

let hackerTargets = {}; 

// 1. ç™ºå‹•ç”»é¢
function activateHacker() {
    hackerTargets = {}; 
    renderHackerUI();
}

function renderHackerUI() {
    let pIds = gameState.playerOrder;
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå€™è£œ: æ‰‹æœ­ãŒã‚ã‚‹äºº
    let targets = pIds.filter(pid => 
        pid !== myId && 
        !gameState.rankings?.[pid] && 
        (gameState.hands[pid] || []).length > 0
    );

    let html = `
        <p><strong>ã‚·ã‚¹ãƒ†ãƒ ã¸ã®ä¾µå…¥ã‚’é–‹å§‹ã—ã¾ã™...</strong><br>
        å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­ã‹ã‚‰<span style="color:#ef5350; font-weight:bold;">1æšãšã¤</span>é¸ã³ã€
        ã‚¦ã‚¤ãƒ«ã‚¹(ãƒ­ãƒƒã‚¯)ã‚’ä»•è¾¼ã‚“ã§ãã ã•ã„ã€‚
        </p>
        <div id="hacker-ui-container" style="text-align:left; max-height:300px; overflow-y:auto;">`;

    if (targets.length === 0) {
        html += `<p style="text-align:center; color:#ccc;">ãƒãƒƒã‚­ãƒ³ã‚°å¯èƒ½ãªç›¸æ‰‹ãŒã„ã¾ã›ã‚“ã€‚</p>`;
    }

    targets.forEach(pid => {
        let p = gameState.players[pid];
        let hand = gameState.hands[pid] || [];
        
        let selectedIdx = hackerTargets[pid]; 

        html += `<div style="margin-bottom:10px; background:rgba(0,0,0,0.05); padding:8px; border-radius:5px;">
                    <div style="font-weight:bold; font-size:12px; margin-bottom:5px; color:#333;">
                        ${p.name} <span style="font-size:10px; color:#666;">(æ‰‹æœ­:${hand.length})</span>
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:4px;">`;
        
        hand.forEach((c, i) => {
            let isSel = (selectedIdx === i);
            let cssClass = `card ${c.type}`;
            if (isSel) cssClass += " target-hack";
            
            let style = "width:36px; height:54px; font-size:12px; cursor:pointer; transition:0.1s;";
            let content = "?";

            if (c.isOpen) {
                content = c.val;
                let cImg = CARD_IMAGES[c.val];
                if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:none;`;
                else if (c.val===0) style += `border:1px solid #ab47bc; background:#f3e5f5; color:#8e24aa;`;
            } else {
                style += "background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
            }

            if (isSel) {
                style += "border:2px solid #ef5350 !important; transform:scale(1.1); box-shadow:0 0 8px #ef5350; opacity:1;";
            }

            html += `<div class="${cssClass}" style="${style}" onclick="selectHackerTarget('${pid}', ${i})">
                        ${content}
                     </div>`;
        });
        html += `</div></div>`;
    });

    html += `</div>`;
    
    let currentSelectCount = Object.keys(hackerTargets).length;
    let requiredCount = targets.length;
    let canExec = (currentSelectCount === requiredCount && requiredCount > 0);

    html += `<div style="text-align:center; margin-top:10px;">
                <p style="font-size:10px; color:${canExec ? '#2e7d32' : '#d32f2f'}; margin-bottom:5px;">
                    é¸æŠçŠ¶æ³: ${currentSelectCount} / ${requiredCount} äºº
                </p>
                <button onclick="execHacker()" ${canExec ? '' : 'disabled'} 
                style="background:${canExec ? '#d32f2f' : '#ccc'}; color:white; padding:10px 30px; font-weight:bold; border-radius:20px; transition:0.3s;">
                ã‚¦ã‚¤ãƒ«ã‚¹é€ä¿¡
                </button>
             </div>`;

    openModal("ãƒãƒƒã‚«ãƒ¼: æ¨™çš„é¸æŠ", html);
    document.getElementById("modal-footer").innerHTML = `<button onclick="closeModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>`;
}

function selectHackerTarget(targetId, idx) {
    hackerTargets[targetId] = idx;
    renderHackerUI();
}

// 3. å®Ÿè¡Œå‡¦ç† (æ‰‹æœ­ã‹ã‚‰hackedHandsã¸ç§»å‹•)
async function execHacker() {
    closeModal();
    let updates = {};
    
    // ç¾åœ¨ã®éš”é›¢ãƒªã‚¹ãƒˆã‚’å–å¾—
    let currentHackedHands = deepCopy(gameState.hackedHands || {});

    Object.keys(hackerTargets).forEach(pid => {
        let idx = hackerTargets[pid];
        let hand = deepCopy(gameState.hands[pid] || []);
        
        if (hand[idx]) {
            // 1. æ‰‹æœ­ã‹ã‚‰æŠœã
            let targetCard = hand.splice(idx, 1)[0];
            
            // 2. IDã‚’åˆ»å°
            targetCard.hackedBy = myId;
            
            // â˜…ä¿®æ­£: ç•ªå·ã§ã¯ãªãã€Œæ™‚é–“ã€ã‚’è¨˜éŒ²ã™ã‚‹
            targetCard.hackedAt = Date.now();
            
            // 3. éš”é›¢ãƒªã‚¹ãƒˆã¸è¿½åŠ 
            if (!currentHackedHands[pid]) currentHackedHands[pid] = [];
            currentHackedHands[pid].push(targetCard);
            
            // 4. DBæ›´æ–°æº–å‚™
            updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
        }
    });

    updates[`rooms/${currentRoom}/hackedHands`] = currentHackedHands;

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'SKILL_HACKER', id: Date.now() };
    await pushLog(`${myName}ãŒ[ãƒãƒƒã‚«ãƒ¼]ã‚’ç™ºå‹•ï¼ã‚·ã‚¹ãƒ†ãƒ ã‚’æŒæ¡ã—ã¾ã—ãŸ`, 'public');

    // â˜…å‰Šé™¤: ä»¥ä¸‹ã®3è¡Œã‚’å‰Šé™¤ï¼ˆã¾ãŸã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼‰ã—ã¦ãã ã•ã„ï¼
    // ãƒãƒƒã‚«ãƒ¼ã¯èƒ½åŠ›ä½¿ç”¨å¾Œã‚‚è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ãŒç¶šããƒ«ãƒ¼ãƒ«ã§ã™ã€‚
    /*
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
    */

    await db.ref().update(updates);
}

async function checkHackerCleanup() {
    if (!gameState || !gameState.hackedHands) return;
    
    // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ãŒæ¥ãŸæ™‚ã®ã¿ãƒã‚§ãƒƒã‚¯
    if (isMyTurn()) {
        let updates = {};
        let needsUpdate = false;
        let currentHackedHands = deepCopy(gameState.hackedHands);

        // â˜…è¿½åŠ : æœ€å¾Œã®ã€Œã‚²ãƒ¼ãƒ ã®å‹•ã(publicãƒ­ã‚°)ã€ãŒã‚ã£ãŸæ™‚é–“ã‚’å–å¾—
        let lastLogTime = 0;
        if (gameState.logs) {
            for (let i = gameState.logs.length - 1; i >= 0; i--) {
                if (gameState.logs[i].type === 'public') {
                    lastLogTime = gameState.logs[i].timestamp || 0;
                    break;
                }
            }
        }
        
        Object.keys(currentHackedHands).forEach(pid => {
            if (!gameState.players[pid]) {
                delete currentHackedHands[pid];
                needsUpdate = true;
                return;
            }

            let lockedCards = currentHackedHands[pid] || [];
            let remainingLocked = [];
            let returningCards = [];
            
            lockedCards.forEach(c => {
                // ãƒãƒƒã‚¯ã—ãŸæ™‚é–“ï¼ˆãªã‘ã‚Œã°0ï¼‰
                let hackTime = c.hackedAt || 0;
                
                // â˜…åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ä¿®æ­£:
                // 1. è‡ªåˆ†ãŒã‹ã‘ãŸãƒ­ãƒƒã‚¯ã§ã‚ã‚‹ (c.hackedBy === myId)
                // 2. æœ€å¾Œã®ãƒ­ã‚°ã®æ™‚é–“ã‚ˆã‚Šã€ãƒãƒƒã‚¯ã—ãŸæ™‚é–“ãŒã€Œ2ç§’ä»¥ä¸Šã€å¤ã„
                //    (ä»Šãƒãƒƒã‚¯ã—ãŸã°ã‹ã‚Šãªã‚‰ã€æ™‚é–“ã¯ã»ã¼åŒã˜ãªã®ã§è§£é™¤ã•ã‚Œã¾ã›ã‚“)
                //    (ä¸€å‘¨å›ã£ã¦ããŸãªã‚‰ã€ãƒ­ã‚°ã®æ™‚é–“ã¯ã‚‚ã£ã¨é€²ã‚“ã§ã„ã‚‹ã®ã§è§£é™¤ã•ã‚Œã¾ã™)
                if (c.hackedBy === myId && (lastLogTime - hackTime > 2000)) {
                    let newC = {...c};
                    delete newC.hackedBy;
                    delete newC.hackedAt; // æ™‚é–“è¨˜éŒ²ã‚‚æ¶ˆã™
                    returningCards.push(newC);
                } else {
                    remainingLocked.push(c);
                }
            });
            
            if (returningCards.length > 0) {
                let hand = deepCopy(gameState.hands[pid] || []);
                hand = hand.concat(returningCards);
                hand = sortCards(hand);
                
                updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
                currentHackedHands[pid] = remainingLocked;
                needsUpdate = true;
            }
        });

        if (needsUpdate) {
            updates[`rooms/${currentRoom}/hackedHands`] = currentHackedHands;
            await pushLog(`${myName}ã®ã‚¦ã‚¤ãƒ«ã‚¹åŠ¹æœãŒåˆ‡ã‚Œã€ãƒ­ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸã€‚`, 'public');
            await db.ref().update(updates);
        }
    }
}

/* --- ALCHEMIST (éŒ¬é‡‘è¡“å¸«) ä¿®æ­£ç‰ˆ [UIæ”¹å–„ & åˆ¤å®šå¼·åŒ–] --- */

let alchemyDrawnCard = null; 
let alchemyHandIdx = -1;     

// ç™ºå‹•
async function activateAlchemist() {
    let deck = gameState.deckNum || [];
    if (deck.length === 0) return showInfoModal("éŒ¬é‡‘å¤±æ•—", "æ•°å­—å±±æœ­ãŒå°½ãã¦ã„ã‚‹ãŸã‚ã€ç´ æã‚’èª¿é”ã§ãã¾ã›ã‚“ã€‚");

    let hand = gameState.hands[myId] || [];
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("éŒ¬é‡‘å¤±æ•—", "æ‰‹æœ­ã«è§¦åª’ã¨ãªã‚‹æ•°å­—ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");

    // ä»®å¼•ã
    let tempDeck = [...deck];
    alchemyDrawnCard = tempDeck.pop();
    
    alchemyHandIdx = -1;
    renderAlchemistUI();
}

// UIè¡¨ç¤º
/* --- ä¿®æ­£ç‰ˆ: å ´ã®ç¢ºèªæ©Ÿèƒ½ & ãƒœã‚¿ãƒ³æ”¹å–„ --- */
/* --- ALCHEMIST (éŒ¬é‡‘è¡“å¸«) UIä¿®æ­£ç‰ˆ --- */
function renderAlchemistUI() {
    let hand = sortCards(deepCopy(gameState.hands[myId] || []));
    
    // â–¼ å ´ã®çŠ¶æ³ï¼ˆãƒˆãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã¨ãƒ«ãƒ¼ãƒ«ï¼‰ã‚’å–å¾—
    let top = getTop(gameState.graveNum);
    let topVal = top ? top.val : "ãªã— (ä½•ã§ã‚‚å‡ºã›ã¾ã™)";
    let isRev = gameState.isReverse;
    let ruleText = isRev ? "â–¼ é€†è¡Œ (å¼±ã„æ–¹ãŒå¼·ã„)" : "â–² é †è¡Œ (å¼·ã„æ–¹ãŒå¼·ã„)";
    
    // â–¼ ä¿®æ­£: å ´æœ­ã®HTMLç”Ÿæˆ (å®Ÿéš›ã®ã‚«ãƒ¼ãƒ‰ã¨åŒã˜ã‚¯ãƒ©ã‚¹ãƒ»ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä½¿ç”¨)
    let topCardHtml = "";
    if (top) {
        let style = "margin-right:15px; cursor:default; transform:scale(0.9);"; // å°‘ã—ã ã‘å°ã•ãã—ã¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«åˆã‚ã›ã‚‹
        let cssClass = `card ${top.type}`;
        
        // 0ã®ã‚¹ã‚¿ã‚¤ãƒ«
        if (Number(top.val) === 0) {
            style += 'color:#6a1b9a; border-color:#6a1b9a; background:#f3e5f5;';
        }
        
        // ç”»åƒå¯¾å¿œ
        let imgUrl = CARD_IMAGES[top.val];
        if (imgUrl) {
            style += `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;`;
        }
        
        // å®Ÿéš›ã®ã‚«ãƒ¼ãƒ‰ã¨åŒã˜HTMLæ§‹é€ 
        topCardHtml = `<div class="${cssClass}" style="${style}" ${Number(top.val)===0 ? 'data-val="0"':''}>${top.val}</div>`;
    } else {
        // å ´ãŒç©ºã®å ´åˆã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
        topCardHtml = `<div class="card" style="border:2px dashed #999; background:rgba(0,0,0,0.2); color:#ccc; margin-right:15px; display:flex; align-items:center; justify-content:center; transform:scale(0.9);">?</div>`;
    }

    // å¼•ã„ãŸã‚«ãƒ¼ãƒ‰ã®è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ«
    let drawImg = CARD_IMAGES[alchemyDrawnCard.val];
    let drawStyle = "border:3px solid #7b1fa2; box-shadow:0 0 10px #7b1fa2; transform:scale(1.1);";
    if (drawImg) drawStyle += `background-image:url('${drawImg}'); color:transparent;`;
    else if (Number(alchemyDrawnCard.val) === 0) drawStyle += `background:#f3e5f5; color:#8e24aa; border-color:#ab47bc;`;

    // HTMLçµ„ã¿ç«‹ã¦
    let html = `
        <div style="background:#37474f; color:white; padding:10px 15px; border-radius:8px; margin-bottom:15px; text-align:left; font-size:12px; display:flex; align-items:center; justify-content:center; box-shadow:inset 0 0 10px rgba(0,0,0,0.5);">
            ${topCardHtml}
            <div>
                <div style="font-size:10px; opacity:0.8;">ç¾åœ¨ã®å ´</div>
                <div style="font-size:18px; font-weight:bold; margin:2px 0;">${topVal}</div>
                <div style="color:#ffb74d; font-weight:bold; border:1px solid #ffb74d; padding:2px 6px; border-radius:4px; display:inline-block; font-size:11px;">${ruleText}</div>
            </div>
        </div>

        <div style="display:flex; justify-content:space-around; align-items:center; margin-bottom:10px; background:#f3e5f5; padding:10px; border-radius:8px;">
            <div style="text-align:center;">
                <div style="font-size:10px; color:#4a148c; font-weight:bold; margin-bottom:5px;">ç´ æA (ãƒ‰ãƒ­ãƒ¼)</div>
                <div class="card num" style="${drawStyle} margin:0 auto;">${alchemyDrawnCard.val}</div>
            </div>
            <div style="font-size:20px; color:#aaa;">+</div>
            <div style="text-align:center;">
                <div style="font-size:10px; color:#4a148c; font-weight:bold; margin-bottom:5px;">ç´ æB (æ‰‹æœ­)</div>
                <div id="alchemy-hand-preview" style="width:54px; height:86px; border:2px dashed #ccc; border-radius:6px; line-height:86px; color:#ccc;">?</div>
            </div>
        </div>

        <p>æ‰‹æœ­ã‹ã‚‰<strong>ç´ æã«ã™ã‚‹æ•°å­—ã‚«ãƒ¼ãƒ‰</strong>ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>
        <div class="modal-list">`;

    // æ‰‹æœ­ãƒªã‚¹ãƒˆ (å¤‰æ›´ãªã—)
    hand.forEach((c, i) => {
        let isNum = (c.type === 'num');
        let isSelected = (alchemyHandIdx === i);
        let style = "transition: transform 0.2s; ";
        let onClick = "";

        if (isNum) {
            style += "cursor:pointer; ";
            if (Number(c.val) === 0) style += 'color:#6a1b9a; border-color:#6a1b9a; ';
            if (isSelected) style += "border:3px solid #7b1fa2; transform:scale(1.1); box-shadow:0 0 10px #7b1fa2;";
            
            if (c.isHacked) {
                style += "cursor:not-allowed; filter:grayscale(100%); border:1px solid #555; background:#333;";
                onClick = `onclick="showInfoModal('ãƒ­ãƒƒã‚¯', 'ãƒãƒƒã‚­ãƒ³ã‚°ã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã¯ç´ æã«ã§ãã¾ã›ã‚“')"`;
            } else {
                onClick = `onclick="selectAlchemistHand(${i})"`;
            }
        } else {
            style += "opacity:0.4; cursor:default; border:1px dashed #999;";
        }
        
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent;`;

        html += `<div class="card ${c.type}" style="${style}" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;

    // éŒ¬é‡‘å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ (ãƒ­ã‚¸ãƒƒã‚¯å¤‰æ›´ãªã—)
    if (alchemyHandIdx !== -1) {
        let val1 = Number(alchemyDrawnCard.val);
        let val2 = Number(hand[alchemyHandIdx].val);

        let sumVal = (val1 + val2) % 10;
        let diffVal = Math.abs(val1 - val2);

        // åˆ¤å®š
        let canSum = canPlay({type:'num', val:sumVal}, top, gameState.isReverse);
        let canDiff = canPlay({type:'num', val:diffVal}, top, gameState.isReverse);

        const makeBtn = (label, val, can) => {
            let bg = can ? "#7b1fa2" : "#e0e0e0"; 
            let color = can ? "white" : "#999";
            let cursor = "pointer"; 
            
            let onClick = "";
            if (can) {
                onClick = `onclick="execAlchemist(${val})"`;
            } else {
                let reason = isRev ? "é€†è¡Œä¸­(å¼±ã„æ–¹ãŒå¼·ã„)ã§ã™" : "é †è¡Œä¸­(å¼·ã„æ–¹ãŒå¼·ã„)ã§ã™";
                let msg = `å ´ã®ã‚«ãƒ¼ãƒ‰[${topVal}]ã«å¯¾ã—ã¦ã€[${val}]ã¯å‡ºã›ã¾ã›ã‚“ã€‚<br>(${reason})`;
                onClick = `onclick="showInfoModal('éŒ¬æˆä¸å¯', '${msg}')"`;
            }

            let note = can ? "" : "<br><span style='font-size:10px; opacity:0.8;'>(Ã— å‡ºã›ã¾ã›ã‚“)</span>";
            
            return `<button ${onClick} style="background:${bg}; color:${color}; padding:10px 5px; border-radius:8px; cursor:${cursor}; width:48%; font-weight:bold; border:none; box-shadow:0 2px 4px rgba(0,0,0,0.2);">
                        ${label} <span style="font-size:18px;">[${val}]</span>${note}
                    </button>`;
        };

        html += `
            <div style="margin-top:15px; padding:10px; background:#fff; border:1px solid #eee; border-radius:8px;">
                <p style="margin:0 0 10px 0; font-weight:bold; color:#333; font-size:12px;">éŒ¬æˆçµæœ (å ´ã®å¼·å¼±ã«å¾“ã†)</p>
                <div style="display:flex; justify-content:space-between; gap:5px;">
                    ${makeBtn("å’Œ (+)", sumVal, canSum)}
                    ${makeBtn("å·® (-)", diffVal, canDiff)}
                </div>
            </div>
        `;
    }

    // ä¸­æ­¢ãƒœã‚¿ãƒ³
    let footerHtml = `<button onclick="execAlchemistKeep()" class="modal-btn" style="background:#78909c; margin-top:10px; width:100%;">
                        éŒ¬é‡‘ä¸­æ­¢ (ç´ æã‚’æ‰‹æœ­ã«åŠ ãˆã‚‹)
                      </button>`;

    openModal("éŒ¬é‡‘è¡“å¸«: ç´ æèåˆ", html);
    document.getElementById("modal-footer").innerHTML = footerHtml;
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
    if (alchemyHandIdx !== -1) {
        let c = hand[alchemyHandIdx];
        let prev = document.getElementById("alchemy-hand-preview");
        if(prev) {
            prev.innerText = c.val;
            prev.style.border = "2px solid #7b1fa2";
            prev.style.color = "#7b1fa2";
            prev.style.fontWeight = "bold";
            prev.style.fontSize = "22px";
            if(Number(c.val)===0) { prev.style.background="#f3e5f5"; prev.style.color="#8e24aa"; prev.style.borderColor="#ab47bc"; }
        }
    }
}

function selectAlchemistHand(idx) {
    alchemyHandIdx = idx;
    renderAlchemistUI();
}

// å®Ÿè¡Œ: æˆåŠŸï¼ˆå ´ã«å‡ºã™ï¼‰
// â†“â†“â†“ execAlchemisté–¢æ•°ã‚’ä¸¸ã”ã¨ã“ã‚Œã«ç½®ãæ›ãˆã¦ãã ã•ã„ â†“â†“â†“
async function execAlchemist(resultVal) {
    closeModal();
    let updates = {};
    
    // æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deck = [...(gameState.deckNum || [])];
    let gn = [...(gameState.graveNum || [])];
    let excl = [...(gameState.exclusion || [])];
    
    // å±±æœ­ãƒã‚§ãƒƒã‚¯
    let realDrawn = deck[deck.length - 1]; 
    if (!realDrawn || Number(realDrawn.val) !== Number(alchemyDrawnCard.val)) {
        return showInfoModal("éŒ¬é‡‘å¤±æ•—", "è© å”±ä¸­ã«å±±æœ­ãŒå¤‰å‹•ã—ã¾ã—ãŸã€‚ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚");
    }
    
    // æ‰‹æœ­ãƒã‚§ãƒƒã‚¯
    if (!hand[alchemyHandIdx] || hand[alchemyHandIdx].isHacked) {
        return showInfoModal("éŒ¬é‡‘å¤±æ•—", "é¸æŠã—ãŸæ‰‹æœ­ãŒãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‹ã€å¤±ã‚ã‚Œã¾ã—ãŸã€‚");
    }

    // å‡¦ç†å®Ÿè¡Œ
    deck.pop(); 
    let realHandCard = hand.splice(alchemyHandIdx, 1)[0];
    
    excl.push(realDrawn);
    excl.push(realHandCard);

    // ç”Ÿæˆã‚«ãƒ¼ãƒ‰ã‚’å ´ã«å‡ºã™
    let createdCard = { type: 'num', val: Number(resultVal), owner: myId, isAlchemy: true };
    gn.push(createdCard);
    
    hand = sortCards(hand);
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckNum`] = deck;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    updates[`rooms/${currentRoom}/graveNum`] = gn;

    await pushLog(`${myName}ãŒéŒ¬é‡‘æˆåŠŸï¼ [${realDrawn.val}](ãƒ‰ãƒ­ãƒ¼)ã¨[${realHandCard.val}](æ‰‹æœ­)ã‚’èåˆã—[${resultVal}]ã‚’å‡ºã—ã¾ã—ãŸã€‚`, 'public');
    
    // â˜…1. ãƒãƒƒã‚­ãƒ³ã‚°æšæ•°ã¨åˆè¨ˆæšæ•°ã®è¨ˆç®—
    let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
    let nextTotal = hand.length + myHackedCount;

    // â˜…2. éŸ³ã®æ±ºå®šï¼ˆã‚¹ã‚­ãƒ«éŸ³ + UNO/DOSï¼‰
    let baseSound = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_ALCHEMIST']) ? 'SKILL_ALCHEMIST' : 'SKILL';
    let soundList = [baseSound];

    if (nextTotal === 1) soundList.push('UNO');
    else if (nextTotal === 2) soundList.push('DOS');

    // éŸ³æƒ…å ±ã‚’é€ä¿¡
    updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // â˜…3. ã‚ãŒã‚Šåˆ¤å®šï¼ˆè¨ˆç®—æ¸ˆã¿ã® myHackedCount ã‚’ä½¿ã†ï¼‰
    if (hand.length === 0 && myHackedCount === 0) {
        let currentRank = Object.keys(gameState.rankings || {}).length + 1;
        updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
        await pushLog(`${myName}ãŒ ${currentRank}ä½ ã§ã‚ãŒã‚Šã¾ã—ãŸï¼`, 'public');
        
        let totalPlayers = gameState.playerOrder.length;
        if (currentRank >= totalPlayers - 1) {
             updates[`rooms/${currentRoom}/status`] = "finished";
             let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
             if(loserId) updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
        }
    }
    
    let tempRankings = {...(gameState.rankings || {})};
    if (hand.length === 0) tempRankings[myId] = 99;

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
    
    alchemyDrawnCard = null;
    alchemyHandIdx = -1;
}

// å®Ÿè¡Œ: ä¸­æ­¢ï¼ˆæ‰‹æœ­ã«åŠ ãˆã‚‹ï¼‰
async function execAlchemistKeep() {
    closeModal();
    let updates = {};
    
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deck = [...(gameState.deckNum || [])];
    
    // å±±æœ­ãƒã‚§ãƒƒã‚¯
    let realDrawn = deck[deck.length - 1]; 
    if (!realDrawn || Number(realDrawn.val) !== Number(alchemyDrawnCard.val)) {
        return showInfoModal("ã‚¨ãƒ©ãƒ¼", "å±±æœ­ã®ä¸æ•´åˆãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
    }
    
    // æ‰‹æœ­ã«åŠ ãˆã‚‹
    deck.pop(); 
    realDrawn.owner = myId; 
    hand.push(realDrawn);
    hand = sortCards(hand);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckNum`] = deck;

    await pushLog(`${myName}ã®éŒ¬é‡‘ã¯ä¸­æ­¢ã•ã‚Œã¾ã—ãŸ(ç´ æã‚’æ‰‹æœ­ã«è¿½åŠ )ã€‚`, 'public');

    // ã‚¹ã‚­ãƒ«ä½¿ç”¨æ¸ˆã¿ & ãƒ‘ã‚¹ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/passCount`] = 0;

    let tempRankings = {...(gameState.rankings || {})};
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
    
    alchemyDrawnCard = null;
    alchemyHandIdx = -1;
}

// ã‚«ãƒƒãƒˆã‚¤ãƒ³å†ç”Ÿé–¢æ•°ï¼ˆç”»åƒå¯¾å¿œç‰ˆï¼‰
function playCutInAnimation(roleKey, roleNameJp, playerName) {
    const overlay = document.getElementById("cut-in-overlay");
    const roleDiv = document.getElementById("cut-in-role");
    const playerDiv = document.getElementById("cut-in-player");
    
    // ç”»åƒãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const imgUrl = ROLE_IMAGES[roleKey];
    
    // ç”»åƒãŒã‚ã‚Œã°èƒŒæ™¯ã«ã‚»ãƒƒãƒˆã€ãªã‘ã‚Œã°é»’èƒŒæ™¯
    if (imgUrl) {
        // ç”»åƒã‚’æš—ãã—ã¦è¡¨ç¤ºï¼ˆæ–‡å­—ã‚’ç›®ç«‹ãŸã›ã‚‹ãŸã‚ linear-gradient ã‚’è¢«ã›ã‚‹ï¼‰
        overlay.style.background = `
            linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)),
            url('${imgUrl}') no-repeat center center / cover
        `;
    } else {
        overlay.style.background = "rgba(0, 0, 0, 0.8)";
    }
        
    // ãƒ†ã‚­ã‚¹ãƒˆã‚»ãƒƒãƒˆ
    roleDiv.innerText = roleNameJp; 
    playerDiv.innerText = playerName;

    overlay.classList.remove("hidden");
    overlay.classList.remove("animate-cut-in");
        
    void overlay.offsetWidth; // ãƒªãƒ•ãƒ­ãƒ¼ç™ºç”Ÿï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†å§‹å‹•ã®ãŠã¾ã˜ãªã„ï¼‰
    overlay.classList.add("animate-cut-in");

    setTimeout(() => {
        overlay.classList.add("hidden");
        overlay.classList.remove("animate-cut-in");
        // çµ‚ã‚ã£ãŸã‚‰èƒŒæ™¯ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ãŠã
        overlay.style.background = "";
    }, 2500);
}

/* --- â˜…è¿½åŠ : æ¼”å‡ºå—ä¿¡ãƒªã‚¹ãƒŠãƒ¼ --- */
function setupEffectListener() {
    // DBã® 'effect' ãƒãƒ¼ãƒ‰ã‚’ç›£è¦–
    db.ref(`rooms/${currentRoom}/effect`).on('value', (snapshot) => {
        let data = snapshot.val();
        if (!data) return;

        // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒå¤ã™ãã‚‹(5ç§’ä»¥ä¸Šå‰)ãªã‚‰ç„¡è¦– (ãƒªãƒ­ãƒ¼ãƒ‰æ™‚ã®æš´ç™ºé˜²æ­¢)
        if (Date.now() - data.timestamp > 5000) return;

        // æ¼”å‡ºå®Ÿè¡Œ
        showVisualEffect(data);
    });
}
// â˜…æ–°è¨­: ãƒ›ã‚¹ãƒˆè¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã
        // â†“â†“â†“ openHostSettingsé–¢æ•°ã‚’ã“ã‚Œã«ç½®ãæ›ãˆã¦ãã ã•ã„ â†“â†“â†“
        function openHostSettings() {
            let check6 = (lastHostHandMode === 6) ? "checked" : "";
            let check4 = (lastHostHandMode === 4) ? "checked" : "";

            let html = `
                <div style="text-align:left; font-size:14px;">
                    <div style="margin-bottom:15px; background:#f9f9f9; padding:10px; border-radius:8px; border:1px solid #eee;">
                        <label style="display:flex; align-items:center; cursor:pointer; margin-bottom:8px;">
                            <input type="radio" name="handMode" value="6" ${check6} style="margin:0 8px 0 0; width:auto; transform:scale(1.2);">
                            <div>
                                <span style="font-weight:bold; color:#2e7d32;">é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ (6æš)</span>
                                <span style="font-size:11px; color:#888; margin-left:5px;">â€• æ•°å­—6 + è¨˜å·2</span>
                            </div>
                        </label>
                        <label style="display:flex; align-items:center; cursor:pointer;">
                            <input type="radio" name="handMode" value="4" ${check4} style="margin:0 8px 0 0; width:auto; transform:scale(1.2);">
                            <div>
                                <span style="font-weight:bold; color:#ef6c00;">çŸ­æœŸæ±ºæˆ¦ (4æš)</span>
                                <span style="font-size:11px; color:#888; margin-left:8px;">â€• æ•°å­—4 + è¨˜å·2</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="display:flex; gap:10px;">
                        <button onclick="confirmInitGameWithSettings()" style="flex:1; background:linear-gradient(135deg, #66bb6a, #43a047); color:white; padding:10px; font-weight:bold; border-radius:20px; box-shadow:0 2px 5px rgba(0,0,0,0.2);">
                            é–‹å§‹ / ãƒªã‚»ãƒƒãƒˆ
                        </button>
                        <button onclick="confirmCloseRoom()" style="width:80px; background:#ef5350; color:white; padding:10px; font-size:11px; border-radius:20px;">
                            è§£æ•£
                        </button>
                    </div>
                </div>
            `;
            openModal("ãƒ›ã‚¹ãƒˆè¨­å®š", html);
        }

        // â˜…æ–°è¨­: è¨­å®šå€¤ã‚’èª­ã¿å–ã£ã¦é–‹å§‹ç¢ºèªã¸
        function confirmInitGameWithSettings() {
            const modeEls = document.getElementsByName('handMode');
            for(let el of modeEls) { if(el.checked) lastHostHandMode = parseInt(el.value); }

            // ç¢ºèªç”»é¢ã¸åˆ‡ã‚Šæ›¿ãˆ
            els.mTitle.innerText = "é–‹å§‹ç¢ºèª";
            els.mContent.innerHTML = `<p><strong>${lastHostHandMode}æšãƒ¢ãƒ¼ãƒ‰</strong> ã§<br>ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ï¼ˆãƒªã‚»ãƒƒãƒˆï¼‰ã—ã¾ã™ã‹ï¼Ÿ</p>`;
            els.mFooter.innerHTML = `
                <button onclick="closeModal(); execInitGame(${lastHostHandMode})" class="modal-btn primary">ã¯ã„</button>
                <button onclick="openHostSettings()" class="modal-btn">æˆ»ã‚‹</button>
            `;
        }

        /* ===============================================
           iPhoneå¯¾ç­–: ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆå¾Œã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå¾©æ´»å‡¦ç†
           =============================================== */
        
        // 1. ãƒšãƒ¼ã‚¸ãŒå†ã³ã€Œè¦‹ãˆã‚‹çŠ¶æ…‹ã€ã«ãªã£ãŸã‚‰èµ·ã“ã™
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                checkAndResumeAudio();
            }
        });

        // 2. ç”»é¢ã‚’ã‚¿ãƒƒãƒã—ãŸã¨ãã‚‚å¿µã®ãŸã‚èµ·ã“ã™
        document.addEventListener('touchstart', function() {
            checkAndResumeAudio();
        }, { passive: true }); // passive: true ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ€§èƒ½ã¸ã®é…æ…®

        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ã€æ­»ã‚“ã§ãŸã‚‰å†é–‹ã•ã›ã‚‹é–¢æ•°
        function checkAndResumeAudio() {
            if (!audioCtx) return;

            // 'suspended' (ä¸€æ™‚åœæ­¢) ã‚„ 'interrupted' (å‰²ã‚Šè¾¼ã¿åœæ­¢) ãªã‚‰å†é–‹
            if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
                audioCtx.resume().then(() => {
                    console.log("AudioContext Resumed by User Action/Visibility");
                }).catch(e => {
                    console.log("AudioContext Resume Failed", e);
                });
            }
        }
    
        // Global exports
        window.joinGame = joinGame;
        window.playCard = playCard;
        window.passTurn = passTurn;
        window.initGame = confirmInitGame; 
        window.viewGrave = viewGrave;
        window.closeModal = closeModal;
        window.execDigUp = execDigUp;
        window.tradeStep2 = tradeStep2;
        window.tradeStep3 = tradeStep3; // â˜…è¿½åŠ : å¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠ
        window.execTrade = execTrade;
        window.execDiscard = execDiscard;
        window.execPassDraw = execPassDraw;
        window.execPassNoDraw = execPassNoDraw;
        window.execPassPlay = execPassPlay;
        window.execPassKeep = execPassKeep;
        window.execPassReset = execPassReset;
        window.closeRoom = confirmCloseRoom;
        window.execInitGame = execInitGame;
        window.execCloseRoom = execCloseRoom;
        window.showLogHistory = showLogHistory;
        window.sendChat = sendChat;
        window.playCutInAnimation = playCutInAnimation;
        window.openHostSettings = openHostSettings;
        window.confirmInitGameWithSettings = confirmInitGameWithSettings;
        // é‡£ã‚Šäºº
        window.activateAngler = activateAngler;
        window.anglerStep2 = anglerStep2;
        window.execAngler = execAngler;
        // å ã„å¸«
        window.activateFortuneTeller = activateFortuneTeller;
        // ç›—è³Š
        window.activateThief = activateThief;
        window.thiefSelectTake = thiefSelectTake; // â˜…è¿½åŠ 
        window.thiefSelectGive = thiefSelectGive; // â˜…è¿½åŠ (åå‰å¤‰æ›´)
        window.execThiefTrade = execThiefTrade;
        window.endThiefTurn = endThiefTurn;
        // ç‹©äºº
        window.activateHunter = activateHunter;
        window.toggleHunterSelect = toggleHunterSelect; // æ–°ã—ã„é–¢æ•°
        window.checkHunterCount = checkHunterCount;     // æ–°ã—ã„é–¢æ•°
        window.execHunterSwap = execHunterSwap;
        // è³­åšå¸«
        window.activateGambler = activateGambler;
        window.execGamblerGuess = execGamblerGuess;
        window.gamblerSelectDiscard = gamblerSelectDiscard;
        window.toggleGamblerSelect = toggleGamblerSelect;
        window.execGamblerDiscard = execGamblerDiscard;
        // æ‰‹å“å¸«
        window.activateMagician = activateMagician;
        window.execMagicianReverse = execMagicianReverse;
        window.activateMagicianTrade = activateMagicianTrade;
        window.magicianSelectTake = magicianSelectTake; // â˜…æ–°è¨­
        window.magicianSelectGive = magicianSelectGive; // â˜…åå‰å¤‰æ›´
        window.activateMagicianDigUp = activateMagicianDigUp;
        window.execMagicianDigUp = execMagicianDigUp;
        // å¯Œè±ª
        window.activateMillionaire = activateMillionaire;
        window.execMillionaire = execMillionaire;
        // çš‡å¸
        window.activateEmperor = activateEmperor;
        window.execEmperorSelect = execEmperorSelect;
        // è­¦å¯Ÿå®˜
        window.activatePoliceOfficer = activatePoliceOfficer;
        window.policeTradeStart = policeTradeStart;
        window.endPoliceTurn = endPoliceTurn;
        window.policeSelectTake = policeSelectTake; // â˜…è¿½åŠ : å¥ªã†ã‚«ãƒ¼ãƒ‰é¸æŠ
        window.policeSelectGive = policeSelectGive;
        window.execPoliceTrade = execPoliceTrade;
        // æ–°å’
        window.activateNewGrad = activateNewGrad;
        window.execNewGradCopy = execNewGradCopy;
        // ãƒãƒƒã‚«ãƒ¼
        window.activateHacker = activateHacker;
        window.selectHackerTarget = selectHackerTarget;
        window.execHacker = execHacker;
        window.checkHackerCleanup = checkHackerCleanup;
        // éŒ¬é‡‘è¡“å¸«
        window.activateAlchemist = activateAlchemist;
        window.selectAlchemistHand = selectAlchemistHand;
        window.execAlchemist = execAlchemist;
        window.execAlchemistKeep = execAlchemistKeep; // â˜…åå‰å¤‰æ›´ (Keep)

    </script>
</body>
</html>