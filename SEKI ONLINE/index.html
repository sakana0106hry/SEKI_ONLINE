<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SEKI Online</title>
    <link rel="stylesheet" href="styles/fonts.css">
    <style>
    /* ベース設定：タイトル画面に寄せた全体テーマ */
    :root {
        --seki-s: #00d8ff;
        --seki-e: #34f78d;
        --seki-k: #ff355e;
        --seki-bg: #030a15;
        --seki-bg-deep: #02060e;
        --seki-bg-mid: #050d19;
        --seki-bg-bright: #0e2342;
        --seki-text-main: #eff6ff;
        --seki-text-sub: #d9ebff;
        --seki-text-muted: #9cb3c9;
        --seki-danger: #ef5350;
        --seki-warning: #ffeb3b;
        --seki-success: #34f78d;
        --seki-card-border: rgba(165, 205, 255, 0.35);
        --seki-panel-border: rgba(0, 216, 255, 0.32);
        --seki-panel-bg: rgba(4, 11, 23, 0.76);
        --seki-panel-bg-soft: rgba(6, 16, 32, 0.55);
        --seki-radius-sm: 8px;
        --seki-radius-md: 12px;
        --seki-radius-lg: 18px;
        --seki-shadow-soft: 0 8px 20px rgba(0, 0, 0, 0.36);
        --seki-shadow-panel: 0 18px 40px rgba(0, 0, 0, 0.52);
        --seki-shadow-glow: 0 0 26px rgba(0, 216, 255, 0.22);
        --seki-transition-fast: 0.2s ease;
        --seki-transition-mid: 0.3s ease;
    }

    body {
        font-family: var(--font-ui);
        background:
            radial-gradient(circle at 18% 14%, rgba(0, 216, 255, 0.14), transparent 36%),
            radial-gradient(circle at 82% 24%, rgba(255, 53, 94, 0.11), transparent 34%),
            radial-gradient(circle at 70% 78%, rgba(52, 247, 141, 0.08), transparent 36%),
            radial-gradient(circle at 50% 110%, #0e2342 0%, #050d19 48%, #02060e 100%);
        background-attachment: fixed;
        color: var(--seki-text-main);
        margin: 0;
        text-align: center;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        min-height: 100dvh;
        overflow-y: auto;
        overflow-x: hidden;
        display: flex;
        flex-direction: column;
    }

    /* 共通レイアウト */
    #game-screen {
        position: relative;
        isolation: isolate;
        padding: 0;
        margin: 0 auto;
        width: 100%;
        max-width: 860px;
        height: auto;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: visible;
        background: linear-gradient(155deg, rgba(6, 16, 32, 0.5), rgba(2, 8, 18, 0.35));
        border-left: 1px solid rgba(0, 216, 255, 0.11);
        border-right: 1px solid rgba(0, 216, 255, 0.11);
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.35);
    }
    #game-screen::before,
    #game-screen::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: -1;
    }
    #game-screen::before {
        background:
            linear-gradient(rgba(45, 100, 190, 0.11) 1px, transparent 1px),
            linear-gradient(90deg, rgba(45, 100, 190, 0.11) 1px, transparent 1px);
        background-size: 42px 42px;
        opacity: 0.45;
        animation: gameGridShift 22s linear infinite;
    }
    #game-screen::after {
        background: repeating-linear-gradient(
            to bottom,
            rgba(255, 255, 255, 0.026) 0px,
            rgba(255, 255, 255, 0.026) 1px,
            rgba(0, 0, 0, 0) 1px,
            rgba(0, 0, 0, 0) 4px
        );
        opacity: 0.24;
    }
    #header-info {
        flex: 0 0 42px;
        padding: 8px 10px;
    }
    .hidden { display: none !important; }
    .seki-topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 10px;
        font-size: 12px;
        height: 42px;
        border-bottom: 1px solid rgba(0, 216, 255, 0.22);
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.28), rgba(0, 0, 0, 0.12));
        backdrop-filter: blur(6px);
    }
    .seki-topbar-actions {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    .seki-msg {
        margin-top: 2px;
        color: var(--seki-warning);
        font-weight: bold;
        font-size: 12px;
        height: 18px;
        line-height: 18px;
        white-space: nowrap;
        text-shadow: 0 0 8px rgba(255, 235, 59, 0.3);
    }
    .seki-controls {
        margin-top: 5px;
    }
    .seki-controls .seki-btn {
        min-width: 84px;
    }
    .seki-btn {
        border: 1px solid var(--seki-card-border);
        border-radius: 16px;
        background: linear-gradient(135deg, rgba(4, 14, 30, 0.95), rgba(8, 22, 44, 0.92));
        color: var(--seki-text-main);
        font-family: var(--font-ui);
        font-size: 13px;
        font-weight: 700;
        padding: 5px 12px;
        cursor: pointer;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.35);
        transition: transform var(--seki-transition-fast), box-shadow var(--seki-transition-fast), border-color var(--seki-transition-fast), filter var(--seki-transition-fast);
    }
    .seki-btn:hover:not(:disabled) {
        transform: translateY(-1px);
        border-color: rgba(0, 216, 255, 0.66);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45), 0 0 14px rgba(0, 216, 255, 0.2);
    }
    .seki-btn:active:not(:disabled) {
        transform: translateY(1px);
    }
    .seki-btn:disabled,
    .seki-btn.is-disabled {
        background: rgba(84, 99, 118, 0.85);
        border-color: rgba(132, 147, 168, 0.7);
        color: rgba(239, 246, 255, 0.7);
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
        opacity: 0.78;
    }
    .seki-btn-mini {
        font-size: 12px;
        padding: 4px 9px;
    }
    .seki-btn-host {
        padding: 5px 12px;
        font-size: 15px;
        display: flex;
        align-items: center;
        border-radius: 18px;
    }
    .seki-btn-gold {
        background: linear-gradient(135deg, #bd8b14, #fbc02d 52%, #ffe082);
        color: #2f2214;
        border-color: rgba(255, 230, 156, 0.62);
    }
    .seki-btn-accent {
        background: linear-gradient(135deg, #0f314d, #166d98 46%, #00d8ff);
        color: #effbff;
        border-color: rgba(0, 216, 255, 0.65);
    }
    .seki-btn-danger {
        background: linear-gradient(135deg, #7c132a, #c21e44 46%, #ff355e);
        border-color: rgba(255, 143, 166, 0.75);
        color: #fff5f8;
    }
    .seki-btn-soft {
        background: linear-gradient(135deg, #2c3b54, #546e7a);
        border-color: rgba(197, 222, 255, 0.4);
    }
    .seki-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 9999;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: none;
        color: var(--seki-text-main);
        background: rgba(1, 6, 14, 0.88);
        backdrop-filter: blur(4px);
    }
    #squeeze-guess {
        position: absolute;
        top: 10%;
        font-size: 24px;
        color: var(--seki-warning);
        text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
    }
    .seki-visual-card {
        position: relative;
        width: 200px;
        height: 300px;
        border: 4px solid rgba(255, 255, 255, 0.95);
        border-radius: 10px;
        overflow: hidden;
        background: #fff;
    }
    #squeeze-content {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 150px;
        color: #333;
        font-weight: bold;
    }
    #squeeze-cover {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(45deg, #1a237e, #1a237e 10px, #283593 10px, #283593 20px);
        transition: top 5s ease-in-out;
    }
    .seki-visual-cover-logo {
        color: rgba(255, 255, 255, 0.2);
        font-size: 50px;
        text-align: center;
        padding-top: 100px;
    }
    #squeeze-result {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-size: 80px;
        font-weight: bold;
        text-shadow: 2px 2px 0 #000;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        opacity: 0;
    }
    
    /* --- S.E.K.I. タイトル画面（ログイン専用） --- */
    #login-screen {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 20px;
        overflow: hidden;
        isolation: isolate;
        background: radial-gradient(circle at 50% 100%, #0e2342 0%, #050d19 48%, #02060e 100%);
    }

    #login-cyber-bg,
    .login-grid,
    .login-scanlines {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }
    #login-cyber-bg { z-index: 0; }

    .login-grid {
        z-index: 1;
        background:
            radial-gradient(circle at 18% 16%, rgba(0, 216, 255, 0.22), transparent 44%),
            radial-gradient(circle at 82% 26%, rgba(255, 53, 94, 0.14), transparent 36%),
            radial-gradient(circle at 74% 84%, rgba(52, 247, 141, 0.16), transparent 40%),
            linear-gradient(rgba(45, 100, 190, 0.18) 1px, transparent 1px),
            linear-gradient(90deg, rgba(45, 100, 190, 0.18) 1px, transparent 1px);
        background-size: auto, auto, auto, 48px 48px, 48px 48px;
        animation: loginGridShift 16s linear infinite;
    }

    .login-scanlines {
        z-index: 2;
        background: repeating-linear-gradient(
            to bottom,
            rgba(255, 255, 255, 0.05) 0px,
            rgba(255, 255, 255, 0.05) 1px,
            rgba(0, 0, 0, 0) 1px,
            rgba(0, 0, 0, 0) 4px
        );
        opacity: 0.3;
        animation: loginScanlineShift 10s linear infinite;
    }

    #login-panel {
        position: relative;
        z-index: 3;
        width: min(92vw, 520px);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding: 34px 30px 30px;
        border-radius: 20px;
        border: 1px solid rgba(0, 216, 255, 0.42);
        background:
            linear-gradient(155deg, rgba(6, 16, 32, 0.85), rgba(4, 11, 23, 0.72)),
            radial-gradient(circle at 14% 18%, rgba(0, 216, 255, 0.12), transparent 38%);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        box-shadow:
            0 24px 54px rgba(0, 0, 0, 0.62),
            0 0 40px rgba(0, 216, 255, 0.16),
            inset 0 0 25px rgba(0, 216, 255, 0.08);
        animation: loginPanelPulse 6s ease-in-out infinite alternate;
    }

    #title-logo {
        width: 100%;
        max-width: 450px;
        height: auto;
        object-fit: contain;
        filter:
            drop-shadow(0 0 14px rgba(0, 216, 255, 0.38))
            drop-shadow(0 0 26px rgba(255, 53, 94, 0.2));
        animation: loginLogoFloat 3.8s ease-in-out infinite alternate;
        margin-bottom: 2px;
    }

    .version-text {
        margin: 0;
        font-family: var(--font-ui);
        font-size: 12px;
        letter-spacing: 1.5px;
        color: #cfe8ff;
        text-shadow: 0 0 10px rgba(0, 216, 255, 0.36);
        opacity: 0.92;
    }

    .seki-tagline {
        margin: 12px 0;
        font-size: 12px;
        color: #d9ebff;
        letter-spacing: 0.8px;
        text-shadow: 0 0 8px rgba(0, 216, 255, 0.22);
    }

    #login-screen input {
        width: 100%;
        border: 1px solid rgba(165, 205, 255, 0.3);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.3);
        color: #eff6ff;
        padding: 13px 14px;
        font-size: 15px;
        font-family: var(--font-ui);
        letter-spacing: 1px;
        text-align: center;
        appearance: none;
        -webkit-appearance: none;
        transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.2s ease;
    }
    #login-screen input::placeholder { color: rgba(216, 235, 255, 0.56); }
    #login-screen input:focus {
        outline: none;
        transform: translateY(-1px);
    }
    #roomName:focus {
        border-color: var(--seki-s);
        box-shadow: 0 0 0 2px rgba(0, 216, 255, 0.2), 0 0 18px rgba(0, 216, 255, 0.36);
    }
    #playerName:focus {
        border-color: var(--seki-e);
        box-shadow: 0 0 0 2px rgba(52, 247, 141, 0.18), 0 0 18px rgba(52, 247, 141, 0.35);
    }

    #login-screen input:-webkit-autofill,
    #login-screen input:-webkit-autofill:hover,
    #login-screen input:-webkit-autofill:focus {
        -webkit-text-fill-color: #eff6ff;
        -webkit-box-shadow: 0 0 0 1000px rgba(0, 0, 0, 0.3) inset;
        box-shadow: 0 0 0 1000px rgba(0, 0, 0, 0.3) inset;
        caret-color: #eff6ff;
        transition: background-color 9999s ease-out 0s;
    }

    #room-suggestion-panel {
        width: 100%;
        max-height: 170px;
        overflow-y: auto;
        margin-top: -2px;
        margin-bottom: 2px;
        font-family: var(--font-ui);
        border-radius: 12px;
        border: 1px solid rgba(0, 216, 255, 0.33);
        background: rgba(2, 10, 20, 0.92);
        box-shadow: inset 0 0 14px rgba(0, 216, 255, 0.1), 0 8px 20px rgba(0, 0, 0, 0.36);
    }
    .room-suggestion-title {
        font-family: var(--font-ui);
        font-size: 11px;
        letter-spacing: 0.5px;
        color: #a5cfff;
        padding: 8px 10px 5px;
        text-align: left;
    }
    .room-suggestion-item {
        width: 100%;
        border: none;
        background: transparent;
        color: #e8f4ff;
        text-align: left;
        padding: 9px 10px;
        font-family: var(--font-ui);
        font-size: 13px;
        cursor: pointer;
        transition: background 0.18s ease;
    }
    .room-suggestion-item:hover {
        background: rgba(0, 216, 255, 0.12);
    }
    .room-suggestion-empty {
        padding: 10px;
        font-family: var(--font-ui);
        font-size: 12px;
        text-align: left;
        color: #9cb3c9;
    }

    #login-screen #btn-join {
        width: 100%;
        margin-top: 8px;
        padding: 14px 18px;
        border: 1px solid rgba(255, 143, 166, 0.72);
        border-radius: 12px;
        background: linear-gradient(135deg, #8f0f2d 0%, #d81f48 42%, #ff355e 100%);
        color: #fff5f8;
        font-family: var(--font-ui);
        font-size: 16px;
        font-weight: 800;
        letter-spacing: 1px;
        cursor: pointer;
        text-transform: uppercase;
        clip-path: polygon(4% 0%, 100% 0%, 100% 84%, 96% 100%, 0% 100%, 0% 16%);
        box-shadow: 0 10px 24px rgba(255, 53, 94, 0.32), 0 0 20px rgba(255, 53, 94, 0.28);
        transition: transform 0.22s ease, box-shadow 0.22s ease, filter 0.22s ease;
    }
    #login-screen #btn-join:hover {
        transform: translateY(-1px) scale(1.01);
        filter: saturate(1.15);
        box-shadow: 0 14px 34px rgba(255, 53, 94, 0.42), 0 0 26px rgba(255, 53, 94, 0.46);
    }
    #login-screen #btn-join:active { transform: translateY(1px); }
    #login-screen #btn-join:disabled {
        background: #4d5563;
        border-color: #6c7482;
        clip-path: none;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }

    @keyframes loginPanelPulse {
        0% { box-shadow: 0 24px 54px rgba(0, 0, 0, 0.62), 0 0 34px rgba(0, 216, 255, 0.14), inset 0 0 20px rgba(0, 216, 255, 0.08); }
        100% { box-shadow: 0 24px 54px rgba(0, 0, 0, 0.7), 0 0 46px rgba(0, 216, 255, 0.25), inset 0 0 25px rgba(52, 247, 141, 0.08); }
    }
    @keyframes loginLogoFloat {
        0% { transform: translateY(0px); }
        100% { transform: translateY(-6px); }
    }
    @keyframes loginGridShift {
        0% { transform: translate3d(0, 0, 0); }
        100% { transform: translate3d(-20px, -24px, 0); }
    }
    @keyframes loginScanlineShift {
        0% { transform: translateY(0); }
        100% { transform: translateY(4px); }
    }
    @keyframes gameGridShift {
        0% { transform: translate3d(0, 0, 0); }
        100% { transform: translate3d(-18px, -16px, 0); }
    }

    @media (max-width: 600px) {
        #login-screen { padding: 12px; }
        #login-panel {
            width: min(94vw, 440px);
            padding: 24px 18px 22px;
            gap: 8px;
            border-radius: 16px;
        }
        #title-logo { max-width: 340px; }
        .seki-tagline { margin: 10px 0; font-size: 11px; }
        #login-screen input { padding: 11px 12px; font-size: 14px; }
        #login-screen #btn-join { font-size: 14px; padding: 12px 14px; }
    }

    @media (prefers-reduced-motion: reduce) {
        .login-grid,
        .login-scanlines,
        #login-panel,
        #title-logo,
        #game-screen::before {
            animation: none !important;
        }
        #login-screen input,
        #login-screen #btn-join,
        .seki-btn {
            transition: none !important;
        }
    }

    /* エリアごとのパネル化（グラスモーフィズム） */
    #my-area {
        background: linear-gradient(155deg, rgba(6, 16, 32, 0.82), rgba(4, 11, 23, 0.74));
        backdrop-filter: blur(7px);
        border-radius: var(--seki-radius-lg);
        border: 1px solid var(--seki-panel-border);
        padding: 15px;
        box-shadow: var(--seki-shadow-panel), inset 0 0 18px rgba(0, 216, 255, 0.08);
        margin-top: 10px;
    }

    /* カード・盤面デザイン */
    .pile { 
        width: 60px; height: 90px; 
        border: 2px dashed rgba(173, 214, 255, 0.62); 
        border-radius: var(--seki-radius-sm);
        margin: auto; display:flex; align-items:center; justify-content:center; 
        background: linear-gradient(155deg, rgba(6, 16, 32, 0.7), rgba(3, 10, 20, 0.56)); 
        cursor: pointer;
        box-shadow: inset 0 0 12px rgba(0, 216, 255, 0.11);
        transition: transform var(--seki-transition-fast), border-color var(--seki-transition-fast), box-shadow var(--seki-transition-fast), background var(--seki-transition-fast); 
    }
    .pile:hover {
        background: linear-gradient(155deg, rgba(8, 26, 48, 0.82), rgba(4, 14, 28, 0.74));
        border-color: var(--seki-warning);
        transform: scale(1.05);
        box-shadow: 0 0 12px rgba(255, 235, 59, 0.25), inset 0 0 14px rgba(0, 216, 255, 0.24);
    }

    .card { 
        width: 54px; height: 86px; 
        background-color: #f5fbff;
        color: #1f2a3a; 
        border-radius: 6px; 
        border: 1px solid #a3b9d6;
        box-shadow: 2px 2px 8px rgba(0,0,0,0.38); /* カードの影 */
        display: inline-flex; align-items: center; justify-content: center; 
        font-weight: bold; margin: 3px; font-size: 22px; 
        cursor: pointer; position: relative; 
        transition: transform var(--seki-transition-fast) cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow var(--seki-transition-fast), border-color var(--seki-transition-fast);
        vertical-align: bottom;
        background-size: cover; background-position: center; background-repeat: no-repeat;
    }
    /* カードの動き */
    .card:not(.selected):hover {
        transform: translateY(-8px) rotate(2deg);
        z-index: 5;
        border-color: rgba(0, 216, 255, 0.55);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.45), 0 0 10px rgba(0, 216, 255, 0.18);
    }
    
    .card.num { color: #1565c0; font-family: var(--font-display-strong); }
    .card.sym { color: #c62828; font-size: 11px; text-align:center; line-height:1.1; letter-spacing: -0.5px;}
    /*.card[data-val="0"] { border: 2px solid #ab47bc; color: #8e24aa; background: #f3e5f5; }*/

    /* 選択状態：光るエフェクト */
    .selected { 
        transform: translateY(-20px) scale(1.1) !important; 
        border: 2px solid var(--seki-warning); 
        box-shadow: 0 0 15px rgba(255, 235, 59, 0.9), 0 10px 20px rgba(0,0,0,0.5); 
        z-index: 100; 
    }
    .card.has-img { color: transparent !important; font-size: 0; border: 2px solid rgba(255, 255, 255, 0.9); }

    /* 他プレイヤー表示 */
    /* --- 円卓レイアウト用CSS --- */
    /* --- アニメーション定義 (光る演出用) --- */
    @keyframes pulse-yellow {
        0% { box-shadow: 0 0 5px #ffeb3b; }
        50% { box-shadow: 0 0 15px #ffeb3b, 0 0 5px rgba(255,235,59,0.5) inset; }
        100% { box-shadow: 0 0 5px #ffeb3b; }
    }
    @keyframes blink-red {
        0% { border-color: #ff1744; background-color: rgba(255, 23, 68, 0.1); }
        50% { border-color: #b71c1c; background-color: rgba(255, 23, 68, 0.3); }
        100% { border-color: #ff1744; background-color: rgba(255, 23, 68, 0.1); }
    }
    @keyframes blink-orange {
        0% { border-color: #ff9800; }
        50% { border-color: #ffe0b2; }
        100% { border-color: #ff9800; }
    }
    @keyframes pulse-badge { from{transform:scale(1);} to{transform:scale(1.3);} }

    /* --- 円卓レイアウト用 (画面分割) --- */
    #game-table {
        /* 残りの高さを全部使う */
        flex: 1;
        
        display: flex;
        flex-direction: column;
        width: 100%;
        position: relative;
        
        /* ★ここが重要：入り切らない場合はここだけスクロールさせる */
        overflow-y: visible; 
        
        /* ★ログバー(35px)と被らないよう、底上げする */
        padding-bottom: 80px !important; 
        
        /* 横のパディング */
        padding-left: 10px;
        padding-right: 10px;
        box-sizing: border-box;
        
        /* 高さ指定（calc）は削除して auto に */
        height: auto !important; 
    }

    /* エリア定義 */
    #area-top {
        height: 15%; /* 画面上部 */
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: 10px;
        padding-bottom: 5px;
    }

    #area-middle {
        flex: 1; /* 残りのスペース */
        display: flex;
        align-items: center;
        /* justify-content: space-between;  ← これを削除して */
        justify-content: center;         /* ← これに変更！ */
        gap: 5px;                        /* ← 間隔を少し空ける */
        width: 100%;
        position: relative;
    }
    /* ↓↓↓ 追加: 自分の手番のときの強調表示 ↓↓↓ */
    #my-area.current-turn {
        border: 2px solid var(--seki-warning) !important;
        box-shadow: 0 0 30px rgba(255, 235, 59, 0.45), 0 0 20px rgba(0, 216, 255, 0.2);
        background: linear-gradient(155deg, rgba(42, 38, 8, 0.88), rgba(18, 25, 38, 0.78));
        transform: translateY(-2px);                /* ほんの少し浮き上がる */
        transition: all 0.3s ease;
    }

    /* サイドバー (左右のプレイヤー) */
    /* --- プレイヤーエリアの枠組み --- */
    /* サイドバーの幅を少し広げて、プレイヤーボックスが入るようにする */
    /* --- 1. エリア定義の調整 (ボックス拡大に合わせて広げる) --- */
    
    /* 左右のサイドバー：幅を広げる */
    .player-zone.col {
        width: 150px; /* 80px -> 110px -> 130px に拡大 */
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 10px;
        z-index: 10; /* 中央フィールドより手前に表示 */
    }

    /* 上部エリア：高さを確保 */
    #area-top {
        height: auto;
        min-height: 130px; /* ボックスがしっかり入る高さ */
        display: flex;
        justify-content: center;
        align-items: flex-end; /* 下揃え */
        gap: 12px; /* 横並び時の隙間 */
        padding-bottom: 5px;
        z-index: 10;
    }
    /* ↓↓↓ 追加: 自分のネームプレート（ヘッダー風） ↓↓↓ */
    .my-name-plate {
        background: linear-gradient(155deg, rgba(6, 18, 35, 0.82), rgba(4, 11, 23, 0.74));
        border-bottom: 1px solid rgba(0, 216, 255, 0.28);
        padding: 8px 15px;
        margin: -15px -15px 10px -15px;       /* 親のpadding(15px)を相殺して上端に密着 */
        border-radius: var(--seki-radius-lg) var(--seki-radius-lg) 0 0;
        
        font-weight: bold;
        font-size: 14px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 6px;
        color: var(--seki-text-main);
        text-shadow: 0 1px 2px rgba(0,0,0,0.8), 0 0 8px rgba(0, 216, 255, 0.2);
        position: relative;
        overflow: visible;
    }
    .my-host-icon {
        color: #ffd700;
        margin-right: 4px;
    }
    .my-name-link {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-thickness: 1px;
        text-underline-offset: 2px;
    }
    .my-role-chip {
        margin-left: 10px;
        color: #8fefff;
    }
    .my-role-chip.used {
        color: #95a6ba;
    }
    .my-reset-badge {
        margin-left: 10px;
        font-size: 12px;
        vertical-align: middle;
        display: inline-block;
    }
    .my-rank-badge {
        color: #ffd700;
        margin-left: 10px;
        text-shadow: 0 0 6px rgba(255, 196, 0, 0.5);
    }

    /* --- 2. プレイヤープレート本体 (サイズアップ) --- */
    .p-box-new {
        width: 140px;            /* 横幅 */
        height: 110px;           /* ★高さを数値で強制固定！ */
        
        display: flex;
        flex-direction: column;  /* 縦並び */
        justify-content: space-between; /* 上・中・下をきっちり配置 */
        
        background: linear-gradient(150deg, rgba(6, 16, 32, 0.9), rgba(4, 11, 23, 0.84));
        border: 1px solid rgba(0, 216, 255, 0.32);
        border-radius: 10px;
        box-shadow: 0 6px 14px rgba(0,0,0,0.6);
        transition: transform var(--seki-transition-mid), border-color var(--seki-transition-mid), box-shadow var(--seki-transition-mid), background var(--seki-transition-mid);
        overflow: visible !important;        /* ★はみ出した分はカット（これで伸びない） */
    }

    /* 手番のときの強調 */
    .p-box-new.current {
        border: 2px solid var(--seki-warning);
        box-shadow: 0 0 20px rgba(255, 235, 59, 0.65), 0 0 14px rgba(0, 216, 255, 0.2);
        background: linear-gradient(145deg, rgba(61, 54, 14, 0.92), rgba(12, 22, 36, 0.85));
        z-index: 100;
        /* currentで拡大させるとレイアウトが崩れることがあるので、
           scaleではなく translate や shadow だけで目立たせるのが安全ですが、
           一旦 scale(1.05) はそのままでいきます */
        transform: scale(1.05);
    }

    /* --- 3. 内部パーツ (文字サイズ拡大) --- */

    /* ヘッダー（名前） */
    .p-header {
        height: 26px;            /* ★高さ固定 */
        line-height: 26px;       /* 垂直中央 */
        padding: 0 4px;
        background: rgba(8, 26, 48, 0.64);
        border-bottom: 1px solid rgba(0, 216, 255, 0.24);
        font-size: 13px;
        font-weight: bold;
        color: #f3fbff;
        white-space: nowrap;     /* 改行させない */
        overflow: hidden;
        text-overflow: ellipsis; /* 長すぎたら...にする */
    }

    .p-host-mark { color: #ffd700; margin-right: 4px; font-size: 13px; }

    /* --- 3段固定レイアウト用の修正 --- */

    /* 中段：手札数とステータスを横並びに */
    .p-body {
        flex: 1;                 /* ★余った高さを全部使う */
        display: flex;
        flex-direction: row;     /* 横並び */
        justify-content: space-between;
        align-items: center;
        padding: 0 8px;
        border-bottom: 1px solid rgba(0, 216, 255, 0.2);
    }

    /* 左側：手札枚数（フォントサイズはそのまま維持） */
    .p-hand-count {
        flex-shrink: 0 !important;      /* 横幅が足りなくても、絶対に縮めない！ */
        white-space: nowrap !important; /* 勝手に改行させない！ */
        font-size: 24px;         /* ★そのまま！ */
        font-weight: 800;
        color: #fff;
        display: flex; 
        align-items: center; 
        gap: 2px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }
    .p-hand-count.count-danger {
        color: #ff1744;
        text-shadow: 0 0 10px #ff1744;
        animation: blink-text 0.6s infinite;
    }
    .p-hand-count.count-warning {
        color: #ffeb3b;
        text-shadow: 0 0 10px #ffeb3b;
        animation: blink-text 1.2s infinite;
    }
    .p-hand-count.count-passed {
        color: #78909c;
    }
    .p-hand-icon { font-size: 16px; opacity: 0.8; margin-right: 2px; } 

    /* 右側：ステータス表示エリア */
    .p-status-area {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        justify-content: center;
    }
    
    /* ステータス文字のスタイル定義 */
    .status-text { font-size: 10px; font-weight: bold; letter-spacing: 1px; }
    
    .status-normal { color: #8aa0b8; }
    
    .status-reset { 
        color: #ffeb3b; 
        animation: pulse-yellow 2s infinite; 
        border: 1px solid #ffeb3b;
        padding: 0 4px;
        border-radius: 4px;
        background: rgba(0,0,0,0.3);
    }
    
    .status-rank {
        color: #ffd700;
        font-size: 14px; /* 順位は少し大きく */
        text-shadow: 0 0 5px #ff9800;
    }

    /* 下段：役職エリア（高さ固定） */
    .p-role-row {
        height: 30px;            /* ★高さ固定 */
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(4, 12, 24, 0.5);
        padding: 0 4px;
    }

    /* --- 役職バッジ（視認性アップ版） --- */
    .role-badge-pill {
        font-size: 13px;       /* 12px -> 13px (少し大きく) */
        font-weight: 800;      /* 太文字にしてクッキリさせる */
        
        padding: 2px 0;        /* 上下は詰めて文字スペース確保 */
        width: 95%;            /* 横幅いっぱいに広げる */
        
        /* 明るく目立つグラデーションに変更 */
        background: linear-gradient(135deg, #0f314d, #166d98 46%, #00d8ff); 
        border: 1px solid rgba(228, 248, 255, 0.85);
        
        /* ほんのり発光させて目立たせる */
        box-shadow: 0 0 8px rgba(0, 216, 255, 0.38);
        
        color: #fff;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        
        /* 中央揃え */
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 12px;
        letter-spacing: 1px;
    }
    .p-box-wrap {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .p-box-new.with-bubble {
        position: relative;
    }
    .p-header.clickable {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-thickness: 1px;
        text-underline-offset: 2px;
    }
    .role-activate-btn {
        margin-top: 8px;
    }
    .role-status-badge {
        font-size: 11px;
        color: var(--seki-warning);
        margin-top: 5px;
        font-weight: bold;
    }
    .role-card.is-used {
        filter: grayscale(1);
        opacity: 0.6;
    }

    /* 正体不明のとき（ROLE: ???）も見やすく */
    .role-unknown {
        font-size: 11px;
        /* 暗いグレーではなく、半透明の白にして読みやすくする */
        color: rgba(255, 255, 255, 0.6); 
        font-weight: bold;
        letter-spacing: 2px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    /* 修正: 役職の補足情報（手品師のスキル名など）を横並びにする */
    .role-sub { 
        font-size: 13px; 
        display: inline;      /* 横に並べる */
        opacity: 0.9; 
        margin-left: 4px;
    }
    /* --- 4. 公開カード (ミニカードも拡大) --- */
    .p-revealed-container {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 3px;
        margin-top: 6px;
        width: 140px; /* ボックス幅に合わせる */
    }
    .mini-card {
        width: 24px; height: 36px; /* 18x26 -> 24x36 に拡大 */
        border-radius: 4px;
        background: #fff;
        color: #333;
        font-size: 14px; /* 数字も読みやすく */
        font-weight: bold;
        line-height: 36px;
        text-align: center;
        border: 1px solid #999;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }
    /* 0のカード */
    /*.mini-card[data-val="0"] { border: 1px solid #ab47bc; color: #8e24aa; background: #f3e5f5; }*/

    /* --- その他微調整 --- */
    /* 自分エリアが隠れないようにマージン確保 */
    /* 中央フィールド（ゾーン分けレイアウト修正） */
    #field-center {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between; /* 上下に要素を分散 */
        
        background: linear-gradient(155deg, rgba(6, 16, 32, 0.62), rgba(3, 9, 20, 0.54));
        border-radius: 20px;
        box-shadow: inset 0 0 22px rgba(0, 216, 255, 0.11), 0 6px 16px rgba(0,0,0,0.28);
        border: 1px solid rgba(0, 216, 255, 0.18);
        
        padding: 5px;
        margin: 0 5px;
        z-index: 1;
    }
    /* --- ゾーン分けデザイン --- */
    
    /* インジケーター（画像 + 天文学者表示） */
    #flow-indicator-row {
        display: flex;
        align-items: stretch;
        justify-content: center;
        gap: 8px;
        margin-bottom: 10px;
        width: 100%;
    }
    #indicator { 
        width: auto;
        height: 60px;         /* 右側UIと高さを揃える */
        object-fit: contain;
        
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.6);
        filter: drop-shadow(0 0 2px rgba(255,255,255,0.3));
        
        display: block;
        margin: 0;
    }
    #astronomer-indicator {
        width: 73.66px;
        height: 50px;         /* 順行/逆行画像と同じ高さ */
        padding: 4px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.35);
        box-shadow: 0 3px 10px rgba(0,0,0,0.45), inset 0 0 16px rgba(120, 144, 255, 0.25);
        background:
            radial-gradient(circle at 20% 20%, rgba(255,255,255,0.26) 1px, transparent 2px),
            radial-gradient(circle at 78% 35%, rgba(255,255,255,0.22) 1px, transparent 2px),
            radial-gradient(circle at 52% 76%, rgba(255,255,255,0.18) 1px, transparent 2px),
            linear-gradient(150deg, #0d1631, #1c2f66);
        color: #e8f0ff;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        line-height: 1.05;
        text-align: center;
        user-select: none;
    }
    #astronomer-indicator.state-strongest {
        border-color: rgba(255, 214, 102, 0.8);
        box-shadow: 0 3px 10px rgba(0,0,0,0.45), 0 0 10px rgba(255, 214, 102, 0.45);
    }
    #astronomer-indicator.state-weakest {
        border-color: rgba(144, 202, 249, 0.7);
        box-shadow: 0 3px 10px rgba(0,0,0,0.45), 0 0 10px rgba(144, 202, 249, 0.4);
        filter: saturate(0.75);
    }
    #astronomer-indicator-value {
        width: 30px;
        height: 40px;
        line-height: 40px;
        border-radius: 6px;
        border: 1px solid rgba(255,255,255,0.9);
        background: linear-gradient(160deg, #fefefe, #dfe9ff);
        color: #1a237e;
        font-size: 24px;
        font-weight: 900;
        margin-top: 2px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.35);
        text-shadow: 0 0 4px rgba(103, 58, 183, 0.35);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #astronomer-indicator-state {
        font-size: 10px;
        margin-bottom: 2px;
        font-weight: bold;
        white-space: nowrap;
        text-align: center;
    }

    /* 左右のゾーンをまとめるコンテナ */
    .field-zone-container {
        display: flex;
        justify-content: center;
        gap: 8px; /* ゾーン間の隙間 */
        width: 100%;
        flex: 1; /* 高さいっぱいに広げる */
    }

    /* 個別ゾーンの枠 */
    .field-zone {
        flex: 1; /* 左右均等 */
        border-radius: 12px;
        padding: 5px 2px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        border: 1px solid rgba(255,255,255,0.15);
        position: relative;
    }

    /* 数字ゾーン (青系) */
    .zone-num {
        background: rgba(33, 150, 243, 0.14); 
        border-color: rgba(0, 216, 255, 0.42);
    }
    /* 記号ゾーン (赤系) */
    .zone-sym {
        background: rgba(244, 67, 54, 0.12); 
        border-color: rgba(255, 53, 94, 0.4);
    }

    /* ラベル (NUMBER / SYMBOL) */
    .zone-label {
        font-size: 12px;
        font-weight: bold;
        letter-spacing: 1px;
        margin-bottom: 2px;
        opacity: 0.6;
    }

    /* 墓地スロット (少し縮小) */
    .grave-slot {
        transform: scale(0.9); 
        margin-bottom: auto; /* 山札を下に押しやる */
    }

    /* 山札エリア (アイコン化) */
    .deck-slot {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        background: rgba(0,0,0,0.34);
        padding: 4px 10px;
        border-radius: 15px;
        margin-bottom: 5px;
        cursor: default;
        border: 1px solid rgba(0, 216, 255, 0.2);
    }

    /* 山札アイコン (CSSでカード裏面を表現) */
    .deck-icon {
        width: 12px; height: 18px;
        border-radius: 2px;
        border: 1px solid #fff;
    }
    .deck-icon.num { background: repeating-linear-gradient(45deg, #1565c0, #1565c0 2px, #0d47a1 2px, #0d47a1 4px); }
    .deck-icon.sym { background: repeating-linear-gradient(45deg, #c62828, #c62828 2px, #b71c1c 2px, #b71c1c 4px); }

    /* 山札の数字 */
    .deck-count {
        font-size: 16px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 1px 2px #000;
    }

    /* 除外エリア (ゴミ箱) */
    #exclusion-area {
        margin-top: 2px;
        font-size: 11px;
        opacity: 0.8;
        cursor: pointer;
        background: rgba(3, 12, 24, 0.62);
        padding: 3px 12px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        gap: 5px;
        border: 1px solid rgba(255, 53, 94, 0.3);
        transition: background var(--seki-transition-fast), opacity var(--seki-transition-fast), border-color var(--seki-transition-fast);
    }
    #exclusion-area:hover {
        opacity: 1;
        background: rgba(6, 18, 35, 0.8);
        border-color: rgba(255, 53, 94, 0.55);
    }

    /* 残り枚数バッジも大きく */
    .p-count-badge {
        width: 24px; height: 24px;
        line-height: 24px;
        font-size: 14px;
        top: -10px; left: -10px;
    }

    /* フィールド調整 */
    #graveyard-container { display: flex; gap: 15px; align-items: center; }
    .grave-box { text-align: center; cursor: pointer; transition: transform 0.1s; }
    .grave-box:active { transform: scale(0.95); }
    .grave-label { font-size: 10px; color: #ccc; }

    /* ログエリア */
    #game-log-bar { 
        position: fixed; bottom: 0; left: 0; width: 100%; height: 35px; 
        background: linear-gradient(135deg, rgba(6, 16, 32, 0.96), rgba(4, 11, 23, 0.96));
        font-size: 13px; line-height: 35px; 
        text-align: left; padding-left: 15px; overflow: hidden; white-space: nowrap; 
        z-index: 50;
        color: var(--seki-text-main);
        cursor: pointer;
        border-top: 1px solid rgba(0, 216, 255, 0.34);
        box-shadow: 0 -2px 14px rgba(0,0,0,0.55);
    }
    
    /* 通知アニメーション */
    @keyframes flash-notify {
        0% { background-color: #ff9800; transform: scale(1); }
        50% { background-color: #f57c00; transform: scale(1.1); }
        100% { background-color: #ff9800; transform: scale(1); }
    }
    .notify-active { animation: flash-notify 1s infinite; border: 2px solid #fff !important; }
    .notify-bar { background-color: #ff9800 !important; color: white !important; font-weight: bold; }

    /* モーダル */
    #modal-overlay {
        position: fixed; top:0; left:0; width:100%; height:100%;
        background: rgba(2, 7, 15, 0.74); z-index: 999;
        backdrop-filter: blur(5px);
        display: flex; justify-content: center; align-items: center;
        animation: fadeIn 0.2s ease;
        transition: background 0.2s, backdrop-filter 0.2s;
    }
    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }

    #modal-overlay.board-visible {
        background: rgba(0,0,0,0.05);
        backdrop-filter: none;
    }
    #modal-overlay.modal-tone-guide {
        background: rgba(2, 10, 20, 0.62);
    }
    #modal-overlay.modal-tone-alert {
        background: rgba(36, 2, 12, 0.7);
    }

    #modal-box {
        background:
            linear-gradient(155deg, rgba(6, 16, 32, 0.9), rgba(4, 11, 23, 0.84)),
            radial-gradient(circle at 12% 18%, rgba(0, 216, 255, 0.1), transparent 34%);
        color: var(--seki-text-main);
        padding: 25px;
        border-radius: 14px;
        max-width: 90%;
        max-height: 80%;
        width: 400px;
        overflow-y: auto; text-align: center; display:flex; flex-direction:column;
        font-family: var(--font-readable);
        box-shadow: var(--seki-shadow-panel), var(--seki-shadow-glow);
        border: 1px solid var(--seki-panel-border);
        transition: background 0.2s, opacity 0.2s, box-shadow 0.2s, border-color 0.2s;
    }
    #modal-box.modal-size-default { width: 400px; max-width: 90%; }
    #modal-box.modal-size-wide { width: 600px; max-width: 95%; }
    #modal-box.modal-size-narrow { width: 340px; max-width: 86%; }
    #modal-box.modal-tone-guide {
        border-color: rgba(0, 216, 255, 0.44);
    }
    #modal-box.modal-tone-alert {
        border-color: rgba(255, 53, 94, 0.6);
        box-shadow: var(--seki-shadow-panel), 0 0 22px rgba(255, 53, 94, 0.25);
    }
    #modal-overlay.board-visible #modal-box {
        background: rgba(13, 22, 40, 0.34);
        border-color: rgba(209, 231, 255, 0.75);
        box-shadow: 0 4px 14px rgba(0,0,0,0.25);
        opacity: 0.4;
    }
    #modal-content { margin-bottom: 20px; flex: 1; overflow-y: auto; }
    .modal-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .modal-btn {
        margin: 5px;
        padding: 10px 20px;
        border: 1px solid rgba(142, 182, 227, 0.45);
        border-radius: var(--seki-radius-sm);
        cursor: pointer;
        font-size: 14px;
        font-family: var(--font-ui);
        color: var(--seki-text-main);
        background: linear-gradient(135deg, rgba(9, 27, 52, 0.9), rgba(6, 18, 35, 0.88));
        transition: transform var(--seki-transition-fast), box-shadow var(--seki-transition-fast), border-color var(--seki-transition-fast), filter var(--seki-transition-fast);
    }
    .modal-btn:hover:not(:disabled) {
        transform: translateY(-1px);
        border-color: rgba(0, 216, 255, 0.7);
        box-shadow: 0 5px 14px rgba(0,0,0,0.35), 0 0 10px rgba(0, 216, 255, 0.24);
        filter: saturate(1.1);
    }
    .modal-btn:disabled,
    .modal-btn.is-disabled {
        background: rgba(89, 102, 119, 0.9);
        color: rgba(239, 246, 255, 0.76);
        border-color: rgba(151, 166, 187, 0.7);
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }
    .modal-btn.primary {
        background: linear-gradient(135deg, #0f314d, #166d98 44%, #00d8ff);
        border-color: rgba(0, 216, 255, 0.7);
        color: #effbff;
        font-weight: 700;
    }
    .modal-btn.danger {
        background: linear-gradient(135deg, #7f1730, #cc244a 46%, #ff355e);
        border-color: rgba(255, 143, 166, 0.78);
        color: #fff5f8;
        font-weight: 700;
    }
    .modal-btn.ghost {
        background: rgba(12, 22, 35, 0.7);
    }
    .modal-note {
        display: block;
        font-size: 12px;
        margin-top: 8px;
        color: var(--seki-text-muted);
    }
    .modal-note.warn {
        color: #ff9f9f;
        font-weight: 700;
    }
    .modal-note.warn-block {
        margin: 0 0 8px;
    }
    .modal-note.info {
        color: #9ce8ff;
    }
    .modal-card-row {
        display: flex;
        justify-content: space-around;
        align-items: center;
        margin: 10px 0;
        gap: 8px;
    }
    .modal-card-col {
        width: 100px;
    }
    .modal-card-label {
        font-size: 10px;
        color: var(--seki-text-muted);
        margin-bottom: 4px;
    }
    .modal-notif-wrap {
        text-align: center;
    }
    .modal-notif-title {
        font-size: 16px;
        font-weight: bold;
        color: #ffadb8;
        margin: 0;
    }
    .modal-notif-arrow {
        font-size: 20px;
        color: #9cb3c9;
    }
    .modal-notif-card {
        width: 100px;
    }
    .modal-notif-value {
        font-size: 32px;
        font-weight: bold;
        line-height: 80px;
    }
    .modal-image-center {
        height: 80px;
        width: auto;
        display: block;
        margin: 0 auto;
    }
    .seki-section {
        margin-top: 10px;
        padding: 8px 10px;
        border-radius: var(--seki-radius-sm);
        border: 1px solid rgba(143, 176, 214, 0.35);
        background: rgba(6, 16, 32, 0.6);
    }
    .seki-section.warn {
        border-color: rgba(255, 143, 166, 0.55);
        background: rgba(72, 12, 27, 0.35);
    }
    .seki-section.info {
        border-color: rgba(0, 216, 255, 0.5);
        background: rgba(8, 26, 48, 0.42);
    }
    .seki-note {
        display: block;
        font-size: 12px;
        color: var(--seki-text-muted);
    }
    .seki-note.warn {
        color: #ffadb8;
        font-weight: 700;
    }
    .seki-scroll-panel {
        text-align: left;
        max-height: 420px;
        overflow-y: auto;
        font-size: 13px;
    }
    .seki-log-line {
        border-bottom: 1px solid rgba(143, 176, 214, 0.3);
        padding: 6px 0;
    }
    .seki-log-time {
        color: #9cb3c9;
        font-size: 11px;
        margin-right: 8px;
    }
    .seki-log-text {
        color: #d9ebff;
    }
    .seki-disabled-note {
        font-size: 12px;
        color: #ff9f9f;
        margin-top: 8px;
    }
    .seki-host-settings {
        text-align: left;
        font-size: 14px;
    }
    .seki-host-mode-box {
        margin-bottom: 15px;
        background: rgba(6, 16, 32, 0.64);
        padding: 10px;
        border-radius: var(--seki-radius-sm);
        border: 1px solid rgba(143, 176, 214, 0.32);
    }
    .seki-host-mode-item {
        display: flex;
        align-items: center;
        cursor: pointer;
    }
    .seki-host-mode-item + .seki-host-mode-item {
        margin-top: 8px;
    }
    .seki-host-mode-item input {
        margin: 0 8px 0 0;
        width: auto;
        transform: scale(1.2);
    }
    .seki-host-mode-title {
        font-weight: 700;
        color: #9ce8ff;
    }
    .seki-host-mode-title.hot {
        color: #ffb86b;
    }
    .seki-host-mode-meta {
        font-size: 11px;
        color: #9cb3c9;
        margin-left: 5px;
    }
    .seki-host-actions {
        display: flex;
        gap: 10px;
    }
    .seki-host-actions .modal-btn {
        margin: 0;
    }
    .seki-host-actions .modal-btn.primary {
        flex: 1;
    }
    .seki-host-actions .modal-btn.danger {
        width: 80px;
    }
    .seki-guide-root {
        text-align: left;
        max-height: 500px;
        overflow-y: auto;
    }
    .seki-guide-role-item {
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(143, 176, 214, 0.26);
        padding-bottom: 5px;
    }
    .seki-guide-summary {
        cursor: pointer;
        display: flex;
        align-items: center;
        outline: none;
        list-style: none;
    }
    .seki-guide-role-img {
        height: 40px;
        vertical-align: middle;
        margin-right: 10px;
        border-radius: 4px;
        border: 1px solid rgba(143, 176, 214, 0.45);
    }
    .seki-guide-role-main {
        flex: 1;
    }
    .seki-guide-role-jp {
        font-weight: 700;
        color: #9ce8ff;
        font-size: 15px;
    }
    .seki-guide-role-en {
        font-size: 13px;
        color: #cce6ff;
        font-weight: 400;
        margin-left: 4px;
    }
    .seki-guide-role-summary {
        font-size: 12px;
        color: #d9ebff;
        display: flex;
        justify-content: space-between;
        align-items: baseline;
    }
    .seki-guide-role-detail {
        margin-top: 10px;
        padding: 10px;
        background: rgba(6, 16, 32, 0.52);
        border-radius: 5px;
        font-size: 12px;
        color: #d9ebff;
        line-height: 1.6;
    }
    .seki-guide-hint {
        font-size: 10px;
        color: #9cb3c9;
        white-space: nowrap;
    }
    .seki-rule-root {
        text-align: left;
        max-height: 400px;
        overflow-y: auto;
        font-size: 13px;
        color: #d9ebff;
    }
    .seki-rule-paragraph {
        margin: 0 0 10px 0;
    }
    .seki-rule-heading {
        border-left: 4px solid #0fa0d8;
        padding-left: 8px;
        margin: 10px 0 5px 0;
        color: #b7ecff;
    }
    .seki-rule-heading.danger {
        border-left-color: #c62828;
    }
    .seki-rule-heading.info {
        border-left-color: #1565c0;
    }
    .seki-rule-heading.warn {
        border-left-color: #f76205;
    }
    .seki-rule-list {
        padding-left: 20px;
        margin: 0;
    }
    .score-dist {
        font-size: 11px;
        color: #d9ebff;
        margin-bottom: 10px;
        background: rgba(188, 140, 20, 0.2);
        padding: 5px;
        border-radius: 4px;
        text-align: center;
        border: 1px solid rgba(251, 192, 45, 0.55);
    }
    .score-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
    }
    .score-head {
        border-bottom: 2px solid rgba(143, 176, 214, 0.45);
        background: rgba(8, 26, 48, 0.55);
    }
    .score-table th,
    .score-table td {
        padding: 8px;
    }
    .score-table th:first-child,
    .score-name-cell {
        text-align: center;
    }
    .score-table th:last-child,
    .score-point-cell {
        text-align: right;
    }
    .score-empty {
        padding: 20px;
        color: #9cb3c9;
        text-align: center;
    }
    .score-row {
        border-bottom: 1px solid rgba(143, 176, 214, 0.28);
    }
    .score-row.me {
        color: #ffadb8;
        font-weight: 700;
    }
    .score-point-cell {
        font-weight: 700;
    }
    .score-reset-wrap {
        margin-top: 20px;
        text-align: center;
    }
    .score-reset-btn {
        font-size: 11px;
        color: #9cb3c9;
        background: rgba(6, 16, 32, 0.6);
        border: 1px solid rgba(143, 176, 214, 0.4);
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        transition: border-color var(--seki-transition-fast), color var(--seki-transition-fast), background var(--seki-transition-fast);
    }
    .score-reset-btn:hover {
        border-color: rgba(0, 216, 255, 0.65);
        color: #d9ebff;
        background: rgba(8, 26, 48, 0.7);
    }

    /* ログスタイル */
    .log-entry { text-align: left; padding: 8px; border-bottom: 1px solid rgba(143, 176, 214, 0.28); font-size: 13px; display: flex; align-items: flex-start; }
    .log-time { color: #a1b4cc; margin-right: 10px; font-size: 11px; min-width: 45px; }
    .log-text { word-break: break-all; line-height: 1.4; }
    .log-private .log-text { color: #ffc8d3; font-weight: bold; background: rgba(136, 20, 45, 0.34); padding: 2px 5px; border-radius: 4px;}
    .log-chat { background: rgba(0, 216, 255, 0.08); }
    
    /* チャット入力 */
    #chat-input-container { display: flex; gap: 8px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(143, 176, 214, 0.3); }
    #chat-input {
        color: var(--seki-text-main);
        flex: 1;
        padding: 10px;
        border-radius: 20px;
        border: 1px solid rgba(126, 173, 224, 0.45);
        outline:none;
        background: rgba(6, 16, 32, 0.78);
        font-family: var(--font-readable);
    }
    #chat-send-btn { background: linear-gradient(135deg, #157a53, #34b583); color: white; border-radius: 20px; padding: 0 20px; border: 1px solid rgba(93, 255, 192, 0.45); }

    .host-settings { margin-bottom: 15px; font-size: 14px; text-align: left; background: rgba(6, 16, 32, 0.55); padding: 10px; border-radius: 8px; border: 1px solid rgba(0, 216, 255, 0.24); }
    .host-settings label { margin-right: 15px; cursor: pointer; display: inline-block; padding: 5px; }
/* --- 追加修正: 墓地カードのはみ出し防止 --- */
    
    /* 墓地（pile）の中にあるカードは余白と影をなくす */
    .pile .card {
        margin: 0; 
        box-shadow: none; /* 埋まっている感じにするため影も消す */
        width: 100%; /* 枠いっぱいに広げる */
        height: 100%;
        border: none; /* 枠線もpile側に任せて消す */
        border-radius: 6px; /* 角丸を合わせる */
    }
    
    /* 墓地のカードはホバーしても浮き上がらないようにする */
    .pile:hover .card {
        transform: none; 
    }

    /* --- 役職パネルのデザイン --- */
    #my-role-panel {
        margin: 10px 0;
        display: flex;
        justify-content: center;
    }

    .role-card {
        background: linear-gradient(135deg, rgba(9, 29, 55, 0.95), rgba(4, 11, 23, 0.9));
        color: var(--seki-text-main);
        padding: 10px 20px;
        border-radius: var(--seki-radius-sm);
        border: 1px solid rgba(0, 216, 255, 0.35);
        box-shadow: 0 4px 12px rgba(0,0,0,0.45), inset 0 0 12px rgba(0, 216, 255, 0.1);
        text-align: center;
        width: 100%;
        max-width: 300px;
        position: relative;
        overflow: hidden;
    }
    
    /* 背景にうっすら装飾 */
    .role-card::before {
        content: 'ROLE';
        position: absolute;
        top: -10px; right: -10px;
        font-size: 50px;
        color: rgba(255,255,255,0.05);
        font-weight: bold;
        transform: rotate(15deg);
    }

    .role-name {
        font-family: var(--font-display-strong);
        font-size: 16px;
        letter-spacing: 1px;
        color: #8fefff;
        text-transform: uppercase;
        font-weight: bold;
    }
    
    .role-jp {
        font-size: 20px;
        font-weight: bold;
        margin: 2px 0;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .role-desc {
        font-size: 11px;
        color: #acd4ff;
        border-top: 1px solid rgba(179, 223, 255, 0.32);
        margin-top: 5px;
        padding-top: 4px;
    }
    /* --- カットインアニメーション用CSS --- */
    #cut-in-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7); /* 背景を少し暗くする */
        z-index: 9999; /* 最前面に表示 */
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: none; /* アニメーション中も裏の操作を阻害しないならnone、邪魔するならauto */
        opacity: 0; /* 初期状態は透明 */
        transition: opacity 0.3s;
    }

    /* JavaScriptで hidden が外れたら表示（opacityはanimate-cut-inで制御してもよいが、ベースを表示にする） */
    #cut-in-overlay:not(.hidden) {
        opacity: 1;
    }

    #cut-in-content {
        text-align: center;
        color: #ffeb3b;
        font-family: var(--font-display-strong);
        text-shadow: 0 0 10px #ff9800;
        transform: scale(0); /* 最初は小さく */
    }

    /* アニメーションクラスが付与されたときの動作 */
    .animate-cut-in #cut-in-content {
        animation: cutInZoom 2.5s ease-out forwards;
    }

    /* 動きの定義 */
    @keyframes cutInZoom {
        0% { transform: scale(0) rotate(-10deg); opacity: 0; }
        20% { transform: scale(1.2) rotate(0deg); opacity: 1; }
        30% { transform: scale(1.0); }
        80% { transform: scale(1.0); opacity: 1; }
        100% { transform: scale(1.5); opacity: 0; }
    }
    
    /* 役職名：ゴールドのグラデーションで高級感を出す */
    #cut-in-role { 
        font-size: 50px; 
        font-weight: 900;
        margin-bottom: 5px; 
        
        /* 金色のグラデーション文字 */
        background: linear-gradient(to bottom, #fff 0%, #ffd700 50%, #bf953f 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        
        /* 影をつけて浮き上がらせる */
        filter: drop-shadow(0 4px 0px rgba(0,0,0,0.5));
        
        /* 少し斜体にしてスピード感を出す */
        font-style: italic;
        letter-spacing: 2px;
    }
    /* プレイヤー名：白文字でシンプルに */
    #cut-in-player { 
        font-size: 20px; 
        color: #ddd; 
        margin-bottom: 15px;
        letter-spacing: 1px;
        font-weight: bold;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }

    /* ▼▼▼ クッキリ・読みやすい版 ▼▼▼ */
    #cut-in-text { 
        font-family: var(--font-display-strong);
        font-weight: 900;
        font-size: 60px; /* 少し大きくして視認性UP */
        
        font-style: italic;
        letter-spacing: 0.1em;
        transform: skewX(-15deg);

        /* グラデーション：白を多めにして明るくクッキリさせる */
        background: linear-gradient(to bottom, #ffffff 45%, #cfd8dc 50%, #78909c 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;

        /* ★ここがポイント：filterではなく「線」で縁取りする */
        /* これにより文字の輪郭がバシッと決まります */
        -webkit-text-stroke: 2px #000;

        /* 影：ぼかし(px)を0にして、パキッとした影を落とす */
        filter: drop-shadow(4px 4px 0px rgba(0, 0, 0, 0.8));
            
        margin-top: 10px;
        white-space: nowrap;
        
        /* 隠し味：少しだけ光らせたい場合は以下をコメントアウト解除 */
        /* text-shadow: 0 0 10px rgba(255,255,255,0.5); */
    }

    #visual-overlay {
        font-family: var(--font-display-strong);
    }
    

    /* ▼▼▼ 追加：皇帝パネル用の輝きアニメーション ▼▼▼ */
    @keyframes goldShine {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    @keyframes goldPulse {
        0% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
        100% { box-shadow: 0 0 30px rgba(255, 215, 0, 1.0), 0 0 10px #fff; }
    }
    
    /* --- Hacked Corner (旧スタイルは削除または無視) --- */
    /* 代わりに以下を追加 */

    /* ロックされたカードのデザイン */
    .card.locked {
        /* 通常カードと同じサイズ・配置 */
        filter: grayscale(0.9) brightness(0.6); /* モノクロにして暗くする */
        border: 2px dashed #ff1744 !important;   /* 赤枠で危険を示す */
        cursor: not-allowed;
        position: relative;
    }

    /* 右下に鍵アイコンを表示（カードの絵柄を隠さない）⇐削除済み

    /* ホバーしても浮き上がらせない */
    .card.locked:hover {
        transform: none !important;
        box-shadow: none !important;
    }

    /* 警察による公開カードのデザイン */
    .card.revealed {
        /* 青色の枠線で「警察」感を出す */
        border: 3px solid #fdd835 !important;
        box-shadow: 0 0 10px rgba(246, 246, 41, 0.6); 
        position: relative; /* 帯の配置用 */
        overflow: hidden;   /* 帯がはみ出さないように */
    }

    /* 右上の「OPEN」帯 */
    .card.revealed::after {
        content: "OPEN";
        position: absolute;
        top: 5px;
        right: -22px;
        width: 80px;
        height: 18px;
        background: #fdd835; /* 警告色（黄色） */
        color: #000;
        font-size: 10px;
        font-weight: bold;
        text-align: center;
        line-height: 18px;
        transform: rotate(45deg); /* 斜めに配置 */
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        z-index: 20;
        pointer-events: none; /* クリックの邪魔をしない */
        font-family: var(--font-display-strong);
    }

    /* --- スマホ・細い画面用のスリムレイアウト --- */
    @media (max-width: 600px) {
        /* 1. 左右のカラム幅を詰める */
        .player-zone.col {
            width: 105px !important; /* ボックス幅に合わせて最小限に */
            z-index: 20;
        }

        /* 2. ボックスをスリム化 */
        .player-zone.col .p-box-new {
            width: 100px !important; /* 140px -> 100px に細くする */
            height: auto !important;    /* 固定をやめて自動に */
            min-height: 180px;          /* 最低でもこの高さを確保 */
            padding-bottom: 5px;        /* 下端の余白 */ 
        }

        /* 3. 中段（手札数とステータス）を縦積みに */
        .player-zone.col .p-box-new .p-body {
            flex-direction: column; /* 縦並び */
            justify-content: center;
            gap: 8px; /* 詰める */
            padding: 5px 0;
            flex: 1;         /* 余ったスペースを埋める */
        }
        
        /* ステータス表示の位置調整 */
        .player-zone.col .p-box-new .p-status-area {
            align-items: center; /* 中央揃え */
            width: 100%;
        }

        /* 4. 下段（役職）のエリア高さを自動調整 */
        .player-zone.col .p-box-new .p-role-row {
            height: auto !important; /* 固定高さを解除 */
            min-height: 40px;        /* 最低限の高さ確保 */
            padding: 5px 0;
            display: flex;
            align-items: center;     /* 上下中央寄せ */
            justify-content: center;
            margin-top: auto; /* 一番下に押し下げる */
        }

        /* 役職バッジの中身を折り返し（縦積み）にする */
        .player-zone.col .p-box-new .role-badge-pill {
            flex-direction: column; /* 縦並び */
            width: 96%;             /* 幅いっぱい */
            padding: 4px 0;
            line-height: 1.2;
            border-radius: 8px;     /* 角丸を少し緩める */
        }
        
        /* 役職の補足（REVERSEなど）のデザイン調整 */
        .player-zone.col .p-box-new {
            display: block;        /* 改行させる */
            margin-left: 0;
            margin-top: 3px;
            font-size: 9px;        /* 少し小さく */
            opacity: 0.9;
        }
        .role-sub {
            display: block;        /* 改行させる */
            margin-left: 0;
            margin-top: 3px;
            font-size: 13px;        /* 少し小さく */
            opacity: 0.9;
        }

        /* 公開カード置き場も幅を合わせる */
        .player-zone.col .p-revealed-container {
            width: 100px !important;
        }
        
        /* 中央フィールドとの隙間を詰める */
        #field-center {
            margin: 0 !important;
        }
        #area-middle {
            gap: 2px !important; /* 左右ボックスとの隙間を最小限に */
        }

    }

    /* --- 追加: 公開カード情報（テキスト表示用） --- */
        .p-revealed-info {
            font-size: 11px;
            margin-top: 5px;     /* ステータスとの隙間 */
            white-space: nowrap; /* 折り返しなし */
            line-height: 1.2;
            /* ★ここが重要: ゲーム全体のフォントトークンを強制する */
            font-family: var(--font-ui) !important;
        }

        /* 何も公開されていない時 (NORMAL表示と同じような色に) */
        .revealed-none {
            color: #9cb3c9;
            font-weight: bold;
        }

        /* 公開されている時 (目立たせる) */
        .revealed-active {
            color: #ffeb3b;      /* 黄色 */
            font-weight: bold;
        }
        
        /* 元々の画像表示エリアは完全に非表示にする */
        .p-revealed-container {
            display: none !important;
        }
        
        /* スマホ表示の微調整 */
        @media (max-width: 600px) {
            .p-revealed-info {
                font-size: 10px;
            }
        }

        /* --- 点滅アニメーション定義 --- */
        @keyframes blink-text {
            0% { opacity: 1.0; transform: scale(1.0); }
            50% { opacity: 0.5; transform: scale(1.05); } /* 半透明になりつつ少し大きくなる */
            100% { opacity: 1.0; transform: scale(1.0); }
        }
        /* --- チャット吹き出し (Chat Bubble) --- */
    .chat-bubble {
        position: absolute;
        background: #fff;
        color: #000;
        font-size: 11px;
        font-weight: bold;
        padding: 6px 10px;
        border-radius: 12px;
        max-width: 240px;       /* 長文は省略 */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        opacity: 0;             /* 最初は隠す */
        pointer-events: none;   /* クリックの邪魔をしない */
        z-index: 500;           /* カードより手前 */
        transition: opacity 0.2s;
    }

    /* 吹き出しのしっぽ (共通) */
    .chat-bubble::after {
        content: "";
        position: absolute;
        border-style: solid;
        display: block;
    }

    /* アニメーションクラス */
    .chat-bubble.active {
        animation: bubble-pop 4s ease-out forwards;
    }

    @keyframes bubble-pop {
        0% { opacity: 0; transform: scale(0.5); }
        10% { opacity: 1; transform: scale(1); }
        85% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0.8); }
    }

    /* --- 位置別のスタイル (画面内側に向くように配置) --- */

    /* 1. 自分 (下部配置) -> 吹き出しは「上」に出す */
    .bubble-pos-bottom {
        bottom: 110%; /* 箱の上に */
        left: 50%;
        transform: translateX(-50%);
    }
    .bubble-pos-bottom::after {
        bottom: -6px; left: 50%; margin-left: -6px;
        border-width: 6px 6px 0;
        border-color: #fff transparent;
    }

    /* 2. 上の人 (上部配置) -> 吹き出しは「下」に出す */
    .bubble-pos-top {
        top: 100%;    /* 箱の下に */
        left: 0;
        margin-top: 10px;
        transform: none;
    }
    .bubble-pos-top::after {
        top: -6px; left: 50%; margin-left: -6px;
        border-width: 0 6px 6px;
        border-color: #fff transparent;
    }

    /* 3. 左の人 -> 吹き出しは「右」に出す */
    .bubble-pos-left {
        top: auto;
        bottom: 100%; /* ボックスの上に */
        
        /* 左端をボックスに合わせる */
        left: 0;
        right: auto;
        
        /* 隙間調整 */
        margin-bottom: 10px; 
        margin-left: 0;
        margin-right: 0;
        
        transform: none;
    }
    .bubble-pos-left::after {
        top: 50%; right: 100%; margin-top: -6px;
        border-width: 6px 6px 6px 0;
        border-color: transparent #fff;
    }

    /* 4. 右の人 -> 吹き出しは「左」に出す */
    .bubble-pos-right {
        /* 上に出す設定(bottom)を解除し、下(top: 100%)に出す */
        top: 100%;
        bottom: auto;
        
        /* 左端をボックスに合わせる */
        left: auto;
        right: 0;
        
        /* 隙間調整 (上側にマージンを入れる) */
        margin-top: 10px; 
        margin-bottom: 0;
        margin-left: 0;
        margin-right: 0;
        
        transform: none;
    }
    .bubble-pos-right::after {
        top: 50%; left: 100%; margin-top: -6px;
        border-width: 6px 0 6px 6px;
        border-color: transparent #fff;
    }

    /* スマホ調整: 左右の人が画面端すぎる場合、少し内側に寄せる微調整 */
    @media (max-width: 600px) {
        .chat-bubble { max-width: 90px; font-size: 10px; }
    }



</style>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
</head>
<body>

    <div id="login-screen">
        <canvas id="login-cyber-bg" aria-hidden="true"></canvas>
        <div class="login-grid" aria-hidden="true"></div>
        <div class="login-scanlines" aria-hidden="true"></div>

        <div id="login-panel">
            <img src="./images/new_logo.png" alt="SEKI Online" id="title-logo">
            <p class="version-text">Ver 30.00 NEW GAME</p>
            <p class="seki-tagline">STRATEGY // EFFICIENCY // KILLER // INTERFACE; S.E.K.I.</p>
            <input type="text" id="roomName" placeholder="Room ID (e.g. seki123)">
            <div id="room-suggestion-panel" class="hidden"></div>
            <input type="text" id="playerName" placeholder="Your Name">
            <button id="btn-join" onclick="joinGame()">JOIN / CREATE ROOM</button>
        </div>
    </div>

    <script>
    (() => {
        const loginScreen = document.getElementById("login-screen");
        const canvas = document.getElementById("login-cyber-bg");
        if (!loginScreen || !canvas) return;

        const ctx = canvas.getContext("2d");
        if (!ctx) return;

        const colors = ["#00d8ff", "#34f78d", "#ff355e"];
        const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)");
        let width = 0;
        let height = 0;
        let dpr = 1;
        let rafId = null;
        let particles = [];

        function toRgba(hex, alpha) {
            const value = hex.replace("#", "");
            const r = parseInt(value.substring(0, 2), 16);
            const g = parseInt(value.substring(2, 4), 16);
            const b = parseInt(value.substring(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        class StreamParticle {
            constructor(seedY) {
                this.reset(seedY);
            }
            reset(seedY) {
                this.x = Math.random() * width;
                this.y = typeof seedY === "number" ? seedY : height + Math.random() * (height * 0.45);
                this.speed = 0.6 + Math.random() * 1.8;
                this.len = 12 + Math.random() * 36;
                this.size = 0.8 + Math.random() * 1.7;
                this.alpha = 0.38 + Math.random() * 0.5;
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }
            update() {
                this.y -= this.speed;
                if (this.y < -this.len - 5) this.reset();
            }
            draw() {
                const grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.len);
                grad.addColorStop(0, toRgba(this.color, this.alpha));
                grad.addColorStop(1, "rgba(0, 0, 0, 0)");
                ctx.fillStyle = grad;
                ctx.fillRect(this.x, this.y, this.size, this.len);
            }
        }

        function drawFrame(isStatic) {
            ctx.fillStyle = isStatic ? "rgba(3, 10, 22, 0.85)" : "rgba(3, 10, 22, 0.24)";
            ctx.fillRect(0, 0, width, height);

            particles.forEach((particle) => {
                if (!isStatic) particle.update();
                particle.draw();
            });

            if (!isStatic && Math.random() > 0.985) {
                const glitchColor = toRgba(colors[Math.floor(Math.random() * colors.length)], 0.5);
                ctx.fillStyle = glitchColor;
                ctx.fillRect(0, Math.random() * height, width, Math.random() * 2 + 0.5);
            }
        }

        function rebuildParticles() {
            const count = Math.max(36, Math.floor(width / 16));
            particles = [];
            for (let i = 0; i < count; i++) {
                particles.push(new StreamParticle(Math.random() * height));
            }
        }

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            width = Math.max(1, Math.floor(rect.width));
            height = Math.max(1, Math.floor(rect.height));
            dpr = Math.min(window.devicePixelRatio || 1, 2);

            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            rebuildParticles();
            drawFrame(true);
        }

        function stopAnimation() {
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
        }

        function tick() {
            if (loginScreen.classList.contains("hidden")) {
                stopAnimation();
                return;
            }
            drawFrame(false);
            rafId = requestAnimationFrame(tick);
        }

        function startAnimation() {
            if (rafId !== null) return;
            if (reduceMotion.matches) return;
            if (loginScreen.classList.contains("hidden")) return;
            rafId = requestAnimationFrame(tick);
        }

        function handleMotionPrefChanged() {
            stopAnimation();
            resizeCanvas();
            if (!reduceMotion.matches && !loginScreen.classList.contains("hidden")) {
                startAnimation();
            }
        }

        window.addEventListener("resize", resizeCanvas);
        document.addEventListener("visibilitychange", () => {
            if (document.hidden) stopAnimation();
            else if (!reduceMotion.matches && !loginScreen.classList.contains("hidden")) startAnimation();
        });

        if (typeof reduceMotion.addEventListener === "function") {
            reduceMotion.addEventListener("change", handleMotionPrefChanged);
        } else if (typeof reduceMotion.addListener === "function") {
            reduceMotion.addListener(handleMotionPrefChanged);
        }

        const observer = new MutationObserver(() => {
            if (loginScreen.classList.contains("hidden")) stopAnimation();
            else if (!reduceMotion.matches) startAnimation();
        });
        observer.observe(loginScreen, { attributes: true, attributeFilter: ["class"] });

        resizeCanvas();
        if (!reduceMotion.matches) startAnimation();
    })();
    </script>

    <div id="game-screen" class="hidden">
        <div id="header-info" class="seki-topbar">
            <div id="room-display"></div>
            <div class="seki-topbar-actions">
                <button id="btn-host-settings" class="hidden seki-btn seki-btn-host seki-btn-accent" onclick="openHostSettings()">
                    ⚙️
                </button>
                <button onclick="showScoreboard()" class="seki-btn seki-btn-mini seki-btn-gold">🏆</button>
                <button onclick="showRoleList()" class="seki-btn seki-btn-mini seki-btn-accent">役職</button>
                <button onclick="showRule()" class="seki-btn seki-btn-mini">ルール</button>
                <button id="btn-bgm-toggle" onclick="toggleBgmMute()" class="seki-btn seki-btn-mini">🔊</button>
                <button onclick="leaveRoom()" class="seki-btn seki-btn-mini seki-btn-danger">🚪</button>
            </div>
        </div>

        <div id="game-table">
            
            <div id="area-top" class="player-zone row"></div>

            <div id="area-middle">
                <div id="area-left" class="player-zone col"></div>

                <div id="field-center">
                    <div id="flow-indicator-row">
                        <img id="indicator" src="./images/reverse_blue.jpg" alt="順行/逆行">
                        <div id="astronomer-indicator" aria-live="polite">
                            <div id="astronomer-indicator-state">観測待機</div>
                            <div id="astronomer-indicator-value">-</div>
                        </div>
                    </div>
                    
                    <div class="field-zone-container">
                        
                        <div class="field-zone zone-num">
                            <div class="zone-label">数字墓地</div>
                            
                            <div class="grave-slot" onclick="viewGrave('num')">
                                <div id="graveNum" class="pile"></div>
                            </div>
                            
                            <div class="deck-slot">
                                <div class="deck-icon num"></div>
                                <div id="deckNumCount" class="deck-count">-</div>
                            </div>
                        </div>

                        <div class="field-zone zone-sym">
                            <div class="zone-label">記号墓地</div>
                            
                            <div class="grave-slot" onclick="viewGrave('sym')">
                                <div id="graveSym" class="pile"></div>
                            </div>
                            
                            <div class="deck-slot">
                                <div class="deck-icon sym"></div>
                                <div id="deckSymCount" class="deck-count">-</div>
                            </div>
                        </div>
                    </div>

                    <div id="exclusion-area" onclick="viewGrave('excl')">
                        <span>🗑️除外：</span>
                        <span id="exclusion-count">0</span>
                    </div>
                    
                    <div id="msg" class="seki-msg">待機中...</div>
                </div>

                <div id="area-right" class="player-zone col"></div>
            </div>

            <div id="my-area">
                <div id="my-name-bar" class="my-name-plate"></div>
            
                <div id="my-hand"></div>
                <div id="controls" class="seki-controls">
                    <button id="btn-play" onclick="playCard()" class="seki-btn seki-btn-accent">決定</button>
                    <button id="btn-pass" onclick="passTurn()" class="seki-btn seki-btn-soft">パス</button>
                </div>

                <div id="my-role-panel"></div>

            </div>
        </div>
    </div>

    <div id="game-log-bar" onclick="showLogHistory()">ログを読み込み中...</div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-box">
            <h3 id="modal-title">タイトル</h3>
            <div id="modal-content">内容</div>
            <div id="modal-footer">
                <button onclick="closeModal()" class="modal-btn ghost">閉じる</button>
            </div>
        </div>
    </div>

    <div id="cut-in-overlay" class="hidden">
        <div id="cut-in-bg"></div>
        <div id="cut-in-content">
            <div id="cut-in-role">ROLE NAME</div>
            <div id="cut-in-player">Player Name</div>
            <div id="cut-in-text">SKILL ACTIVATED!</div>
        </div>
    </div>

    <div id="visual-overlay" class="seki-overlay">
    <div id="squeeze-guess"></div>

    <div class="seki-visual-card">
        
        <div id="squeeze-content">?</div>

        <div id="squeeze-cover">
            <div class="seki-visual-cover-logo">SEKI</div>
        </div>
    </div>

    <div id="squeeze-result"></div>
</div>

    <script>
        // エラー抑制
        window.onerror = function(msg) { 
            // execPassResetのエラー無視行を削除しました
            showInfoModal("システムエラー", msg); 
        };

        const CARD_IMAGES = {
            "TRADE": "./images/trade.png",
            "DIG UP": "./images/dig up.png",
            "DISCARD": "./images/discard.png",
            "REVERSE": "./images/reverse.png",
        };

        // 役職画像の定義（ここに追加していく）
        const ROLE_IMAGES = {
        "ANGLER": "./images/angler.png",
        "FORTUNE TELLER": "./images/fortuneteller.png",
        "THIEF": "./images/thief.png",
        "HUNTER": "./images/hunter.png",
        "GAMBLER": "./images/gambler.png",
        "CROWN": "./images/crown.png",
        "MILLIONAIRE": "./images/millionaire.png",
        "EMPEROR": "./images/emperor.png",
        "HACKER": "./images/hacker.png",
        "POLITICIAN": "./images/politician.png",
        "POLICE OFFICER": "./images/policeofficer.png",
        "ALCHEMIST": "./images/alchemist.png",
        "NECROMANCER": "./images/necromancer.png",
        "AGENT": "./images/agent.png",
        "ASTRONOMER": "./images/astronomer.png",
        //他もあれば追加
        };

        /* --- 音声ファイルの登録 --- */
        const SOUND_FILES = {
            // 賭博師用
            'DRUM': './sounds/drum.mp3',         // ドラムロール
            'WIN_NORMAL': './sounds/win.mp3',    // 普通の当たり
            'WIN_BIG': './sounds/win_big.mp3',   // 大当たり！
            'LOSE': './sounds/lose.mp3',          // 負け...
            // BGM
            'BGM_LOBBY': './sounds/bgm_lobby.mp3',
            'BGM_BATTLE': './sounds/bgm_battle.mp3',
            // システム通知
            'turn':    './sounds/turn.mp3',  // 自分の番
            'chat':    './sounds/chat.mp3',  // チャット受信
            'WARNING': './sounds/warning.mp3', // トレードの被害
            'DOS': './sounds/dos.mp3',
            'UNO': './sounds/uno.mp3',
            // 順位決定音
            'RANK_1':     './sounds/winner.mp3',  // 1位
            'RANK_2_3':   './sounds/normal.mp3',  // 2位・3位
            'RANK_4':     './sounds/loser.mp3',  // 4位（最下位）

            // カードアクション
            'PUT':     './sounds/put.mp3',
            'REVERSE': './sounds/reverse.mp3',
            'TRADE':   './sounds/trade.mp3',
            'DIG UP':  './sounds/digup.mp3',
            'DISCARD': './sounds/discard.mp3',
            // 役職発動音
            'SKILL': './sounds/skill_default.mp3',
            'SKILL_ANGLER': "./sounds/skill_angler.mp3",
            'SKILL_FORTUNE TELLER': "./sounds/skill_fortuneteller.mp3",
            'SKILL_THIEF': "./sounds/skill_thief.mp3",
            'SKILL_HUNTER': "./sounds/skill_hunter.mp3",
            'SKILL_GAMBLER': "./sounds/skill_gambler.mp3",
            'SKILL_CROWN': "./sounds/skill_crown.mp3",
            'SKILL_MILLIONAIRE': "./sounds/skill_millionaire.mp3",
            'SKILL_EMPEROR': "./sounds/skill_emperor.mp3",
            'SKILL_HACKER': "./sounds/skill_hacker.mp3",
            'SKILL_POLITICIAN': "./sounds/skill_politician.mp3",
            'SKILL_POLICE OFFICER': "./sounds/skill_policeofficer.mp3",
            'SKILL_ALCHEMIST': "./sounds/skill_alchemist.mp3",
            'SKILL_NECROMANCER': "./sounds/skill_necromancer.mp3",
            'SKILL_AGENT': "./sounds/skill_agent.mp3",
            'SKILL_ASTRONOMER': "./sounds/skill_astronomer.mp3",
        };
        
        /* ===============================================
           iPhone対応版 音声システム (Web Audio API)
           =============================================== */
        
        // 1. オーディオシステムの本体
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // 2. 読み込んだ音声データを貯めておく場所
        const audioBuffers = {};

        // 3. BGM管理用
        let bgmSource = null;
        let bgmGainNode = null;
        let isBgmMuted = false;
        let currentBgmType = null;

        // 音声ファイルをロードしてデコードする関数
        async function loadSound(key) {
            // すでに読み込み済みなら何もしない
            if (audioBuffers[key]) return audioBuffers[key];

            const url = SOUND_FILES[key];
            if (!url) return null;

            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const decodedBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                audioBuffers[key] = decodedBuffer;
                return decodedBuffer;
            } catch (e) {
                console.warn(`音声読み込み失敗: ${key}`, e);
                return null;
            }
        }

        /* --- 修正: 定義されているすべての音をプリロードする --- */
        // SOUND_FILES にあるキーをすべて取得して、順番に読み込みを開始する
        Object.keys(SOUND_FILES).forEach(key => {
            loadSound(key);
        });

        /* --- 再生関数 (効果音用) --- */
        async function playSoundEffect(type) {
            // 1. コンテキストが無効なら再開を試みる
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // 2. データを取得 (なければ今ロードする)
            let buffer = audioBuffers[type];
            if (!buffer) {
                buffer = await loadSound(type);
                if (!buffer) return;
            }

            // 3. 音源作成
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;

            // 4. 音量調整 (iPhoneでも効きます)
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.6; // 効果音の音量 (0.0〜1.0)

            // 5. 接続: Source -> Gain -> Speaker
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // 6. 再生
            source.start(0);
        }

        /* --- BGM再生関数 (音量調整対応) --- */
        async function playBgm(type) {
            // 同じ曲なら何もしない
            if (currentBgmType === type && bgmSource) return;

            // 前の曲を止める
            stopBgm();

            if (isBgmMuted) {
                currentBgmType = type; // タイプだけ覚えておく（ミュート解除時に再生するため）
                return; 
            }

            // データを準備
            let buffer = audioBuffers[type];
            if (!buffer) {
                buffer = await loadSound(type);
                if (!buffer) return;
            }

            // BGM用ソース作成
            bgmSource = audioCtx.createBufferSource();
            bgmSource.buffer = buffer;
            bgmSource.loop = true;

            // BGM用音量ノード
            bgmGainNode = audioCtx.createGain();
            // ★ここが重要: iPhone用にBGMをかなり小さく設定 (0.05くらいが丁度いいことが多い)
            bgmGainNode.gain.value = 0.05; 

            // 接続
            bgmSource.connect(bgmGainNode);
            bgmGainNode.connect(audioCtx.destination);

            // 再生
            bgmSource.start(0);
            currentBgmType = type;
        }

        function stopBgm() {
            if (bgmSource) {
                try { bgmSource.stop(); } catch(e){}
                bgmSource = null;
            }
            bgmGainNode = null;
            currentBgmType = null;
        }

        function toggleBgmMute() {
            isBgmMuted = !isBgmMuted;
            const btn = document.getElementById('btn-bgm-toggle');
            
            if (isBgmMuted) {
                btn.innerText = "🔇";
                stopBgm(); // 停止
                // タイプは保持しておかないと再開できないので、stopBgmで消えた分を戻す工夫が必要ですが、
                // 簡易的に「今の状態(gameState)」を見て再判定するのが確実です。
            } else {
                btn.innerText = "🔊";
                // 再開処理
                if (gameState && gameState.status === 'playing') playBgm('BGM_BATTLE');
                else playBgm('BGM_LOBBY');
            }
        }

        /* --- iPhone用のロック解除 (サイレント版) --- */
        function unlockAudioContext() {
            // 1. システムが停止中なら再開
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            // 2. 「無音」のバッファを一瞬再生して、再生権限を獲得する
            // (実際の音声ファイルは使いません)
            const emptyBuffer = audioCtx.createBuffer(1, 1, 22050);
            const source = audioCtx.createBufferSource();
            source.buffer = emptyBuffer;
            source.connect(audioCtx.destination);
            source.start(0);

        }
                
        const firebaseConfig = {
            apiKey: "AIzaSyBvdLTIWWv_7UCucT_i0Xiy7CgbGoBWUyo",
            authDomain: "seki-online.firebaseapp.com",
            projectId: "seki-online",
            storageBucket: "seki-online.firebasestorage.app",
            messagingSenderId: "196888255072",
            appId: "1:196888255072:web:0aad0ac1ec1d82485d8105",
            measurementId: "G-NV0Q9LB87B"
        };
        
        let db;
        try {
            if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
            db = firebase.database();
        } catch(e) { alert("Firebase読込エラー: " + e.message); }

        const NUMBERS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        const ASTRONOMER_CHOICES = [2, 3, 4, 5, 6, 7, 8];
        const SYMBOLS = ["REVERSE", "TRADE", "DIG UP", "DISCARD"];
        const SYMBOL_COUNTS = {"REVERSE":4, "TRADE":4, "DIG UP":4, "DISCARD":1};
        // 【修正】Ver 2.0準拠の役職定義
        const ROLES = [
            "ALCHEMIST", "ASTRONOMER", "ANGLER", "EMPEROR", "FORTUNE TELLER", 
            "GAMBLER", "HACKER", "HUNTER", "CROWN",
            "MILLIONAIRE", "POLITICIAN", "POLICE OFFICER", "THIEF", "NECROMANCER", "AGENT"
        ];

        // 【追加】役職の日本語名と簡易説明（表示用）
        // 【修正】役職情報（簡易説明 + 詳細説明）
        const ROLE_INFO = {
            "ALCHEMIST": { 
                jp: "錬金術師", 
                summary: "数字山札を引き、手札と四則演算して出す",
                desc: `<ol>
<li>数字山札から、1枚カードを引く。</li>
<li>そのカードと、手札の好きな<span style="color: #3598db;"><strong>数字カード</strong></span>で、いずれかの四則演算をする。</li>
<li>その和差積商の下一桁を、数字墓地に出せるとき、出すことができる。</li>
<li>もし出せない場合は、引いたカードは除外され、効果は終了する。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: circle;">
<li>差が負の数の場合は絶対値を取る</li>
<li>割り算では、大きい方&divide;小さい方になり、0除算は不可能</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "ASTRONOMER": {
                jp: "天文学者",
                summary: "2〜8の1枚を観測し、最強として扱う",
                desc: `<ol>
<li>順行なら「9より強い数字」を、逆行なら「1より強い数字」を、<strong>2〜8</strong>から1つ選び、観測する。</li>
<li>観測中の数字は、全プレイヤーにとって、その時点の強弱階層（順行 or 逆行）で<strong>最強</strong>として扱われる。</li>
<li>自分のターンを行う。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: circle;">
<li>観測中にREVERSEで強弱が逆転すると、当該の数字は観測不可になり<strong>最弱</strong>になる。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "ANGLER": { 
                jp: "釣り人",   
                summary: "手札1枚を除外、墓地から1枚回収",
                desc: `<ol>
<li>自分の手札から好きな<strong>カード</strong>1枚を除外する。</li>
<li>数字墓地もしくは記号墓地から、好きな<strong>カード</strong>1枚を手札に加える。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "EMPEROR": { 
                jp: "皇帝",     
                summary: "全員の手札を回収し、好きな1枚奪って残りを再配布",
                desc: `<ul style="list-style-type: square;">
<li>ゲーム開始時に自分が「皇帝」であることが他プレイヤー全員に通知される。</li>
</ul>
<ol>
<li>他プレイヤー全員の手札を回収し、見ることができる。</li>
<li>回収した手札から好きな<strong>カード</strong>を1枚選ぶ。</li>
<li>余ったカードが皇帝を含む全員に再配布される（手札の枚数は変わらない）。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "FORTUNE TELLER": { 
                jp: "占い師",   
                summary: "全員の手札と役職を見る",
                desc: `<ol>
<li>他プレイヤー全員の手札および役職を自分だけ確認することができる。</li>
<li>このとき確認した結果はログに記録され、いつでも確認することができる。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "GAMBLER": { 
                jp: "賭博師",   
                summary: "山札の数字を予想し、当たりで最大2枚の手札破棄",
                desc: `<ol>
<li>数字山札の一番上のカードについて、A: 小さい【1, 2, 3, 4】、B: 大きい【6, 7, 8, 9】、C: 命知らず【0, 5】の3つの組から予想する。</li>
<li>演出が入り、数字山札の1番上のカードが明らかになる。</li>
<li>結果により、手札の好きな<strong>カード</strong>を1枚or2枚捨てる、もしくは見た<strong><span style="color: #3598db;">数字カード</span></strong>を手札に加える。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>AおよびBを予想した場合、当たったとき自分の手札から好きな<strong>カード</strong>を<strong>1枚</strong>捨てる。</li>
<li>Cを予想した場合、 当たったときは自分の手札から好きな<strong>カード</strong>を<strong>2枚</strong>捨て，外れたときは見た<strong><span style="color: #3598db;">数字カード</span></strong>を手札に加える。</li>
<li>Cの外れ以外では、見たカードは除外される。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "HACKER": { 
                jp: "ハッカー", 
                summary: "全員のカードを1枚だけロックする",
                desc: `<ol>
<li>ハッカーを除く他プレイヤー全員に対し、手札の<strong>カード</strong>1枚を完全にロックする。</li>
<li>自分のターンを行う。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>ロックされたカードは、<span style="color: #e03e2d;"><strong>記号カード</strong></span>や<span style="color: #843fa1;"><strong>役職能力</strong></span>などあらゆる効果の対象にならない。</li>
<li>次のハッカーのターンが来たとき、ロックの効果は解除される。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "HUNTER": { 
                jp: "狩人",     
                summary: "記号山札を見て、手札と交換する",
                desc: `<ol>
<li>記号山札を見ることができる。</li>
<li>望むなら、自分の手札から好きな<span style="color: #e03e2d;"><strong>記号カード</strong></span>を、好きな枚数だけ、記号山札から同じ枚数を交換する。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>どのような交換を行ったかは、他のプレイヤーからは見えない。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "CROWN": {
                jp: "ピエロ",
                summary: "DISCARD以外の記号カードの効果を即座に使用",
                desc: `<ol>
<li>DISCARD以外の<span style="color: #e03e2d;"><strong>記号カード</strong></span>の効果を1つだけ即座に使用する。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "MILLIONAIRE": {
                jp: "富豪",
                summary: "数字カードを除外し、記号カードを引く",
                desc: `<ol>
<li>自分の手札の好きな<span style="color: #3598db;"><strong>数字カード</strong></span>を1枚除外する。</li>
<li>記号山札の一番上の<strong><span style="color: #e03e2d;">記号カード</span></strong>を手札に加える。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "POLICE OFFICER": { 
                jp: "警察官",   
                summary: "全員の手札を1枚公開し、望むならトレード",
                desc: `<ol>
<li>他のプレイヤー全員に対し、手札の1枚を選んで永続的に表にする。</li>
<li>望むなら、<span style="color: #e03e2d;"><strong>記号カード</strong></span>のTRADEと同じトレードを行うことができる。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>プレイヤーの手札間を移動したときも表のまま。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "THIEF": { 
                jp: "盗賊",     
                summary: "トレードを2回まで行う",
                desc: `<ol>
<li><strong><span style="color: #e03e2d;">記号カード</span></strong>のTRADEと同じトレードを2回まで行うことができる（1回で終了しても良い）。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>同じ相手を対象に行っても良い。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "NECROMANCER": {
                jp: "死霊使い",
                summary: "数字墓地/記号墓地から1枚除外",
                desc: `<ol>
<li>数字墓地もしくは記号墓地の、好きなカード1枚を除外する。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            },
            "POLITICIAN": {
                jp: "政治家",
                summary: "手札干渉の対象外（記号カード使用で解除）",
                desc: `<ol>
<li>発動すると、手札干渉効果（<span style="color: #e03e2d;"><strong>TRADE</strong></span>、<span style="color: #843fa1;"><strong>ハッカー</strong></span>、<span style="color: #843fa1;"><strong>占い師</strong></span>、<span style="color: #843fa1;"><strong>皇帝</strong></span>、<span style="color: #843fa1;"><strong>警察官</strong><span style="color: #000000;">、</span><strong>盗賊</strong><span style="color: #000000;">、</span><strong>ピエロ</strong><span style="color: #000000;">、</span><strong>工作員</strong></span>）に選択されなくなる。</li>
<li>自分のターンを行う。</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: circle;">
<li>保護効果を受けている間に、自分自身で<span style="color: #e03e2d;"><strong>記号カード</strong></span>（&nbsp;<strong>DISCARD</strong> / <strong>REVERSE</strong> / <strong>TRADE</strong> / <strong>DIG UP）</strong>を使うと、保護は即時解除される。</li>
</ul>
</li>
</ul>
<div><strong>ターン終了！</strong></div>`
            },
            "AGENT": {
                jp: "工作員",
                summary: "任意の2人の手札をランダムに1枚交換",
                desc: `<ol>
<li>自分を含む任意のプレイヤーから対象を2人を選ぶ。</li>
<li>対象の2人の手札から、ランダムに1枚ずつ交換される。</li>
<li>自分のターンを行う。</li>
</ol>
<div><strong>ターン終了！</strong></div>`
            }
        };

        let myId = localStorage.getItem("seki_uid_v2");
        if (!myId) {
            myId = Date.now().toString() + "_" + Math.random().toString(36).substr(2, 5);
            localStorage.setItem("seki_uid_v2", myId);
        }
        
        let prevHandCounts = {}; // 手札枚数の記録用（SE再生に使用）
        const audioCache = {};
        // ★追加: ホスト設定の前回値を覚えておく変数
        let lastHostHandMode = 6;

        let currentRoom = null;
        let myName = "";
        let selectedIdx = -1;
        let gameState = null;
        let drawnCardTemp = null;
        let wasMyTurn = false;
        let hasFinished = false;
        let joined = false;
        let lastReadLogTime = 0; // チャット既読用
        let prevActivatedList = {}; // 前回の発動状況を記録する
        let prevRevealedRoles = {}; // カミングアウト状況を記録する
    
        let prevSoundId = 0;
        let lastGraveNumCount = -1; // 前回の数字墓地の枚数
        let lastGraveSymCount = -1; // 前回の記号墓地の枚数
        let necromancerTargetType = null;
        let necromancerTargetIdx = -1;
        // ★追加: ハッカー解除制御用の変数
        let lastCleanupTurnIdx = -1;
        let myRankPlayed = false; // ★追加: 順位決定音が再生済みかどうかのフラグ
        let lastChatTimeProcessed = 0; // ★追加: チャット吹き出し用
        

        const els = {
            login: document.getElementById("login-screen"),
            game: document.getElementById("game-screen"),
            roomName: document.getElementById("roomName"),
            roomSuggestion: document.getElementById("room-suggestion-panel"),
            playerName: document.getElementById("playerName"),
            hand: document.getElementById("my-hand"),
            indicator: document.getElementById("indicator"),
            graveNum: document.getElementById("graveNum"),
            graveSym: document.getElementById("graveSym"),
            others: document.getElementById("other-players"),
            msg: document.getElementById("msg"),
            hostCtrl: document.getElementById("host-controls"),
            log: document.getElementById("game-log-bar"),
            modal: document.getElementById("modal-overlay"),
            mBox: document.getElementById("modal-box"),
            mTitle: document.getElementById("modal-title"),
            mContent: document.getElementById("modal-content"),
            deckNum: document.getElementById("deckNumCount"),
            deckSym: document.getElementById("deckSymCount"),
            mFooter: document.getElementById("modal-footer"),
            btnJoin: document.getElementById("btn-join"),
            btnChat: document.getElementById("btn-chat-icon")
        };

        const ROOM_CAPACITY = 5;
        let roomSuggestionTimer = null;
        let roomSuggestionCache = [];

        function setRoomSuggestionVisible(visible) {
            if (!els.roomSuggestion) return;
            if (visible) els.roomSuggestion.classList.remove("hidden");
            else els.roomSuggestion.classList.add("hidden");
        }

        function stopRoomSuggestionPolling() {
            if (roomSuggestionTimer !== null) {
                clearInterval(roomSuggestionTimer);
                roomSuggestionTimer = null;
            }
        }

        function renderRoomSuggestions(list) {
            if (!els.roomSuggestion || !els.roomName) return;

            const filterText = els.roomName.value.trim().toLowerCase();
            const filtered = list.filter(item =>
                !filterText || item.name.toLowerCase().includes(filterText)
            );

            els.roomSuggestion.innerHTML = "";

            const title = document.createElement("div");
            title.className = "room-suggestion-title";
            title.innerText = "Current Rooms";
            els.roomSuggestion.appendChild(title);

            if (filtered.length === 0) {
                const empty = document.createElement("div");
                empty.className = "room-suggestion-empty";
                empty.innerText = "No matching rooms";
                els.roomSuggestion.appendChild(empty);
                return;
            }

            filtered.slice(0, 20).forEach((item) => {
                const btn = document.createElement("button");
                btn.type = "button";
                btn.className = "room-suggestion-item";
                btn.innerText = `${item.name} (${item.count}/${ROOM_CAPACITY})`;
                btn.addEventListener("mousedown", (ev) => {
                    ev.preventDefault();
                    els.roomName.value = item.name;
                    setRoomSuggestionVisible(false);
                    stopRoomSuggestionPolling();
                    if (els.playerName) els.playerName.focus();
                });
                els.roomSuggestion.appendChild(btn);
            });
        }

        async function refreshRoomSuggestions() {
            if (!db || !els.roomSuggestion || !els.roomName || currentRoom) return;
            try {
                const snapshot = await db.ref("rooms").get();
                const rooms = snapshot.val() || {};

                roomSuggestionCache = Object.entries(rooms)
                    .map(([name, data]) => {
                        const players = (data && data.players) ? data.players : {};
                        return { name, count: Object.keys(players).length };
                    })
                    .filter(item => !!item.name)
                    .sort((a, b) => (b.count - a.count) || a.name.localeCompare(b.name, "ja"));

                renderRoomSuggestions(roomSuggestionCache);
            } catch (e) {
                els.roomSuggestion.innerHTML = `
                    <div class="room-suggestion-title">Current Rooms</div>
                    <div class="room-suggestion-empty">Failed to load room list</div>
                `;
            }
        }

        function startRoomSuggestionPolling() {
            if (roomSuggestionTimer !== null || currentRoom) return;
            refreshRoomSuggestions();
            roomSuggestionTimer = setInterval(refreshRoomSuggestions, 5000);
        }

        function setupRoomSuggestionEvents() {
            if (!els.roomName || !els.roomSuggestion) return;

            els.roomName.addEventListener("focus", () => {
                setRoomSuggestionVisible(true);
                if (roomSuggestionCache.length > 0) renderRoomSuggestions(roomSuggestionCache);
                startRoomSuggestionPolling();
            });

            els.roomName.addEventListener("click", () => {
                setRoomSuggestionVisible(true);
                if (roomSuggestionCache.length > 0) renderRoomSuggestions(roomSuggestionCache);
                startRoomSuggestionPolling();
            });

            els.roomName.addEventListener("input", () => {
                setRoomSuggestionVisible(true);
                if (roomSuggestionCache.length > 0) renderRoomSuggestions(roomSuggestionCache);
                else refreshRoomSuggestions();
            });

            els.roomName.addEventListener("keydown", (ev) => {
                if (ev.key === "Escape") {
                    setRoomSuggestionVisible(false);
                    stopRoomSuggestionPolling();
                }
            });

            document.addEventListener("mousedown", (ev) => {
                if (!els.roomSuggestion || els.roomSuggestion.classList.contains("hidden")) return;
                if (ev.target === els.roomName || els.roomSuggestion.contains(ev.target)) return;
                setRoomSuggestionVisible(false);
                stopRoomSuggestionPolling();
            });
        }

        setupRoomSuggestionEvents();

        // --- モーダル関数 ---
        function normalizeModalOptions(options = {}) {
            const normalized = { size: "default", tone: "default" };
            if (!options || typeof options !== "object") return normalized;
            if (["default", "wide", "narrow"].includes(options.size)) normalized.size = options.size;
            if (["default", "guide", "alert"].includes(options.tone)) normalized.tone = options.tone;
            return normalized;
        }

        function applyModalPresentation(options) {
            if (!els.modal || !els.mBox) return;
            els.modal.classList.remove("modal-tone-default", "modal-tone-guide", "modal-tone-alert");
            els.mBox.classList.remove(
                "modal-size-default", "modal-size-wide", "modal-size-narrow",
                "modal-tone-default", "modal-tone-guide", "modal-tone-alert"
            );
            els.modal.classList.add(`modal-tone-${options.tone}`);
            els.mBox.classList.add(`modal-size-${options.size}`);
            els.mBox.classList.add(`modal-tone-${options.tone}`);
        }

        function renderModalButton(label, onClick, variant = "ghost", extraClass = "", disabled = false) {
            const classList = ["modal-btn"];
            if (variant === "primary") classList.push("primary");
            else if (variant === "danger") classList.push("danger");
            else classList.push("ghost");
            if (extraClass) classList.push(extraClass);
            const disabledAttr = disabled ? "disabled" : "";
            return `<button onclick="${onClick}" class="${classList.join(" ")}" ${disabledAttr}>${label}</button>`;
        }

        function renderCardView(card, options = {}) {
            if (!card) return `<div class="card">?</div>`;
            let cssClass = options.cssClass || `card ${card.type}`;
            if (card.isOpen && !cssClass.includes("revealed")) cssClass += " revealed";
            const imgUrl = CARD_IMAGES[card.val];
            const imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid rgba(255,255,255,0.92);` : "";
            const extraStyle = options.style || "";
            const onClick = options.onClick ? ` onclick="${options.onClick}"` : "";
            const attrs = options.attrs ? ` ${options.attrs}` : "";
            const val = (card.val === 0 || card.val) ? card.val : "?";
            const hasImgClass = imgUrl ? " has-img" : "";
            return `<div class="${cssClass}${hasImgClass}" style="${imgStyle}${extraStyle}"${onClick}${attrs}>${val}</div>`;
        }

        function renderNoticeBlock(html, tone = "info") {
            const toneClass = tone === "warn" ? "warn" : "";
            return `<span class="seki-note ${toneClass}">${html}</span>`;
        }

        function renderSectionBlock(html, tone = "default") {
            const toneClass = (tone === "warn" || tone === "info") ? ` ${tone}` : "";
            return `<div class="seki-section${toneClass}">${html}</div>`;
        }

        function openModal(title, html, options = {}) {
            const modalOptions = normalizeModalOptions(options);
            els.mTitle.innerText = title;
            els.mContent.innerHTML = html;
            els.mFooter.innerHTML = renderModalButton("閉じる", "closeModal()", "ghost");
            applyModalPresentation(modalOptions);
            els.modal.classList.remove("hidden");
        }
        function showInfoModal(title, msg, options = {}) {
            const modalOptions = normalizeModalOptions(options);
            els.mTitle.innerText = title;
            els.mContent.innerHTML = `<p>${msg}</p>`;
            els.mFooter.innerHTML = renderModalButton("OK", "closeModal()", "primary");
            applyModalPresentation(modalOptions);
            els.modal.classList.remove("hidden");
        }
        function showConfirmModal(title, msg, yesCallbackStr, options = {}) {
            const modalOptions = normalizeModalOptions(options);
            els.mTitle.innerText = title;
            els.mContent.innerHTML = `<p>${msg}</p>`;
            els.mFooter.innerHTML = `
                ${renderModalButton("はい", `${yesCallbackStr}; closeModal()`, "primary")}
                ${renderModalButton("いいえ", "closeModal()", "ghost")}
            `;
            applyModalPresentation(modalOptions);
            els.modal.classList.remove("hidden");
        }
        function closeModal() {
            if (!els.modal || !els.mBox) return;
            els.modal.classList.add("hidden");
            applyModalPresentation({ size: "default", tone: "default" });
        }

        function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); }
        function sortCards(hand) {
            if(!hand) return [];
            hand.sort((a,b) => {
                if(a.type !== b.type) return a.type === 'num' ? -1 : 1;
                if(a.type === 'num') return a.val - b.val;
                const sOrder = ["REVERSE", "TRADE", "DIG UP", "DISCARD"];
                return sOrder.indexOf(a.val) - sOrder.indexOf(b.val);
            });
            return hand;
        }

        // --- ログシステム & 色生成 ---
        function getPoliticianShieldMap(data = gameState) {
            if (!data || !data.politicianShield) return {};
            return data.politicianShield;
        }

        function isPoliticianShieldActive(pid, data = gameState) {
            return !!(pid && getPoliticianShieldMap(data)[pid]);
        }

        function canTargetByHandInterference(targetId) {
            if (!isPoliticianShieldActive(targetId)) return true;
            return false;
        }

        async function clearPoliticianShieldIfNeeded(playerId, updates, reasonText = "") {
            const shieldMap = {...(getPoliticianShieldMap() || {})};
            if (!shieldMap[playerId]) return false;

            delete shieldMap[playerId];
            updates[`rooms/${currentRoom}/politicianShield`] = shieldMap;

            const pName = (gameState && gameState.players && gameState.players[playerId]) ? gameState.players[playerId].name : "Player";
            const suffix = reasonText ? ` (${reasonText})` : "";
            await pushLog(`${pName} の[政治家]保護が解除されました${suffix}`, 'public');
            return true;
        }

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 70%, 40%)`;
        }

        async function pushLog(text, type='public', targetId=null) {
            if(!currentRoom) return;
            const logEntry = { text: text, type: type, targetId: targetId, timestamp: Date.now() };
            let logs = (gameState && gameState.logs) ? [...gameState.logs] : [];
            logs.push(logEntry);
            if(logs.length > 50) logs.shift(); 
            await db.ref(`rooms/${currentRoom}/logs`).set(logs);
        }

        function renderLogs(logs) {
            if(!logs || logs.length === 0) { els.log.innerText = "ログなし"; return; }
            let lastLog = logs[logs.length-1];
            
            // 最新ログ表示
            let display = "";
            for(let i=logs.length-1; i>=0; i--) {
                let l = logs[i];
                if(l.type === 'public' || l.targetId === myId || l.type === 'chat') {
                    let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit'});
                    display = `${time} ${l.text}`;
                    break;
                }
            }
            els.log.innerText = display + " (タップで履歴＆チャット)";

            // ▼▼▼ 修正箇所: チャット吹き出し表示処理 ▼▼▼
            const now = Date.now(); // 現在時刻を取得

            // ▼▼▼ 追加: チャット吹き出し表示処理 ▼▼▼
            // 今回のレンダリングでまだ処理していない、かつ新しいチャットのみ対象
            logs.forEach(l => {
                if (l.type === 'chat') {
                    // 1. 吹き出し表示ロジック (4秒以内の発言なら表示し続ける)
                    // これにより、画面が再描画されても吹き出しが維持されます
                    if (now - l.timestamp < 4000) {
                        if (l.targetId) {
                            // ★修正: 第三引数に timestamp を渡す
                            showChatBubble(l.targetId, l.text, l.timestamp);
                        }
                    }
                }
            });
            
            // 最新のタイムスタンプを記録
            if (lastLog) {
                lastChatTimeProcessed = Math.max(lastChatTimeProcessed, lastLog.timestamp);
            }
            // ▲▲▲ 追加ここまで ▲▲▲

            // ★チャット通知
            if (lastLog.type === 'chat' && lastLog.targetId !== myId) {
                const match = lastLog.text.match(/^\[(.*?)\]/);
                const senderName = match ? match[1] : "";
                
                if (senderName !== myName && lastLog.timestamp > lastReadLogTime) {
                    // els.btnChat.classList.add("notify-active");
                    if (Date.now() - lastLog.timestamp < 2000) { // 2秒以内の新着なら鳴らす
                         playSoundEffect('chat');
                    }
                }
            }
        }

        // ▼▼▼ 新規関数: 吹き出し表示 ▼▼▼
        function showChatBubble(pid, text, timestamp) {
            const bubble = document.getElementById(`bubble-${pid}`);
            if (!bubble) return;

            // 名前部分 "[Name] " を除去してメッセージだけにする
            const match = text.match(/^\[.*?\] (.*)$/);
            const msg = match ? match[1] : text;

            bubble.innerText = msg;

            // ★追加: 経過時間を計算して、アニメーションを「途中から」開始させる
            // これにより、画面が書き換わっても見た目上のアニメーションは継続しているように見えます
            const elapsed = Date.now() - timestamp;
            
            // アニメーションリセット（連続投稿対応）
            bubble.classList.remove("active");
            void bubble.offsetWidth; // リフロー強制

            // ★重要: 経過時間分だけアニメーションを「巻き戻して」セットする
            // (例: 1秒経過していたら、最初から1秒進んだ状態から表示される)
            bubble.style.animationDelay = `-${elapsed}ms`;

            bubble.classList.add("active");
        }

        function showLogHistory() {
            if(!gameState) return;
            let logs = gameState.logs || [];
            
            // ★既読処理
            lastReadLogTime = Date.now();
            // els.btnChat.classList.remove("notify-active");
            //els.log.classList.remove("notify-bar");

            let html = `
                <div id="chat-input-container">
                    <input type="text" id="chat-input" placeholder="メッセージを入力..." onkeydown="if(event.key==='Enter' && !event.isComposing){sendChat();}">
                    <button id="chat-send-btn" onclick="sendChat()">送信</button>
                </div>
                <div id="log-list-container">
            `;
            
            [...logs].reverse().forEach(l => {
                if(l.type === 'private' && l.targetId !== myId) return;
                let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit', second:'2-digit'});
                let styleClass = '';
                let content = l.text;

                if(l.type === 'private') {
                    styleClass = 'log-private';
                } else if(l.type === 'chat') {
                    styleClass = 'log-chat';
                    const match = content.match(/^\[(.*?)\] (.*)$/);
                    if (match) {
                        const name = match[1];
                        const msg = match[2];
                        const color = stringToColor(name);
                        content = `<span style="color:${color}; font-weight:bold;">[${name}]</span> ${msg}`;
                    }
                }
                html += `<div class="log-entry ${styleClass}"><span class="log-time">${time}</span><span class="log-text">${content}</span></div>`;
            });
            html += `</div>`;
            openModal("チャット & ログ", html);
        }

        async function sendChat() {
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if(!msg) return;

            await pushLog(`[${myName}] ${msg}`, 'chat', myId);

            input.value = "";
            lastReadLogTime = Date.now();
            showLogHistory(); 
        }
        
        // プレイヤーを入室順（joinedAtが早い順）に並べる関数
        function getSortedPlayerIds(players) {
            return Object.keys(players).sort((a, b) => {
                const tA = players[a].joinedAt || 0;
                const tB = players[b].joinedAt || 0;
                // 時間が同じならID順、あれば時間順
                if (tA === tB) return a.localeCompare(b);
                return tA - tB;
            });
        }

        async function leaveRoom() {
            if (!currentRoom || !myId) {
                location.reload();
                return;
            }

            if (window.confirm("部屋を抜けてタイトルに戻りますか？")) {
                try {
                    // 1. Firebaseから自分のプレイヤーデータを削除
                    await db.ref(`rooms/${currentRoom}/players/${myId}`).remove();
                    
                    // 2. ページをリロードして初期状態に戻る
                    location.reload();
                } catch (e) {
                    console.error("退室エラー:", e);
                    location.reload(); // エラーが起きても強制的にタイトルへ
                }
            }
        }

        async function joinGame() {
            unlockAudioContext();
            if(currentRoom) return; 
            els.btnJoin.disabled = true; 
            
            lastReadLogTime = Date.now();

            try {
                const room = els.roomName.value.trim();
                const name = els.playerName.value.trim();
                if (!room || !name) {
                    els.btnJoin.disabled = false;
                    return showInfoModal("入力エラー", "部屋名と名前を入力してください");
                }

                // ▼▼▼▼▼ ここから追加・修正 ▼▼▼▼▼
                
                // 1. まず部屋のデータを取得して確認する
                const checkRef = db.ref(`rooms/${room}`);
                const snapshot = await checkRef.get();

                if (snapshot.exists()) {
                    const data = snapshot.val();
                    const players = data.players || {};
                    const playerCount = Object.keys(players).length;
                    
                    // 「自分がまだリストにいない」かつ「既に5人以上いる」ならエラー
                    // (リロードして戻ってきた人は入れるように !players[myId] で判定します)
                    if (!players[myId] && playerCount >= 5) {
                        els.btnJoin.disabled = false;
                        return showInfoModal("満員", "この部屋は定員(5名)に達しています。<br>別の部屋名を使ってください。");
                    }

                    // ★追加: 名前重複チェック
                    // IDが違うのに、同じ名前の人がいたらエラーにする
                    const isNameDuplicate = Object.keys(players).some(pid => {
                        // 自分自身は除外
                        if (pid === myId) return false;
                        // 名前が一致するかチェック
                        return players[pid].name === name;
                    });

                    if (isNameDuplicate) {
                         els.btnJoin.disabled = false;
                         return showInfoModal("名前重複", "その名前は既に使用されています。<br>別の名前を使ってください。");
                    }

                }
                

                myName = name;
                currentRoom = room;

                const updates = {};
                updates[`rooms/${room}/players/${myId}/name`] = name;
                updates[`rooms/${room}/players/${myId}/online`] = true;
                //★変更：サーバーの正確な時間を使って「入室時刻」を記録する
                updates[`rooms/${room}/players/${myId}/joinedAt`] = firebase.database.ServerValue.TIMESTAMP;


                await db.ref().update(updates);
                joined = true;

                setupEffectListener();
                playBgm('BGM_LOBBY');

                const roomRef = db.ref(`rooms/${room}`);
                roomRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        gameState = data;
                        render(data);
                    } else {
                        if (joined && gameState && gameState.playerOrder) {
                            showInfoModal("終了", "部屋が解散（削除）されました。");
                            setTimeout(() => location.reload(), 2000);
                        } else {
                            gameState = { players: { [myId]: { name, online: true } }, logs: [] };
                            render(gameState);
                        }
                    }
                });

                

                setRoomSuggestionVisible(false);
                stopRoomSuggestionPolling();
                els.login.classList.add("hidden");
                els.game.classList.remove("hidden");
                document.getElementById("room-display").innerText = `部屋: ${room}`;
            } catch(e) { 
                showInfoModal("通信エラー", e.message); 
                els.btnJoin.disabled = false;
            }
        }

        function confirmCloseRoom() {
            showConfirmModal("解散確認", "本当に部屋を解散しますか？", "execCloseRoom()");
        }
        async function execCloseRoom() {
            try { await db.ref(`rooms/${currentRoom}`).remove(); location.reload(); } 
            catch(e) { showInfoModal("エラー", "削除失敗: " + e.message); }
        }

        /* --- 修正版 confirmInitGame --- */
        function confirmInitGame() {
            // showConfirmModalを使うと、ボタンを押した瞬間に強制的に閉じてしまい、
            // エラーメッセージまで消してしまうので、手動でボタンを作ります。
            
            els.mTitle.innerText = "開始確認";
            els.mContent.innerHTML = "<p>ゲームを開始（リセット）しますか？</p>";
            els.mFooter.innerHTML = `
                <button onclick="closeModal(); execInitGame()" class="modal-btn primary">はい</button>
                <button onclick="closeModal()" class="modal-btn">いいえ</button>
            `;
            els.modal.classList.remove("hidden");
        }
        async function execInitGame(fixedNumCount) {
            try {
                const players = gameState.players || {};

                // 1. 入室順リスト取得
                let playerIds = getSortedPlayerIds(players);

                // 2. 最下位を先頭へ
                if (gameState.rankings) {
                    let loserId = Object.keys(gameState.rankings).reduce((a, b) => 
                        gameState.rankings[a] > gameState.rankings[b] ? a : b
                    , null);

                    if (loserId && playerIds.includes(loserId)) {
                        playerIds = playerIds.filter(pid => pid !== loserId);
                        playerIds.unshift(loserId);
                    }
                }

                if(playerIds.length < 2) return showInfoModal("エラー", "最低2人のプレイヤーが必要です！");

                // ★修正: 引数で枚数を受け取る（なければデフォルト6）
                // (モーダル内の要素を探す処理は削除しました)
                let numCount = fixedNumCount || 6;

                let deckNum = [];
                NUMBERS.forEach(n => { for(let i=0; i<4; i++) deckNum.push({type:'num', val:n}); });
                let deckSym = [];
                SYMBOLS.forEach(s => { for(let i=0; i<SYMBOL_COUNTS[s]; i++) deckSym.push({type:'sym', val:s}); });
                
                shuffle(deckNum);
                shuffle(deckSym);

                /* --- execInitGame関数内 --- */
                
                let hands = {};
                let roles = {};
                
                // 役職シャッフル（重複なしで配るため）
                let availRoles = [...ROLES];
                shuffle(availRoles);
                
      
                playerIds.forEach((pid, i) => {
                    let h = [];
                    // ★枚数選択反映
                    for(let k=0; k<numCount; k++) h.push(deckNum.pop());
                    for(let k=0; k<2; k++) h.push(deckSym.pop());
                    h = sortCards(h);
                    hands[pid] = h;
                    roles[pid] = availRoles.pop();
                });

                // ★追加: 皇帝のカミングアウト判定
                let revealedRoles = {};
                let coLogs = [];
                
                playerIds.forEach(pid => {
                    const r = roles[pid];
                    if (r === "EMPEROR") {
                        revealedRoles[pid] = true; // 最初から公開状態にする
                        let rNameJP = (ROLE_INFO[r]) ? ROLE_INFO[r].jp : r;
                        coLogs.push({
                            text: `${players[pid].name} は [${rNameJP}] であることをカミングアウトしました！`,
                            type: 'public',
                            timestamp: Date.now()
                        });
                        
                        // 皇帝ならカットイン演出も予約（initDataのログに入れておく）
                        if (r === "EMPEROR") {
                             // ここで直接カットインは出せないので、ログを見て検知させるか、
                             // シンプルにログ通知だけで済ませるのが安全です。
                        }
                    }
                });
                
                // ▲▲▲ ここまで挿入 ▲▲▲

                const initData = {
                    status: "playing",
                    deckNum,
                    deckSym,
                    graveNum: [],
                    graveSym: [],
                    exclusion: [],
                    isReverse: false,
                    turnIdx: 0,
                    playerOrder: playerIds,
                    passCount: 0,
                    hands, roles, players, rankings: {}, 
                    astronomerObservation: null,
                    // 【追加】能力使用済みフラグ（初期値は空）
                    activatedList: {},
                    politicianShield: {},
                    revealedRoles: revealedRoles,

                    // ★追加: ハッキングされたカードの隔離所
                    hackedHands: null,

                    // ▼▼▼ 修正: ここに lastSound: null を追加して、前の音を消す ▼▼▼
                    lastSound: null,
                    // ▲▲▲ 追加ここまで ▲▲▲

                    // ログにカミングアウト情報を追加
                    logs: [
                        {text: `ゲーム開始！(数字${numCount}枚モード)`, type: "public", timestamp: Date.now()},
                        ...coLogs 
                    ]
                };

                wasMyTurn = false;
                hasFinished = false;
                await db.ref(`rooms/${currentRoom}`).update(initData);
            } catch(e) { showInfoModal("エラー", "開始エラー: " + e.message); }
        }

        // ★共通関数: リセット権の継承判定ロジック
        function checkInheritedResetLogic(data, myId) {
            if (!data) return false;
            
            let top = (data.graveNum && data.graveNum.length > 0) ? data.graveNum[data.graveNum.length-1] : null;
            
            // 1. 基本条件: 墓地にカードがあり、その持ち主が前回の勝者であり、かつその勝者が今回のランキングに存在すること
            if (!top || !data.lastWinnerId || data.lastWinnerId !== top.owner) return false;
            if (!data.rankings || !data.rankings[data.lastWinnerId]) return false;

            // 2. 生存人数計算 (あがっていない人)
            let activePIds = (data.playerOrder || []).filter(pid => !data.rankings || !data.rankings[pid]);
            let activeCount = activePIds.length;
            if (activeCount <= 0) return false;

            // 3. 一周判定ガード:
            // 手番が「勝者の次の生存者」に戻っている時だけ継承成立を許可する
            if (!Array.isArray(data.playerOrder) || typeof data.turnIdx !== 'number') return false;
            let winnerIdx = data.playerOrder.indexOf(data.lastWinnerId);
            if (winnerIdx < 0) return false;
            let cycleStartIdx = getNextActivePlayerIndex(winnerIdx, data.playerOrder, data.rankings || {});
            if (cycleStartIdx < 0 || data.turnIdx !== cycleStartIdx) return false;
            
            // 4. ログ解析: 勝った時間より後のログを確認
            let winTime = data.lastWinnerTime || 0;
            let logs = data.logs || [];
            let actedNames = new Set();
            let recentLogs = logs.filter(l => l.timestamp > winTime && l.type === 'public');

            recentLogs.forEach(l => {
                let match = l.text.match(/^(.+?)が/);
                if (match) actedNames.add(match[1]);
            });

            // 5. 除外処理 (勝者本人を除外)
            if (data.players && data.players[data.lastWinnerId]) {
                actedNames.delete(data.players[data.lastWinnerId].name);
            }

            // 6. 判定
            return actedNames.size >= activeCount;
        }

       function render(data) {
            // 1. 要素の取得
            let turnIndicator = document.getElementById("turn-indicator");
            let graveContainer = document.getElementById("grave-container");
            let handContainer = document.getElementById("my-hand");
            let hackedContainer = document.getElementById("hacked-area");
           
            // 2. クリア
            if(handContainer) handContainer.innerHTML = "";
            if(hackedContainer) hackedContainer.innerHTML = "";

            // 3. データ準備
            const players = data.players || {};
            const hands = data.hands || {};
            const roles = data.roles || {};
            const hackedHands = data.hackedHands || {};
            const currentAct = data.activatedList || {};
            const currentRev = data.revealedRoles || {};

            // ★追加: 墓地トップとリセット権所有者の計算（位置を上に移動）
            let top = (data.graveNum && data.graveNum.length > 0) ? data.graveNum[data.graveNum.length-1] : null;
            let resetHolder = top ? top.owner : null;

           // ★修正: 共通関数を使ってリセット権の継承判定を行う
            let isInheritedReset = checkInheritedResetLogic(data, myId);

            // ★決定: 最終的なリセット権を持つプレイヤーID
            // 継承が起きているなら「現在の手番プレイヤー」、そうでなければ「カードの持ち主」
            let effectiveResetHolder = resetHolder;
            if (isInheritedReset && data.playerOrder) {
                effectiveResetHolder = data.playerOrder[data.turnIdx];
            }

            // ★追加: 実質的なホスト（権限者）を決定する
            // 通常は先頭の人だが、ゲーム終了時は「最下位の人」に権限を移す
            let pIdsForHost = getSortedPlayerIds(players);
            if (data.playerOrder) pIdsForHost = data.playerOrder;
            
            let effectiveHostId = (pIdsForHost.length > 0) ? pIdsForHost[0] : null;

            if (data.status === "finished" && data.rankings) {
                let loserId = Object.keys(data.rankings).reduce((a, b) => 
                    data.rankings[a] > data.rankings[b] ? a : b
                , null);
                
                if (loserId && players[loserId]) {
                    effectiveHostId = loserId;
                }
            }

            // ↓↓↓ 修正: "山札: xx枚" という文字を消し、数字だけ入れる ↓↓↓
            if (data.deckNum && els.deckNum) els.deckNum.innerText = data.deckNum.length;
            if (data.deckSym && els.deckSym) els.deckSym.innerText = data.deckSym.length;
            
            // -----------------------------------------------------
            // A. ゲーム進行中の描画
            // -----------------------------------------------------
            if (data.status === "playing" || data.status === "finished") {
                
                // --- 1. 手札の描画 (統合版・安全対策済み) ---
                if (handContainer) {
                    handContainer.innerHTML = ""; // クリア

                    let rawHand = hands[myId];
                    let myHand = rawHand ? sortCards(deepCopy(rawHand)) : [];
                    let myLockedHand = hackedHands[myId] || [];
                    
                    const fragment = document.createDocumentFragment();

                    // 【対策A】 「通常の手札」
                    myHand.forEach((c, i) => {
                        let div = document.createElement("div");
                        let cssClass = `card ${c.type}`;
                        if (c.isOpen) cssClass += " revealed";

                        div.className = cssClass;
                        // if(c.val === 0) div.setAttribute("data-val", "0");
                        if(i === selectedIdx) div.classList.add("selected");
                        
                        let valNode = document.createTextNode(c.val);
                        div.appendChild(valNode);
                        
                        let imgUrl = CARD_IMAGES[c.val];
                        if (imgUrl) {
                            div.style.backgroundImage = `url('${imgUrl}')`;
                            div.classList.add('has-img');
                        }

                        if (data.status === "playing" && !data.rankings?.[myId]) {
                            div.onclick = () => {
                                selectedIdx = (selectedIdx === i) ? -1 : i;
                                render(data);
                            };
                        }
                        fragment.appendChild(div);
                    });

                    // 【対策B】 「隔離カード」
                    myLockedHand.forEach(c => {
                        let div = document.createElement("div");
                        div.className = `card ${c.type} locked`; 
                        
                        let imgUrl = CARD_IMAGES[c.val];
                        if (imgUrl) {
                            div.style.backgroundImage = `url('${imgUrl}')`;
                            div.classList.add('has-img');
                        }
                        
                        let valNode = document.createTextNode(c.val);
                        div.appendChild(valNode);
                        // if(c.val === 0) div.setAttribute("data-val", "0");

                        div.onclick = () => showInfoModal("ロック中", "このカードは機能停止しています。");
                        fragment.appendChild(div);
                    });

                    handContainer.appendChild(fragment);
                }

                // --- 3. 役職パネルの描画 ---
                const myRole = roles[myId];
                const rInfo = (typeof ROLE_INFO !== 'undefined') ? ROLE_INFO[myRole] : null;
                
                let roleArea = document.getElementById("my-role-panel");
                if(!roleArea && document.getElementById("my-area")) {
                    roleArea = document.createElement("div");
                    roleArea.id = "my-role-panel";
                    let controls = document.getElementById("controls");
                    if(controls) document.getElementById("my-area").insertBefore(roleArea, controls);
                }

                if (roleArea && myRole && rInfo) {
                    let actBtnHtml = "";
                    let isActivated = currentAct[myId];
                    let isPoliticianShielded = isPoliticianShieldActive(myId, data);
                    
                    if (isMyTurn() && !isActivated && data.status === "playing") {
                        let funcName = "";
                        // 各役職の発動関数マッピング
                        if (myRole === "ANGLER") funcName = "activateAngler()";
                        else if (myRole === "FORTUNE TELLER") funcName = "activateFortuneTeller()";
                        else if (myRole === "THIEF") funcName = "activateThief(1)";
                        else if (myRole === "HUNTER") funcName = "activateHunter()";
                        else if (myRole === "GAMBLER") funcName = "activateGambler()";
                        else if (myRole === "CROWN") funcName = "activateMagician()";
                        else if (myRole === "MILLIONAIRE") funcName = "activateMillionaire()";
                        else if (myRole === "EMPEROR") funcName = "activateEmperor()";
                        else if (myRole === "POLITICIAN") funcName = "activatePolitician()";
                        else if (myRole === "POLICE OFFICER") funcName = "activatePoliceOfficer()";
                        else if (myRole === "HACKER") funcName = "activateHacker()";
                        else if (myRole === "ALCHEMIST") funcName = "activateAlchemist()";
                        else if (myRole === "ASTRONOMER") funcName = "activateAstronomer()";
                        else if (myRole === "NECROMANCER") funcName = "activateNecromancer()";
                        else if (myRole === "AGENT") funcName = "activateAgent()";

                        if (funcName) {
                            actBtnHtml = `<button onclick="${funcName}" class="seki-btn seki-btn-mini seki-btn-accent role-activate-btn">スキル発動</button>`;
                        }
                    } else if (isActivated) {
                        let statusText = "(発動済み)";
                        if (myRole === "POLITICIAN") statusText = isPoliticianShielded ? "保護中" : "使用済み";
                        else if (myRole === "EMPEROR") statusText = "使用済み";
                        else if (myRole === "ASTRONOMER") statusText = getAstronomerRoleSubText(data) || "使用済み";
                        
                        // ▼▼▼ 修正: ピエロの場合、中身を表示 ▼▼▼
                        if (myRole === "CROWN" && typeof isActivated === 'string') {
                            // 役職IDなら日本語に変換、そうでなければそのまま表示(REVERSE等)
                            let val = isActivated;
                            if (ROLE_INFO[val]) val = ROLE_INFO[val].jp;
                            
                            statusText = `使用: ${val}`;
                        }
                        // ▲▲▲ 修正ここまで ▲▲▲
                        
                        actBtnHtml = `<div class="role-status-badge">${statusText}</div>`;
                    }

                    // 背景スタイル
                    let roleCardClass = "role-card";
                    if (isActivated) roleCardClass += " is-used";
                    const bgUrl = (typeof ROLE_IMAGES !== 'undefined') ? ROLE_IMAGES[myRole] : null;
                    let bgStyle = "";
                    
                    if (myRole === "EMPEROR") {
                        roleCardClass += " role-emperor";
                        if (bgUrl) {
                            bgStyle = `background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(0,0,0,0.6)), url('${bgUrl}'); background-size: cover; background-position: center 12%; border: 3px solid #fff; animation: goldPulse 2s infinite alternate;`;
                        } else {
                            bgStyle = `background: linear-gradient(45deg, #FFD700, #FDB931, #FFED86, #FFD700); background-size: 200% 200%; border: 3px solid #fff; animation: goldShine 3s ease infinite, goldPulse 2s infinite alternate; color: #3e2723; text-shadow: none;`;
                        }
                    } else if (bgUrl) {
                        bgStyle = `background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.8)), url('${bgUrl}'); background-size: cover; background-position: center 12%;`;
                    } else {
                        bgStyle = `background: linear-gradient(135deg, #0f314d, #166d98 46%, #00d8ff);`;
                    }

                    roleArea.innerHTML = `
                        <div class="${roleCardClass}" style="${bgStyle}">
                            <div class="role-name">${myRole}</div>
                            <div class="role-jp">${rInfo.jp}</div>
                            <div class="role-desc">${rInfo.summary}</div>
                            ${actBtnHtml}
                        </div>
                    `;
                }

                // --- 4. 演出・音・カットイン ---
                Object.keys(currentAct).forEach(pid => {
                    if (!prevActivatedList[pid] && currentAct[pid]) {
                        const rKey = roles[pid];
                        const rNameJP = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rKey]) ? ROLE_INFO[rKey].jp : rKey;
                        const pName = players[pid].name;
                        
                        if (typeof playCutInAnimation === 'function') playCutInAnimation(rKey, rNameJP, pName);
                        
                        const sndKey = 'SKILL_' + rKey;
                        if (typeof SOUND_FILES !== 'undefined' && SOUND_FILES[sndKey]) playSoundEffect(sndKey);
                        else playSoundEffect('SKILL');
                    }
                });
                
                Object.keys(currentRev).forEach(pid => {
                    if (!prevRevealedRoles[pid] && currentRev[pid]) {
                        const rKey = roles[pid];
                        if (rKey === "EMPEROR") {
                            const rNameJP = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rKey]) ? ROLE_INFO[rKey].jp : rKey;
                            const pName = players[pid].name;
                            if (typeof playCutInAnimation === 'function') playCutInAnimation(rKey, rNameJP, pName);
                            const sndKey = 'SKILL_' + rKey;
                            playSoundEffect(typeof SOUND_FILES !== 'undefined' && SOUND_FILES[sndKey] ? sndKey : 'SKILL');
                        }
                    }
                });

                prevActivatedList = deepCopy(currentAct);
                prevRevealedRoles = deepCopy(currentRev);

                // --- 5. BGM & 他プレイヤー表示 ---
                // ★修正: ゲーム終了時はロビーBGM（または停止）に切り替える
                if (data.status === "playing") {
                    playBgm('BGM_BATTLE');
                } else {
                    playBgm('BGM_LOBBY'); 
                    // ※もし無音が良ければ stopBgm(); にしてください
                }

                const areaTop = document.getElementById("area-top");
                const areaLeft = document.getElementById("area-left");
                const areaRight = document.getElementById("area-right");
                if(areaTop) areaTop.innerHTML = "";
                if(areaLeft) areaLeft.innerHTML = "";
                if(areaRight) areaRight.innerHTML = "";

                let pIds = getSortedPlayerIds(players); 
                if(data.playerOrder) pIds = data.playerOrder;
                
                // 自分エリアの演出処理
                const myAreaEl = document.getElementById("my-area");
                if (myAreaEl) {
                    let myHand = hands[myId] || [];
                    let myLocked = hackedHands[myId] || [];
                    let myCount = myHand.length + myLocked.length;
                    myAreaEl.classList.remove("current-turn", "warning-1", "warning-2");
                    if (pIds[data.turnIdx] === myId) {
                        myAreaEl.classList.add("current-turn");
                    }
                }

                // 配置計算
                let relativeOrder = [];
                let myIndex = pIds.indexOf(myId);
                if (myIndex !== -1) {
                    for (let i = 1; i < pIds.length; i++) {
                        let idx = (myIndex + i) % pIds.length;
                        relativeOrder.push(pIds[idx]);
                    }
                } else {
                    relativeOrder = pIds; // 観戦用
                }

                let layoutMap = [];
                let total = relativeOrder.length; 
                if (total === 2) { 
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaRight }];
                } else if (total === 3) {
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaTop }, { pid: relativeOrder[2], area: areaRight }];
                } else if (total === 4) {
                    layoutMap = [{ pid: relativeOrder[0], area: areaLeft }, { pid: relativeOrder[1], area: areaTop }, { pid: relativeOrder[2], area: areaTop }, { pid: relativeOrder[3], area: areaRight }];
                } else {
                    relativeOrder.forEach(pid => layoutMap.push({pid: pid, area: areaTop}));
                }

                // ■■■ 描画ループ (3段固定レイアウト版) ■■■
                layoutMap.forEach(item => {
                    let pid = item.pid;
                    let area = item.area;
                    if (!area) return;

                    // ▼▼▼ 追加: エリアに応じた吹き出し位置クラスを決定 ▼▼▼
                    let bubbleClass = "bubble-pos-top"; // デフォルト（上）
                    if (area.id === "area-left") bubbleClass = "bubble-pos-left";
                    else if (area.id === "area-right") bubbleClass = "bubble-pos-right";
                    // ▲▲▲ 追加ここまで ▲▲▲

                    let isTurn = (pIds[data.turnIdx] === pid);
                    let isRanked = (data.rankings && data.rankings[pid]);
                    let pHand = hands[pid] || [];
                    let lockedHand = hackedHands[pid] || []; 
                    let handCount = pHand.length + lockedHand.length;

                    // クラス設定
                    let boxClass = "p-box-new";
                    if (isTurn) boxClass += " current";
                    if (isRanked) boxClass += " passed";

                    // --- 1. 手札枚数の色スタイル ---
                    let countClass = "";
                    if (!isRanked) { 
                        if (handCount === 1) {
                            boxClass += " warning-1";
                            countClass = " count-danger";
                        } else if (handCount === 2) {
                            boxClass += " warning-2";
                            countClass = " count-warning";
                        }
                    } else {
                        // あがった人は枚数0でグレーアウト
                        countClass = " count-passed";
                    }

                    // --- 2. ステータス表示 (NORMAL / RESET / RANK) ---
                    let statusHtml = `<span class="status-text status-normal">NORMAL</span>`;
                    
                    if (isRanked) {
                        // 順位がついている場合
                        let rank = data.rankings[pid];
                        let suffix = ["st","nd","rd"][rank-1] || "th"; // 1st, 2nd...
                        statusHtml = `<span class="status-text status-rank">🏆 ${rank}${suffix}</span>`;
                    } else if (pid === effectiveResetHolder) {
                        // リセット権を持っている場合
                        statusHtml = `<span class="status-text status-reset">👑 RESET</span>`;
                    }
                    
                    // --- 3. 役職表示 (??? / ROLE NAME) ---
                    let isRevealed = currentAct[pid] || isRanked || currentRev[pid];
                    let roleHtml = `<span class="role-unknown">ROLE: ???</span>`; // デフォルト
                    
                    if (isRevealed) {
                        let rName = roles[pid];
                        let rJp = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[rName]) ? ROLE_INFO[rName].jp : rName;
                        
                        let roleSub = "";
                        if (rName === "CROWN" && typeof currentAct[pid] === 'string') {
                            roleSub = currentAct[pid];
                        } else if (rName === "POLITICIAN" && currentAct[pid]) {
                            roleSub = isPoliticianShieldActive(pid, data) ? "保護中" : "使用済み";
                        } else if (rName === "ASTRONOMER" && currentAct[pid]) {
                            roleSub = getAstronomerRoleSubText(data) || "使用済み";
                        } else if (rName === "EMPEROR" && currentAct[pid]) {
                            roleSub = "使用済み";
                        }

                        if (roleSub) {
                            roleHtml = `<div class="role-badge-pill">${rJp}: <span class="role-sub">${roleSub}</span></div>`;
                        } else {
                            roleHtml = `<div class="role-badge-pill">${rJp}</div>`;
                        }
                    }

                    // ヘッダーアイコン
                    let hostMark = (pid === effectiveHostId) ? "<span class='p-host-mark'>★</span>" : "";
                    
                    // --- 4. 公開カード情報のテキスト生成 (ここが変更点) ---
                    // 手札データ(hands)の中で isOpen フラグが立っているものを探す
                    let openFromHand = pHand.filter(c => c.isOpen);
                    
                    // サーバーから別途リストが送られてくる場合（念のため安全策）
                    let openFromServer = (data.revealedCards && data.revealedCards[pid]) ? data.revealedCards[pid] : [];
                    
                    // 両方をマージ
                    let allOpenCards = [...openFromHand, ...openFromServer];
                    let revealedTextHtml = "";

                    if (allOpenCards.length > 0) {
                        // 文字列リストを作成 (例: ["1", "REV"])
                        let textList = allOpenCards.map(c => {
                            let v = c.val; 
                            // 数字(0-9)があればそのまま返す
                            if (v !== undefined && v !== null && !isNaN(v)) {
                                return v;
                            }
                            
                            // 記号カードの略称変換
                            let name = String(v).toUpperCase();
                            if (name.includes('REVERSE')) return 'REV';
                            if (name.includes('TRADE'))   return 'TRD';
                            if (name.includes('DIG'))     return 'DIG';
                            if (name.includes('DISCARD')) return 'DIS';
                            
                            return "?"; 
                        });
                        
                        // ★修正: 重複を削除せず、ソートして見やすくしてから結合
                        // (Setを使わないことで、3が2枚なら "3, 3" と表示されるようになります)
                        textList.sort((a, b) => {
                            // 数字なら数字順、文字ならアルファベット順
                            if (!isNaN(a) && !isNaN(b)) return a - b;
                            return String(a).localeCompare(String(b));
                        });

                        let uniqueText = textList.join(', ');
                        revealedTextHtml = `公開: <span class="revealed-active">${uniqueText}</span>`;
                    } else {
                        // なし (グレー文字)
                        revealedTextHtml = `<span class="revealed-none">公開: NONE</span>`;
                    }
                    let pName = players[pid].name;


                    // ★ HTML組み立て ★
                    let html = `
                        <div class="${boxClass} with-bubble">
                            <div id="bubble-${pid}" class="chat-bubble ${bubbleClass}"></div>
                            <div class="p-header clickable" onclick="showPlayerLogs('${pid}')">${hostMark}${pName}</div>
                            <div class="p-body">
                                <div class="p-hand-count${countClass}">
                                    <span class="p-hand-icon">🃏×</span>${handCount}
                                </div>

                                <div class="p-status-area">
                                    ${statusHtml}
                                    <div class="p-revealed-info">
                                        ${revealedTextHtml}
                                    </div>
                                </div>
                            </div>

                            <div class="p-role-row">
                                ${roleHtml}
                            </div>
                        </div>
                    `;
                    
                    let wrapper = document.createElement("div");
                    wrapper.className = "p-box-wrap";
                    wrapper.innerHTML = html;
                    area.appendChild(wrapper);
                });

                // ▼▼▼ 追加: 3人対戦などで上エリアが空なら非表示にして詰める ▼▼▼
                if (areaTop.children.length === 0) {
                    areaTop.style.display = "none";
                } else {
                    areaTop.style.display = "flex";
                }
                // ▲▲▲ 追加ここまで ▲▲▲

                // --- 6. 場の情報更新 ---
                if (els.indicator) {
                    let targetSrc = data.isReverse ? "./images/reverse_red.jpg" : "./images/reverse_blue.jpg";
                    if (els.indicator.getAttribute('src') !== targetSrc) els.indicator.src = targetSrc;
                }
                updateAstronomerIndicator(data);
                if (els.graveNum) els.graveNum.innerHTML = renderPile(data.graveNum);
                if (els.graveSym) els.graveSym.innerHTML = renderPile(data.graveSym);
                if (document.getElementById("exclusion-count")) document.getElementById("exclusion-count").innerText = (data.exclusion || []).length;

                // メッセージ
                let isMyTurnNow = (pIds[data.turnIdx] === myId);
                if (data.status === "finished") {
                     els.msg.innerText = `ゲーム終了！`;
                     document.getElementById("btn-play").disabled = true;
                     document.getElementById("btn-pass").disabled = true;
                } else if (data.rankings && data.rankings[myId]) {
                    els.msg.innerText = `あなたは ${data.rankings[myId]}位 であがりました！`;
                    document.getElementById("btn-play").disabled = true;
                    document.getElementById("btn-pass").disabled = true;
                
                } else {
                    // ここでの activeCount, isInheritedReset は冒頭で計算したものを使用
                    let isOwnerReset = (resetHolder === myId);
                    let canReset = isOwnerReset || isInheritedReset;

                    if (isMyTurnNow) {
                        if (!wasMyTurn) playSoundEffect('turn');
                        if (data.turnIdx !== lastCleanupTurnIdx) {
                            lastCleanupTurnIdx = data.turnIdx;
                            if (typeof checkHackerCleanup === 'function') checkHackerCleanup();
                        }
                        els.msg.innerText = canReset ? "リセット可能（パスで発動）" : "あなたの番です";
                        document.getElementById("btn-play").disabled = false;
                        document.getElementById("btn-pass").disabled = false;
                    } else {
                        lastCleanupTurnIdx = -1;
                        let curP = players[pIds[data.turnIdx]];
                        els.msg.innerText = `${curP ? curP.name : '相手'} のターン`;
                        document.getElementById("btn-play").disabled = true;
                        document.getElementById("btn-pass").disabled = true;
                    }
                }
                wasMyTurn = isMyTurnNow;

            } else {
                // 待機中 (Lobby)
                els.msg.innerText = `待機中... ${Object.keys(players).length}人が参加`;
                playBgm('BGM_LOBBY');
                prevActivatedList = {};
                prevRevealedRoles = {};
                if(handContainer) handContainer.innerHTML = "";
                if(document.getElementById("my-role-panel")) document.getElementById("my-role-panel").innerHTML = "";
                updateAstronomerIndicator(null);
            }

            // 共通: ログ更新
            renderLogs(data.logs);

            // ホストコントロール (★変更点: effectiveHostIdを使用)
            // ↓↓↓ render関数内の「ホストコントロール」部分を書き換え ↓↓↓
            // ホストコントロール (★変更点: 新しいボタンを表示/非表示にする)
            const isHost = (effectiveHostId === myId);
            const btnHost = document.getElementById("btn-host-settings");
            
            if (isHost && btnHost) {
                btnHost.classList.remove("hidden");
            } else if (btnHost) {
                btnHost.classList.add("hidden");
            }

            // ↓↓↓ render関数内の「通知チェック」の上あたりに追加 ↓↓↓
            // --- 7. 自分の順位決定音 (敗者も含む) ---
            if (data.rankings && data.rankings[myId]) {
                if (!myRankPlayed) {
                    let rank = data.rankings[myId];
                    let total = data.playerOrder.length;
                    
                    if (rank === 1) playSoundEffect('RANK_1');     // 1位
                    else if (rank === total) playSoundEffect('RANK_4'); // ★最下位(敗者)
                    else playSoundEffect('RANK_2_3');              // それ以外
                    
                    myRankPlayed = true; // 再生済みにする
                }
            } else {
                // まだ順位がついていない（またはゲーム開始時）はリセット
                myRankPlayed = false;
            }

            // ↑↑↑ 書き換えここまで ↑↑↑
            // 通知チェック
            const myPlayer = players[myId] || {};
            if (myPlayer.notification) {
                playSoundEffect('WARNING');
                const note = myPlayer.notification;
                const getNotifDisplay = (val) => {
                    if (CARD_IMAGES[val]) return `<img src="${CARD_IMAGES[val]}" class="modal-image-center">`;
                    return `<div class="modal-notif-value">${val}</div>`;
                };
                let html = `
                    <div class="modal-notif-wrap">
                        <p class="modal-notif-title">${note.fromName} にトレードされました！</p>
                        <div class="modal-card-row">
                            <div class="modal-notif-card"><div class="modal-card-label">盗まれた</div>${getNotifDisplay(note.lostVal)}</div>
                            <div class="modal-notif-arrow">➡</div>
                            <div class="modal-notif-card"><div class="modal-card-label">渡された</div>${getNotifDisplay(note.gotVal)}</div>
                        </div>
                    </div>`;
                openModal("⚠️ トレード警告", html, { tone: "alert" });
                firebase.database().ref(`rooms/${currentRoom}/players/${myId}/notification`).remove();
            }

            // ↓↓↓ 追加: 自分の名前バーの更新 ↓↓↓
            // ■■■ 自分エリア（名前・役職・順位）の表示処理 ■■■
            const nameBar = document.getElementById("my-name-bar");
            if (nameBar && players[myId]) {

                // ▼▼▼ 追加: 自分用の吹き出しを nameBar の近くに追加 ▼▼▼
                // nameBar は position: relative がないので、親の my-area に依存させるか、
                // nameBar自体に relative をつける手もありますが、
                // ここでは nameBar の中に absolute で配置します。
                // nameBar に style="position:relative" を付与しておくと安全です
                let myPName = players[myId].name;
                
                // 1. 役職のHTML生成
                let myRoleHtml = "";
                if (roles[myId]) {
                    const rKey = roles[myId];
                    const rInfo = (typeof ROLE_INFO !== 'undefined') ? ROLE_INFO[rKey] : null;
                    const jpName = rInfo ? rInfo.jp : rKey;
                    
                    // スキル使用済みなら灰色、未使用なら紫
                    const isUsed = currentAct[myId];
                    const usedClass = isUsed ? " used" : "";
                    myRoleHtml = `<span class="my-role-chip${usedClass}">【役職】${jpName}</span>`;
                }

                // ★修正: resetHolder ではなく effectiveResetHolder を使用して判定
                let resetBadge = "";
                if (effectiveResetHolder === myId) {
                    // status-resetクラスをそのまま利用（位置調整のためstyleを追加）
                    resetBadge = `<span class="status-reset my-reset-badge">👑 RESET</span>`;
                }

                // 2. ホストなら★を表示
                let hostIcon = (effectiveHostId === myId) ? "<span class='my-host-icon'>★</span>" : "";

                // 3. 順位がついているなら表示
                let rankText = (data.rankings && data.rankings[myId]) ? `<span class="my-rank-badge">🏆${data.rankings[myId]}位</span>` : "";

                let bubbleHtml = `<div id="bubble-${myId}" class="chat-bubble bubble-pos-bottom"></div>`;
                
                // ★全部まとめてセット！ (先頭に bubbleHtml を追加)
                // ★変更: 自分の名前もクリックして履歴を見れるようにする
                nameBar.innerHTML = `${bubbleHtml}${hostIcon}<span onclick="showPlayerLogs('${myId}')" class="my-name-link">${myPName}</span>${myRoleHtml}${resetBadge}${rankText}`;
            }

            // 音再生
            const soundData = data.lastSound;
            if (soundData && soundData.id !== prevSoundId) {
                if (Array.isArray(soundData.type)) {
                    soundData.type.forEach(t => playSoundEffect(t));
                } else {
                    playSoundEffect(soundData.type);
                }
                prevSoundId = soundData.id;
            }
        }

        function getTotalHandCount(pid) {
            let h1 = (gameState.hands[pid] || []).length;
            let h2 = (gameState.hackedHands && gameState.hackedHands[pid]) ? gameState.hackedHands[pid].length : 0;
            return h1 + h2;
        }

        function viewGrave(type) {
            let list;
            let title;
            if (type === 'num') { list = gameState.graveNum; title = "数字墓地"; }
            else if (type === 'sym') { list = gameState.graveSym; title = "記号墓地"; }
            else if (type === 'excl') { list = gameState.exclusion; title = "除外場"; }

            if (!list || list.length === 0) return showInfoModal(title, "空です");
            
            let html = '<div class="modal-list">';
            list.slice().reverse().forEach(c => {
                html += renderCardView(c);
            });
            html += '</div>';
            openModal(title, html);
        }

        // --- Action Logic ---
        function passTurn() {
            if (!isMyTurn()) return;
            
            let activeCount = getActiveCount(gameState);
            let top = getTop(gameState.graveNum);
            let resetHolder = top ? top.owner : null;

            let isOwnerReset = (resetHolder === myId && (gameState.graveNum||[]).length > 0);

            // ★修正: 共通関数を使ってリセット権の継承判定を行う
            let isInheritedReset = checkInheritedResetLogic(gameState, myId);

            if (isOwnerReset || isInheritedReset) {
                const resetNotice = renderNoticeBlock("※リセット権を行使します（場が流れ、自分のターンが続きます）", "warn");
                openModal(
                    "パス (リセット権行使)",
                    `山札からドローしますか？<br><br>${resetNotice}<br><br>${renderModalButton("ドローする", "execPassDraw(true)", "primary")}${renderModalButton("しない", "execPassNoDraw(true)", "ghost")}`
                );
                return;
            }

            openModal(
                "パス",
                `山札からドローしますか？<br><br>${renderModalButton("ドローする", "execPassDraw(false)", "primary")}${renderModalButton("しない", "execPassNoDraw(false)", "ghost")}`
            );
        }

        async function execPassNoDraw(isReset) {
            closeModal();
            let updates = {};
            
            if(isReset) {
                let excl = [...(gameState.exclusion || []), ...(gameState.graveNum || [])];
                updates[`rooms/${currentRoom}/exclusion`] = excl;
                updates[`rooms/${currentRoom}/graveNum`] = [];
                updates[`rooms/${currentRoom}/passCount`] = 0;
                await pushLog(`${myName}がドローせずリセットしました`, 'public');
            } else {
                updates[`rooms/${currentRoom}/passCount`] = (gameState.passCount || 0) + 1;
                await pushLog(`${myName}がドローせずパスしました`, 'public');
                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            }
            
            await db.ref().update(updates);
        }

        // ↓↓↓ execPassDraw関数を丸ごとこれに置き換えてください ↓↓↓
        async function execPassDraw(isReset) {
            closeModal();
            let updates = {};
            let deck = [...(gameState.deckNum || [])];
            
            // 山札が空の場合の補充処理
            if (deck.length === 0) {
                let excl = [...(gameState.exclusion || [])];
                let newDeck = excl.filter(c => c.type === 'num');
                let remainingExcl = excl.filter(c => c.type !== 'num');

                if (newDeck.length > 0) {
                    shuffle(newDeck);
                    deck = newDeck;
                    updates[`rooms/${currentRoom}/exclusion`] = remainingExcl;
                    await pushLog("除外場から数字山札を補充しました", 'public');
                } else {
                    showInfoModal("通知", "山札も除外場もありません。ドローなしでパスします。");
                    execPassNoDraw(isReset);
                    return;
                }
            }
            
            // カードを引く
            let card = deck.pop();
            const top = getTop(gameState.graveNum);
            // リセット時でなければ、出せるかどうか判定する
            const playable = !isReset && (card.type === 'num' && canPlay(card, top, gameState.isReverse));
            
            drawnCardTemp = card;
            updates[`rooms/${currentRoom}/deckNum`] = deck;
            await db.ref().update(updates);

            if (playable) {
                // 出せる場合：選択肢を表示
                let imgUrl = CARD_IMAGES[card.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                let cardHtml = `<div class="card ${card.type}" style="display:inline-flex; ${imgStyle}">${card.val}</div>`;
                
                let html = `引いたカード: ${cardHtml}<br>これを出しますか？<br><br>
                            <button class='modal-btn primary' onclick='execPassPlay()'>出す</button>
                            <button class='modal-btn' onclick='execPassKeep()'>手札に入れる</button>`;
                
                openModal("ドロー結果", html);

                // ★修正: ここでフッター（閉じるボタン）を消去して、キャンセル不可にする
                if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }

            } else {
                // 出せない場合（またはリセット時）：自動的に手札へ
                let msg = isReset ? "(リセットのため手札に入れます)" : "(出せないので手札に入れます)";
                await pushLog(`[${card.val}] を引きました ${msg}`, 'private', myId);
                execPassKeep(isReset);
            }
        }

        async function execPassPlay() {
            closeModal();
            let card = drawnCardTemp;
            if(!card) return;
            
            let updates = {};
            let gn = [...(gameState.graveNum || [])];
            gn.push({ ...card, owner: myId });
            updates[`rooms/${currentRoom}/graveNum`] = gn;
            updates[`rooms/${currentRoom}/passCount`] = 0;
            
            await pushLog(`${myName}がパスドローから [${card.val}] を出しました`, 'public');
            
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await db.ref().update(updates);
            drawnCardTemp = null;
        }

        async function execPassKeep(isReset = false) {
            closeModal(); 
            let card = drawnCardTemp;
            if(!card) return;

            let updates = {};
            let hand = [...gameState.hands[myId]];
            hand.push(card);
            hand = sortCards(hand);
            updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            
            if(isReset) {
                let excl = [...(gameState.exclusion || []), ...(gameState.graveNum || [])];
                updates[`rooms/${currentRoom}/exclusion`] = excl;
                updates[`rooms/${currentRoom}/graveNum`] = [];
                updates[`rooms/${currentRoom}/passCount`] = 0;
                await pushLog(`${myName}がリセットして1枚引きました`, 'public');
            } else {
                updates[`rooms/${currentRoom}/passCount`] = (gameState.passCount || 0) + 1;
                if(gameState.lastLog !== `${myName}がドローせずパスしました`) {
                     await pushLog(`${myName}がパスして1枚引きました`, 'public');
                }
                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            }

            await db.ref().update(updates);
            drawnCardTemp = null;
        }

        async function playCard() {
            if (selectedIdx === -1) return;
            if (!isMyTurn()) return showInfoModal("エラー", "あなたの番ではありません");

            let currentHand = sortCards(deepCopy(gameState.hands[myId]));
            const card = currentHand[selectedIdx];
            
            if (card.type === 'num') {
                if (Number(card.val) === 0 && currentHand.length === 1) {
                    return showInfoModal("禁止あがり", "最後の一枚が「0」であがることはできません。");
                }

                const top = getTop(gameState.graveNum);
                
                if (!canPlay(card, top, gameState.isReverse)) {
                    return showInfoModal("エラー", "そのカードは出せません");
                }
                
                let updates = {};
                let newHand = [...currentHand];
                newHand.splice(selectedIdx, 1);
                updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;

                // ★残り枚数を計算して、鳴らす音を決定する
                // ★音のセットを作成（基本はPUT）
                let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
                let nextTotal = newHand.length + myHackedCount;
                
                let soundList = ['PUT']; 
                if (nextTotal === 1) soundList.push('UNO');
                else if (nextTotal === 2) soundList.push('DOS');

                // セットで送信
                updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

                let newGraveNum = [...(gameState.graveNum || [])];
                
        
                
                let playCardData = { ...card, owner: myId };
                newGraveNum.push(playCardData);

                updates[`rooms/${currentRoom}/graveNum`] = newGraveNum;
                updates[`rooms/${currentRoom}/passCount`] = 0;
                
                await pushLog(`${myName}が [${card.val}] を出しました`, 'public');

                /* --- playCard 関数内の修正 (推奨版) --- */

                // 手札(newHand)が0枚、かつ、隔離エリア(hackedHands)も0枚ならあがり
                // ★ここを書き換え
                if (newHand.length === 0 && myHackedCount === 0) {
                    let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                    // ... (以下、あがり処理はそのまま)
                    updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                    await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');

                    // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
                    updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
                    updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
                    // ▲▲▲ 追加ここまで ▲▲▲

                    let totalPlayers = gameState.playerOrder.length;

                    if (currentRank >= totalPlayers - 1) {
                         updates[`rooms/${currentRoom}/status`] = "finished";

                        // 敗者（最後の一人）を特定
                        let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！！最下位 ${lName} の残り手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！！`, 'public');
                        }

                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                    }
                }
                
                let tempRankings = {...(gameState.rankings || {})};
                if(newHand.length === 0) tempRankings[myId] = 99;

                let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
                updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

                await db.ref().update(updates);
                selectedIdx = -1;

            } else { handleSymbol(card, selectedIdx, currentHand); }
        }

        async function handleSymbol(card, idx, currentHand) {
            // ▼▼▼ 修正箇所: ロック中のカードも考慮して「あがり」かどうか判定する ▼▼▼
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            
            if (currentHand.length === 1 && myHackedCount === 0) return showInfoModal("禁止あがり", "記号であがることはできません。");
            
            
            if (card.val === "DIG UP") {
                const hasNum = currentHand.some((c, i) => i !== idx && c.type === 'num');
                if (!hasNum) return showInfoModal("使用不可", "手札に数字カードがないため、DIG UPは使用できません。");
                let gn = gameState.graveNum || [];
                if (gn.length === 0) return showInfoModal("使用不可", "数字墓地がないため使用できません");
                
                let top = gn[gn.length-1];
                let imgUrl = CARD_IMAGES[top.val];
                let imgStyle = imgUrl ? `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;` : '';
                let topCardHtml = `<div class="card ${top.type}" style="${imgStyle} display:inline-flex;">${top.val}</div>`;

                let html = `<p>墓地の ${topCardHtml} を手札に入れます。<br>代わりに場に埋めるカード(手札)を選んでください。</p><div class="modal-list">`;
                currentHand.forEach((c, i) => {
                    if (i === idx) return; 
                    if (c.type !== 'num') return; 
                    let style = '';
                    let cImg = CARD_IMAGES[c.val];
                    if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                    html += `<div class="card ${c.type}" style="${style}" onclick="execDigUp(${idx}, ${i})">${c.val}</div>`;
                });
                html += `</div>`;
                openModal("DIG UP: 交換", html);
                return;
            }
            if (card.val === "TRADE") {
                let pIds = gameState.playerOrder;
                let html = `<p>トレード相手を選んでください。</p>`;
                let canUseTarget = false;
                const activePids = pIds.filter(pid => !(gameState.rankings && gameState.rankings[pid]));
                const onlyOtherPid = (activePids.length === 2) ? activePids.find(pid => pid !== myId) : null;
                const canWhiffTrade = !!(onlyOtherPid && isPoliticianShieldActive(onlyOtherPid));
                pIds.forEach(pid => {
                    if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
                    let p = gameState.players[pid];
                    let count = gameState.hands[pid] ? gameState.hands[pid].length : 0;
                    if (count > 0) {
                        if (isPoliticianShieldActive(pid)) {
                            html += `<button class="modal-btn is-disabled" disabled>${p.name} (政治家で対象外)</button>`;
                        } else {
                            canUseTarget = true;
                            html += `<button class="modal-btn" onclick="tradeStep2('${pid}', ${idx})">${p.name} (手札${count})</button>`;
                        }
                    }
                });
                if (!canUseTarget) {
                    html += `<p class="modal-note">対象にできるプレイヤーがいません。</p>`;
                    if (canWhiffTrade) {
                        const otherName = (gameState.players && gameState.players[onlyOtherPid]) ? gameState.players[onlyOtherPid].name : "相手";
                        html += `
                            <div class="seki-section warn">
                                <p class="modal-note warn warn-block">
                                    2人終盤かつ ${otherName} が[政治家]保護中のため、TRADEを空振り消費できます。
                                </p>
                                <button class="modal-btn primary" onclick="execTradeWhiff(${idx}, '${onlyOtherPid}')">空振りでTRADEを使用する</button>
                            </div>
                        `;
                    }
                }
                openModal("TRADE: 相手選択", html);
                return;
            }
            if (card.val === "DISCARD") {
                let newHand = [...currentHand];
                // 使用したDISCARDカード以外をリスト化
                let discardable = newHand.filter((_, i) => i !== idx);
                
                // ★追加: 捨てられる数字カードがあるかチェック
                let hasNum = discardable.some(c => c.type === 'num');
                if (!hasNum) return showInfoModal("エラー", "捨てることのできる数字カードがありません");

                let html = `<p>捨てるカードを選んでください<br><span style="font-size:12px; color:#ef5350;">※数字カードのみ選択可能です</span></p><div class="modal-list">`;
                discardable.forEach((c, i) => {
                    let style = '';
                    let onClick = '';
                    let cImg = CARD_IMAGES[c.val];

                    // ★変更: 数字カードなら選択可能、記号カードなら選択不可
                    if (c.type === 'num') {
                        // 選択可能
                        style = 'cursor:pointer; transition:transform 0.1s; ';
                        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                        onClick = `onclick="execDiscard(${idx}, ${i})"`;
                    } else {
                        // 選択不可 (グレーアウト)
                        style = 'opacity:0.3; cursor:not-allowed; border:1px dashed #777; background:rgba(0,0,0,0.2); transform:scale(0.95);';
                        if(cImg) {
                            style += `background-image:url('${cImg}'); background-size:cover; background-position:center; color:transparent;`;
                        }
                    }

                    html += `<div class="card ${c.type}" style="${style}" ${onClick}>${c.val}</div>`;
                });
                html += `</div>`;
                openModal("DISCARD: 手札破棄", html);
                return;
            }

            // ↓↓↓ handleSymbol関数内の lastSound 送信部分をこれに書き換え ↓↓↓
            // ---------------------------------------------------------
            // ★修正: REVERSEなどの即時発動カード処理
            // ---------------------------------------------------------
            // 1. まず手札から出したカードを取り除く (ここで newHand を定義！)
            let updates = {};
            let newHand = [...currentHand];
            newHand.splice(idx, 1);

            // 2. 残り枚数を計算して、音のセットを作成
            let nextTotal = newHand.length + myHackedCount;

            let soundList = [card.val]; // 例: ['REVERSE']
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            // 3. データを更新
            updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;
            let newGraveSym = [...(gameState.graveSym || [])];
            newGraveSym.push(card);
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            await clearPoliticianShieldIfNeeded(myId, updates, `${card.val}使用`);

            let logMsg = `${myName}が [${card.val}] を使用して`;
            if (card.val === "REVERSE") {
                updates[`rooms/${currentRoom}/isReverse`] = !gameState.isReverse;
                logMsg += "強弱を逆転させました";
            }

            await pushLog(logMsg, 'public');

            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await db.ref().update(updates);
            selectedIdx = -1;
        }

        // ↓↓↓ execDigUp関数を丸ごとこれに置き換えてください ↓↓↓
        async function execDigUp(digUpIdx, returnIdx) {
            closeModal();
            let updates = {};
            let newHand = sortCards(deepCopy(gameState.hands[myId]));
            let gn = [...gameState.graveNum];
            
            // 処理
            let top = gn.pop(); 
            let usedDigUp = newHand.splice(digUpIdx, 1)[0]; 
            let newGraveSym = [...(gameState.graveSym || []), usedDigUp];
            
            // インデックス調整
            let actualReturnIdx = (returnIdx > digUpIdx) ? returnIdx - 1 : returnIdx;
            let retCard = newHand.splice(actualReturnIdx, 1)[0];
            newHand.push(top);
            
            gn.push({ ...retCard, owner: myId }); 
            newHand = sortCards(newHand);
            
            updates[`rooms/${currentRoom}/hands/${myId}`] = newHand;
            
            // ★修正: UNO/DOS音の追加
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = newHand.length + myHackedCount;

            let soundList = ['DIG UP'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            updates[`rooms/${currentRoom}/graveNum`] = gn;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            await clearPoliticianShieldIfNeeded(myId, updates, "DIG UP使用");
            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await pushLog(`${myName}が [DIG UP] を使用して [${top.val}] を回収し、[${retCard.val}] を埋めました。`, 'public');
            
            await db.ref().update(updates);
            selectedIdx = -1;
        }

        /* --- 通常のTRADE改修 (狙い撃ち対応) --- */

        // 元の tradeStep2 を「奪うカード選択」に上書き
        // (handleSymbol からはこれが呼ばれます)
        /* --- 修正版: tradeStep2 (フォントバレ防止) --- */
        function tradeStep2(targetId, tradeCardIdx) {
            if (!canTargetByHandInterference(targetId)) return;
            let targetHand = deepCopy(gameState.hands[targetId] || []);
            
            // 元のインデックスを記録してシャッフル
            targetHand.forEach((c, i) => c.originalIndex = i);
            shuffle(targetHand);

            let html = `<p>相手の手札から<strong>欲しいカード</strong>を選んでください。<br>
                        <span style="font-size:11px;">(通常は裏向きですが、公開カードは見えます)</span></p>
                        <div class="modal-list">`;

            targetHand.forEach(c => {
                let content = "?";
                let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
                let cssClass = "card"; // ★修正: 初期値はただのcard

                // 公開カードなら中身を表示
                // ★ハッキングチェック
                if (c.isHacked) {
                    cssClass += " hacked";
                    style = "cursor:not-allowed; border:1px solid #555; background:#333;";
                    content = "🔒"; // 裏向きでもロックされていることはわかる
                    onClick = ""; // クリック無効
                }
                // 公開カードチェック (ハックされてたらロック優先)
                else if (c.isOpen) {
                    cssClass = `card ${c.type}`;
                    content = c.val;
                    style = "cursor:pointer; ";
                    let cImg = CARD_IMAGES[c.val];
                    if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                }

                html += `<div class="${cssClass}" style="${style}" 
                        onclick="tradeStep3('${targetId}', ${tradeCardIdx}, ${c.originalIndex})">
                        ${content}
                        </div>`;
            });
            
            html += `</div>`;
            openModal("TRADE: 略奪選択", html);
        }

        // 新設: 自分の渡すカードを選ぶ (旧 tradeStep2 の中身)
        function tradeStep3(targetId, tradeCardIdx, takeIdx) {
            let myHand = sortCards(deepCopy(gameState.hands[myId]));
            let html = `<p>相手に渡すカードを選んでください。</p><div class="modal-list">`;
            
            myHand.forEach((c, i) => {
                if (i === tradeCardIdx) return; // コストとして払うTRADEカードは選べない
                
                let style = "";
                let cImg = CARD_IMAGES[c.val];
                if (cImg) {
                    style = `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
                }

                // 実行 (execTrade に takeIdx を渡す)
                html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                        onclick="execTrade('${targetId}', ${tradeCardIdx}, ${i}, ${takeIdx})">${c.val}</div>`;
            });
            
            html += `</div>`;
            openModal("TRADE: 譲渡選択", html);
        }

        // 2人終盤かつ相手が政治家保護中のときだけ使えるTRADE空振り消費
        async function execTradeWhiff(tradeCardIdx, blockedPid) {
            closeModal();
            let updates = {};
            let myHand = sortCards(deepCopy(gameState.hands[myId] || []));

            if (tradeCardIdx < 0 || tradeCardIdx >= myHand.length) {
                return showInfoModal("エラー", "TRADEカードの位置が不正です。");
            }
            if (myHand[tradeCardIdx].val !== "TRADE") {
                return showInfoModal("エラー", "TRADEカードが見つかりません。");
            }

            const activePids = (gameState.playerOrder || []).filter(pid => !(gameState.rankings && gameState.rankings[pid]));
            const onlyOtherPid = (activePids.length === 2) ? activePids.find(pid => pid !== myId) : null;
            if (!(onlyOtherPid && onlyOtherPid === blockedPid && isPoliticianShieldActive(onlyOtherPid))) {
                return showInfoModal("使用不可", "この空振り消費は、プレイヤーが2人で相手が政治家保護中のときのみ使用できます。");
            }

            let usedTrade = myHand.splice(tradeCardIdx, 1)[0];
            let newGraveSym = [...(gameState.graveSym || []), usedTrade];

            updates[`rooms/${currentRoom}/hands/${myId}`] = myHand;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            await clearPoliticianShieldIfNeeded(myId, updates, "TRADE空振り使用");

            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = myHand.length + myHackedCount;
            let soundList = ['TRADE'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');
            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            const blockedName = (gameState.players && gameState.players[blockedPid]) ? gameState.players[blockedPid].name : "相手";
            await pushLog(`${myName}が [TRADE] を使用しましたが、${blockedName} は[政治家]保護中のため空振りになりました。`, 'public');

            await db.ref().update(updates);
            selectedIdx = -1;
        }

        // 実行処理 (引数 takeIdx を追加)
        // ↓↓↓ execTrade関数を丸ごとこれに置き換えてください ↓↓↓
        async function execTrade(targetId, tradeCardIdx, giveCardIdx, takeIdx) {
            closeModal();
            if (!canTargetByHandInterference(targetId)) return;
            let updates = {};
            let myHand = sortCards(deepCopy(gameState.hands[myId]));
            let targetHand = sortCards(deepCopy(gameState.hands[targetId]));
            
            // コスト支払い
            let usedTrade = myHand.splice(tradeCardIdx, 1)[0];
            let newGraveSym = [...(gameState.graveSym || []), usedTrade];
            
            // インデックス調整
            let actualGiveIdx = (giveCardIdx > tradeCardIdx) ? giveCardIdx - 1 : giveCardIdx;
            
            // 交換実行
            let giveCard = myHand.splice(actualGiveIdx, 1)[0];
            let receiveCard = targetHand.splice(takeIdx, 1)[0];
            
            myHand.push(receiveCard);
            targetHand.push(giveCard);
            myHand = sortCards(myHand);
            targetHand = sortCards(targetHand);
            
            updates[`rooms/${currentRoom}/hands/${myId}`] = myHand;
            updates[`rooms/${currentRoom}/hands/${targetId}`] = targetHand;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            await clearPoliticianShieldIfNeeded(myId, updates, "TRADE使用");
            
            await pushLog(`${myName}が [TRADE] を使用して${gameState.players[targetId].name} とカードを交換しました`, 'public');
            await pushLog(`${gameState.players[targetId].name}から [${receiveCard.val}] を奪い、[${giveCard.val}] を渡しました。`, 'private', myId);
            await pushLog(`${gameState.players[myId].name}に [${receiveCard.val}] を奪われ、 [${giveCard.val}] を渡されました。`, 'private', targetId);

            updates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
                fromName: myName + "(TRADE)",
                lostVal: receiveCard.val,
                gotVal: giveCard.val
            };

            // ★修正: UNO/DOS音の追加
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = myHand.length + myHackedCount;

            let soundList = ['TRADE'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };
            
            await db.ref().update(updates);
            selectedIdx = -1;
        }

        // ↓↓↓ execDiscard関数を丸ごとこれに置き換えてください ↓↓↓

        async function execDiscard(useCardIdx, targetIdx) {
            closeModal();
            let updates = {};
            let currentHand = sortCards(deepCopy(gameState.hands[myId]));

            // 1. コストとして使う「DISCARD」カード自体
            let usedCard = currentHand.splice(useCardIdx, 1)[0];
            let newGraveSym = [...(gameState.graveSym || []), usedCard];

            // 2. 捨てられるカード
            // (UIの仕組み上、splice後のインデックスが渡ってくるのでそのまま使えます)
            let discardCard = currentHand.splice(targetIdx, 1)[0];

            // ★ここが修正ポイント：種類によって送り先を変える
            let newGraveNum = [...(gameState.graveNum || [])];

            if (discardCard.type === 'num') {
                // 数字なら「数字墓地」へ（これで場のトップが更新され、バグが直る！）
                // ownerを自分にすることで、責任の所在を明確にする
                newGraveNum.push({ ...discardCard, owner: myId });
            } else {
                // 記号なら「記号墓地」へ
                newGraveSym.push(discardCard);
            }
            currentHand = sortCards(currentHand);
            
            // 音のセットを作成
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = currentHand.length + myHackedCount;

            let soundList = ['DISCARD'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };
            
            // 墓地情報を更新（除外場 exclusion への追加は削除）
            updates[`rooms/${currentRoom}/graveNum`] = newGraveNum;
            updates[`rooms/${currentRoom}/graveSym`] = newGraveSym;
            updates[`rooms/${currentRoom}/hands/${myId}`] = currentHand;
            await clearPoliticianShieldIfNeeded(myId, updates, "DISCARD使用");
        
            await pushLog(`${myName}が [DISCARD] で [${discardCard.val}] を捨てました！！`, 'public');

            updates[`rooms/${currentRoom}/passCount`] = 0;

            // あがり判定
            if (currentHand.length === 0 && myHackedCount === 0) {
                let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');

                // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
                updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
                updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
                // ▲▲▲ 追加ここまで ▲▲▲

                let totalPlayers = gameState.playerOrder.length;
                if (currentRank >= totalPlayers - 1) {
                         updates[`rooms/${currentRoom}/status`] = "finished";

                        // 敗者（最後の一人）を特定
                        let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！　最下位 ${lName} の残り手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！`, 'public');
                        }
                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                }
            }

            let tempRankings = {...(gameState.rankings || {})};
            if(currentHand.length === 0) tempRankings[myId] = 99;

            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await db.ref().update(updates);
            selectedIdx = -1;
        }

        function isMyTurn() {
            if (!gameState || !gameState.playerOrder) return false;
            return gameState.playerOrder[gameState.turnIdx] === myId;
        }
        function getTop(arr) { return (arr && arr.length > 0) ? arr[arr.length-1] : null; }
        function getAstronomerObservation(data = gameState) {
            if (!data || !data.astronomerObservation) return null;
            const rawVal = Number(data.astronomerObservation.value);
            if (!ASTRONOMER_CHOICES.includes(rawVal)) return null;
            return {
                value: rawVal,
                activatedIsReverse: !!data.astronomerObservation.activatedIsReverse,
                activatedBy: data.astronomerObservation.activatedBy || null
            };
        }
        function getAstronomerState(data = gameState) {
            const obs = getAstronomerObservation(data);
            if (!obs) return null;
            const isNowReverse = !!(data && data.isReverse);
            const isStrongest = (isNowReverse === obs.activatedIsReverse);
            return {
                ...obs,
                isStrongest
            };
        }
        function getAstronomerRoleSubText(data = gameState) {
            const state = getAstronomerState(data);
            if (!state) return "";
            return state.isStrongest
                ? `観測 ${state.value}`
                : `観測 ${state.value}`;
        }
        function getNumberStrengthOrder(isRev, data = gameState) {
            const baseOrder = isRev
                ? [1, 2, 3, 4, 5, 6, 7, 8, 9]
                : [9, 8, 7, 6, 5, 4, 3, 2, 1];
            const astro = getAstronomerState(data);
            if (!astro) return baseOrder;

            const rest = baseOrder.filter(v => v !== astro.value);
            return astro.isStrongest
                ? [astro.value, ...rest]
                : [...rest, astro.value];
        }
        function compareNumberStrength(a, b, isRev, data = gameState) {
            const valA = Number(a);
            const valB = Number(b);
            if (valA === valB) return 0;

            const order = getNumberStrengthOrder(!!isRev, data);
            const idxA = order.indexOf(valA);
            const idxB = order.indexOf(valB);
            if (idxA === -1 || idxB === -1) return 0;
            return idxA < idxB ? 1 : -1;
        }
        function canPlay(card, topCard, isRev, data = gameState) {
            if (!topCard) return true;
            if (Number(card.val) === 0 || Number(topCard.val) === 0) return true;
            return compareNumberStrength(card.val, topCard.val, isRev, data) > 0;
        }
        function updateAstronomerIndicator(data = gameState) {
            const panel = document.getElementById("astronomer-indicator");
            const valEl = document.getElementById("astronomer-indicator-value");
            const stateEl = document.getElementById("astronomer-indicator-state");
            if (!panel || !valEl || !stateEl) return;

            const state = getAstronomerState(data);
            if (!state) {
                panel.style.display = "none";
                return;
            }

            panel.style.display = "flex";
            panel.classList.remove("state-strongest", "state-weakest");
            panel.classList.add(state.isStrongest ? "state-strongest" : "state-weakest");
            valEl.innerText = state.value;
            stateEl.innerText = state.isStrongest ? "最強" : "最弱";
        }
        function shuffle(arr) { for(let i=arr.length-1; i>0; i--){ let j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
        function renderPile(arr) {
            if (!arr || arr.length === 0) return "";
            let c = arr[arr.length-1];
            return renderCardView(c);
        }

        function getActiveCount(data) {
            if(!data || !data.playerOrder) return 0;
            let finishedCount = Object.keys(data.rankings || {}).length;
            return Math.max(1, data.playerOrder.length - finishedCount);
        }

        function getNextActivePlayerIndex(currentIdx, playerOrder, rankings) {
            let next = (currentIdx + 1) % playerOrder.length;
            let loop = 0;
            while (rankings && rankings[playerOrder[next]] && loop < playerOrder.length) {
                next = (next + 1) % playerOrder.length;
                loop++;
            }
            return next;
        }
	// 追加: リセット処理の実体
        async function execPassReset() {
            // 既存の「ドローなしでリセット」する処理へ委譲します
            return execPassNoDraw(true);
        }
/* --- ANGLER (釣り人) の実装 --- */

// ステップ1: 手札から除外するカードを選ぶ
function activateAngler() {
    let hand = gameState.hands[myId] || [];
    if(hand.length === 0) return showInfoModal("エラー", "手札がないため発動できません");
    
    // 墓地が空っぽか確認（拾うものがないと損するだけなので警告、でもルール上は発動できそうだが一応チェック）
    let gn = gameState.graveNum || [];
    let gs = gameState.graveSym || [];
    if(gn.length === 0 && gs.length === 0) return showInfoModal("エラー", "墓地にカードがないため釣れません");

    let html = `<p>エサとして除外する手札を選んでください。</p><div class="modal-list">`;
    hand.forEach((c, i) => {
        // カード表示用の共通処理（画像など）
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // クリックでステップ2へ
        html += `<div class="card ${c.type}" style="${style}" onclick="anglerStep2(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("釣り人: エサ選択", html);
}

// ステップ2: 墓地から拾うカードを選ぶ
function anglerStep2(excludeIdx) {
    let gn = gameState.graveNum || [];
    let gs = gameState.graveSym || [];
    
    let html = `<p>墓地から釣り上げるカードを選んでください。</p><div class="modal-list" style="justify-content:flex-start;">`;
    
    // 数字墓地
    gn.forEach((c, i) => {
        let style = '';
        html += `<div class="card num" style="${style}" onclick="execAngler(${excludeIdx}, 'num', ${i})">${c.val}<span style="font-size:8px; display:block;"></span></div>`;
    });
    // 記号墓地
    gs.forEach((c, i) => {
        let cImg = CARD_IMAGES[c.val];
        let style = cImg ? `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;` : '';
        html += `<div class="card sym" style="${style}" onclick="execAngler(${excludeIdx}, 'sym', ${i})">${c.val}</div>`;
    });
    
    html += `</div>`;
    openModal("釣り人: 釣魚選択", html);
}

// ステップ3: 実行
async function execAngler(excludeIdx, targetType, targetGraveIdx) {
    closeModal();
    let updates = {};
    
    // データのコピー
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let gn = [...(gameState.graveNum || [])];
    let gs = [...(gameState.graveSym || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 1. 手札を除外
    let excludedCard = hand.splice(excludeIdx, 1)[0];
    excl.push(excludedCard);

    // 2. 墓地から回収
    let pickedCard;
    if (targetType === 'num') {
        pickedCard = gn.splice(targetGraveIdx, 1)[0];
    } else {
        pickedCard = gs.splice(targetGraveIdx, 1)[0];
    }
    hand.push(pickedCard);
    hand = sortCards(hand); // 手札整理

    // 3. データ更新準備
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    updates[`rooms/${currentRoom}/graveNum`] = gn;
    updates[`rooms/${currentRoom}/graveSym`] = gs;
    
    // 使用済みフラグON
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ログ
    await pushLog(`${myName}が[釣り人]を発動！手札を除外して墓地の [${pickedCard.val}] を釣り上げました`, 'public');
    //playSoundEffect('SKILL'); 

    // 4. ターン終了処理
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- FORTUNE TELLER (占い師) の実装 --- */
// 修正版: ログに詳細を残す機能を追加

async function activateFortuneTeller() {
    // 1. 他のプレイヤーの情報を収集
    let html = `<div style="text-align:left;">`;
    let logText = ``; // ★ログ保存用のテキスト
    
    const pIds = gameState.playerOrder;
    
    pIds.forEach(pid => {
        if (pid === myId) return; // 自分はスキップ

        const pName = gameState.players[pid].name;
        if (isPoliticianShieldActive(pid)) {
            html += `
                <div style="margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
                    <div style="font-weight:bold; color:#fdd835;">${pName}</div>
                    <div style="font-size:12px; color:#d32f2f;">[政治家]発動中のため確認できません</div>
                </div>
            `;
            logText += `[${pName}] [政治家]発動中のため確認不可<br>`;
            return;
        }

        const pRole = gameState.roles[pid];
        const pRoleJP = (ROLE_INFO[pRole]) ? ROLE_INFO[pRole].jp : pRole;
        const pHand = gameState.hands[pid] || [];

        // 手札の内容（表示用HTML）
        let handHtml = pHand.map(c => {
             // 画像があるかチェック
             let imgUrl = CARD_IMAGES[c.val];
             
             // 共通のスタイル（小さめのカードにする）
             let baseStyle = "display:inline-block; width:30px; height:45px; border-radius:4px; margin:2px; vertical-align:middle; line-height:45px; text-align:center; font-weight:bold; border:1px solid #ccc; background:#fafafa; color:#333; position:relative;";
             
             // 画像がある場合（記号など）：背景画像にして文字を消す
             if (imgUrl) {
                 return `<span class="card ${c.type}" style="${baseStyle} background-image:url('${imgUrl}'); background-size:cover; color:transparent; border:none;">${c.val}</span>`;
             }
             
             // 画像がない場合（数字など）：数字を表示
             // 数字の「0」だけは紫色にする
             
             // 普通の数字
             return `<span class="card ${c.type}" style="${baseStyle}">${c.val}</span>`;
        }).join("");

        // 手札の内容（ログ保存用の簡易テキスト）
        let handText = pHand.map(c => c.val).join(", ");

        // モーダル用HTML作成
        html += `
            <div style="margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
                <div style="font-weight:bold; color:#fdd835;">${pName}</div>
                <div style="font-size:12px;">役職: <span style="color:#080000;">${pRoleJP}</span></div>
                <div style="font-size:12px;">手札: ${handHtml}</div>
            </div>
        `;

        // ★ログ用テキスト作成（改行を入れて見やすく）
        logText += `[${pName}] 役職:${pRoleJP} / 手札:${handText}<br>`;
    });

    html += `</div><p style="font-size:12px; color:#aaa;">※この内容はログ(チャット履歴)にも保存されました。</p>`;

    // 2. サーバー更新
    let updates = {};
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true; // 使用済みにする
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    
    // 全員への通知（中身は言わない）
    await pushLog(`${myName}が[占い師]を発動！水晶玉を覗き込みました...`, 'public');
    
    // ★自分だけのメモとして詳細を保存（ここがポイント！）
    // type='private', targetId=myId にすることで自分にしか見えません
    await pushLog(`【占い結果メモ】<br>${logText}`, 'private', myId);
    
    //playSoundEffect('SKILL'); 
    
    // データベース更新
    await db.ref().update(updates);

    // 3. モーダルで情報を表示
    openModal("占い師: 千里眼", html);
}

/* --- ASTRONOMER (天文学者) の実装 --- */
function activateAstronomer() {
    if (!isMyTurn()) return showInfoModal("エラー", "あなたの番ではありません");
    if (!gameState || !gameState.roles || gameState.roles[myId] !== "ASTRONOMER") {
        return showInfoModal("エラー", "天文学者ではないため発動できません。");
    }

    let actList = {...(gameState.activatedList || {})};
    if (actList[myId]) return showInfoModal("使用不可", "天文学者はすでに発動済みです。");

    const isRev = !!gameState.isReverse;
    const strongerThan = isRev ? 1 : 9;

    let html = `
        <p>観測する数字を選んでください。<br>
        <span style="font-size:12px; color:#ff0000;">
            現在は${isRev ? "逆行" : "順行"}なので、[${strongerThan}]より強い数字を指定します。
        </span>
        </p>
        <div class="modal-list">`;

    for (let n = 1; n <= 9; n++) {
        const isSelectable = ASTRONOMER_CHOICES.includes(n);
        let style = "";
        if (!isSelectable) {
            style = "opacity:0.35; cursor:not-allowed; border:1px dashed #888; transform:scale(0.95);";
        }
        const onClick = isSelectable
            ? `onclick="execAstronomerObserve(${n})"`
            : `onclick="showAstronomerInvalidSelection(${n})"`;
        html += `<div class="card num" style="${style}" ${onClick}>${n}</div>`;
    }

    html += `</div>
        <p style="font-size:11px; color:#ff0000; margin-top:8px;">
            ※ 2〜8のみ選択可能です（1と9は対象外）。
        </p>`;

    openModal("天文学者: 観測", html);
}

function showAstronomerInvalidSelection(val) {
    showInfoModal("対象外", `[${val}] は観測対象外です。2〜8から選んでください。`);
}

async function execAstronomerObserve(observedVal) {
    if (!isMyTurn()) return showInfoModal("エラー", "あなたの番ではありません");
    if (!gameState || !gameState.roles || gameState.roles[myId] !== "ASTRONOMER") {
        return showInfoModal("エラー", "天文学者ではないため発動できません。");
    }

    const val = Number(observedVal);
    if (!ASTRONOMER_CHOICES.includes(val)) {
        return showInfoModal("対象外", "2〜8から選んでください。");
    }

    let actList = {...(gameState.activatedList || {})};
    if (actList[myId]) return showInfoModal("使用不可", "天文学者はすでに発動済みです。");

    closeModal();

    let updates = {};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/astronomerObservation`] = {
        value: val,
        activatedIsReverse: !!gameState.isReverse,
        activatedBy: myId,
        timestamp: Date.now()
    };

    const strongerThan = gameState.isReverse ? 1 : 9;
    await pushLog(`${myName}が[天文学者]を発動し、[${val}] を観測して [${strongerThan}] より強くしました。`, 'public');
    await db.ref().update(updates);
}


/* --- POLITICIAN (政治家) --- */
async function activatePolitician() {
    if (!isMyTurn()) return;

    let actList = {...(gameState.activatedList || {})};
    if (actList[myId]) return showInfoModal("使用不可", "政治家はすでに発動済みです。");

    let shieldMap = {...(gameState.politicianShield || {})};
    shieldMap[myId] = true;

    let updates = {};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/politicianShield`] = shieldMap;

    await pushLog(`${myName}が[政治家]を発動し、手札干渉の対象外になりました。`, 'public');
    await db.ref().update(updates);
}

function activateThief(count = 1) {
    let html = `<p><strong>【盗賊スキル ${count}/2回目】</strong><br>トレードする相手を選んでください。</p>`;
    let canUseTarget = false;
    
    const pIds = gameState.playerOrder;
    pIds.forEach(pid => {
        if (pid === myId) return; 
        if (gameState.rankings && gameState.rankings[pid]) return; 

        const pName = gameState.players[pid].name;
        // 公開情報の表示（警察官などでバレている場合）
        const hand = gameState.hands[pid] || [];
        const handLen = hand.length;
        if (handLen === 0) return;
        let revealed = hand.filter(c => c.isOpen).map(c => c.val).join(", ");
        let revealedInfo = revealed ? `<br><span style="font-size:11px; color:#000000;">(公開: ${revealed})</span>` : "";

        if (isPoliticianShieldActive(pid)) {
            html += `<button disabled style="display:block; width:100%; margin:5px 0; padding:10px; background:#9e9e9e; color:#fff; opacity:0.7; border:none; border-radius:6px; cursor:not-allowed;">
                ${pName} (政治家で対象外)
            </button>`;
        } else {
            canUseTarget = true;
            html += `<button onclick="thiefSelectTake('${pid}', ${count})" style="display:block; width:100%; margin:5px 0; padding:10px;">
                ${pName} (手札${handLen}枚)${revealedInfo}
            </button>`;
        }
    });

    if (!canUseTarget) {
        html += `<p style="font-size:12px; color:#777;">対象にできるプレイヤーがいません。</p>`;
    }

    openModal(`盗賊: ターゲット選択 (${count}回目)`, html);
    if (canUseTarget && document.getElementById("modal-footer")) {
        document.getElementById("modal-footer").innerHTML = "";
    }
}

// 2. ★追加: 奪うカードを選ぶ（裏向きシャッフル）
/* --- 修正版: 盗賊 (ハッカー対応) --- */

// 奪うカード選択
function thiefSelectTake(targetId, count) {
    if (!canTargetByHandInterference(targetId)) return;
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p>相手の手札から<strong>奪うカード</strong>を選んでください。<br>
                <span style="font-size:11px;">(公開カードは見えます)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "?";
        let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        let cssClass = "card"; 
        let onClick = `onclick="thiefSelectGive('${targetId}', ${c.originalIndex}, ${count})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            style = "cursor:not-allowed; border:1px solid #555; background:#333;";
            content = "🔒"; 
            onClick = "";
        }
        else if (c.isOpen) {
            cssClass = `card ${c.type}`;
            content = c.val;
            style = "cursor:pointer; "; 
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });
    
    openModal(`盗賊: 略奪選択 (${count}回目)`, html);
    if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
}

// 渡すカード選択
function thiefSelectGive(targetId, takeIdx, count) {
    if (!canTargetByHandInterference(targetId)) return;
    const myHand = sortCards(deepCopy(gameState.hands[myId] || []));

    let html = `<p>相手に押し付けるカードを選んでください。</p><div class="modal-list">`;
    
    myHand.forEach((c, idx) => {
        let style = "";
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execThiefTrade('${targetId}', ${idx}, ${takeIdx}, ${count})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            onClick = "";
        }

        html += `<div class="${cssClass}" style="${style} cursor:pointer;" ${onClick}>${c.val}</div>`;
    });

    openModal(`盗賊: 譲渡選択 (${count}回目)`, html);

    if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
}

// 3. 自分の手札から「押し付けるカード」を選ぶ
function thiefSelectGive(targetId, takeIdx, count) {
    if (!canTargetByHandInterference(targetId)) return;
    const myHand = sortCards(deepCopy(gameState.hands[myId] || []));

    let html = `<p>相手に押し付けるカードを選んでください。</p><div class="modal-list">`;
    
    myHand.forEach((c, idx) => {
        let style = "";
        
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // 実行関数へ (takeIdx も渡す)
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                      onclick="execThiefTrade('${targetId}', ${idx}, ${takeIdx}, ${count})">
                      ${c.val}
                 </div>`;
    });
    

    openModal(`盗賊: 譲渡選択 (${count}回目)`, html);

    if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
}

// 4. トレード実行処理 (ランダムではなく指定インデックスで)
async function execThiefTrade(targetId, giveIdx, takeIdx, count) {
    closeModal();
    if (!canTargetByHandInterference(targetId)) return;
    const updates = {};
    
    let myHand = [...(gameState.hands[myId] || [])];
    let targetHand = [...(gameState.hands[targetId] || [])]; // 相手の手札(ソート済み)
    
    if (targetHand.length === 0) {
        showInfoModal("エラー", "相手の手札がありません！");
        return;
    }

    // --- トレード実行 ---
    // 自分が出すカード
    const giveCard = myHand.splice(giveIdx, 1)[0]; 
    // 相手から奪うカード (指定したインデックス)
    const receiveCard = targetHand.splice(takeIdx, 1)[0]; 
    
    myHand.push(receiveCard); 
    targetHand.push(giveCard); 

    // カード移動後の整理
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);
    
    const targetName = gameState.players[targetId].name;
    
    // ログ出力
    await pushLog(`${myName}が[盗賊]で${targetName}とトレードしました！(${count}回目)`, 'public');
    await pushLog(`${targetName}から [${receiveCard.val}] を盗み、 [${giveCard.val}] を奪いました。`, 'private', myId);
    await pushLog(`${myName}に [${receiveCard.val}] を盗まれ、 [${giveCard.val}] を渡されました。`, 'private', targetId);

    // 通知
    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(盗賊)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };

    // 音（2回目は専用音）
    if (count === 2) {
         const skillSound = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_THIEF']) ? 'SKILL_THIEF' : 'SKILL';
         updates[`rooms/${currentRoom}/lastSound`] = { type: skillSound, id: Date.now() };
    }

    // 1回目なら使用済みフラグを立てる
    if (count === 1) {
        let actList = {...(gameState.activatedList || {})};
        actList[myId] = true; 
        updates[`rooms/${currentRoom}/activatedList`] = actList;
    }

    await db.ref().update(updates);

    // 次の行動確認
    if (count === 1) {
        let confirmHtml = `
            <p>1回目のトレードが完了しました。<br>
            <strong>奪ったカード: ${receiveCard.val}</strong><br>
            続けて2回目のトレードを行いますか？
            </p>
            <button onclick="activateThief(2)" style="width:100%; padding:15px; background:#d32f2f; color:white; font-weight:bold; margin-bottom:10px;">
                はい (もう一度盗む)
            </button>
            <button onclick="endThiefTurn()" style="width:100%; padding:15px; background:#444; color:white;">
                いいえ (ターンを終了する)
            </button>
        `;
        openModal("盗賊: 追撃の選択", confirmHtml);
        
        if (document.getElementById("modal-footer")) {
                    document.getElementById("modal-footer").innerHTML = "";
                }
    } else {
        endThiefTurn();
    }
}
// 4. ターン終了処理
async function endThiefTurn() {
    closeModal();
    
    // ★修正: gameState.turnIdx を使うように変更（念のため）
    let currentTurnIdx = (typeof turnIdx !== 'undefined') ? turnIdx : gameState.turnIdx;
    let nextIdx = (currentTurnIdx + 1) % gameState.playerOrder.length;
    
    let updates = {};
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
    updates[`rooms/${currentRoom}/passCount`] = 0; 
    updates[`rooms/${currentRoom}/lastAction`] = "THIEF_END";

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await db.ref().update(updates);
    await pushLog(`${myName}の[盗賊]が終了しました。`, 'public');
}

/* --- HUNTER (狩人) の実装 (UI改善版) --- */

function activateHunter() {
    let deckSym = gameState.deckSym || [];
    let hand = gameState.hands[myId] || [];
    
    if (deckSym.length === 0) return showInfoModal("エラー", "記号山札が空です。");

    let html = `
        <p style="font-size:12px;">
            記号山札の中身をすべて確認できます。<br>
            交換したいカードをタップして、<strong>「手札」と「山札」を同じ枚数</strong>にしてください。<br>
            <span style="color:#d32f2f;">※この画面を開いた時点でスキル使用済みとなります。</span>
        </p>
        
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
            <div style="width:48%; background:rgba(0,0,0,0.05); border-radius:8px; padding:5px;">
                <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; font-size:12px;">自分の手札 (除外)</div>
                <div id="hunter-hand-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>
            </div>

            <div style="width:48%; background:rgba(0,0,0,0.05); border-radius:8px; padding:5px;">
                <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; font-size:12px;">記号山札 (入手)</div>
                <div id="hunter-deck-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>
            </div>
        </div>

        <div style="margin-top:15px; text-align:center;">
            <p id="hunter-msg" style="color:#d32f2f; font-size:12px; font-weight:bold;">枚数が一致していません</p>
            
            <button onclick="execHunterSwap()" id="btn-hunter-exec" disabled 
                style="background:#ccc; color:#fff; padding:10px 30px; font-weight:bold; border-radius:20px;">交換して終了</button>
            <br>
            <button onclick="execHunterSwap(true)" style="background:#546e7a; color:#fff; margin-top:10px; padding:8px 20px; font-size:12px; border-radius:20px;">
                交換せずに終了
            </button>
        </div>
    `;

    openModal("狩人: 武器の選定", html);
    document.getElementById("modal-footer").innerHTML = ""; // 閉じるボタン削除

    // --- カードリスト生成関数 ---
    const createCardDiv = (c, i, type) => {
        let imgUrl = CARD_IMAGES[c.val];
        // 基本スタイル
        let style = "width:40px; height:60px; font-size:10px; cursor:pointer; transition:transform 0.1s; border:1px solid #999;";
        if (imgUrl) style += `background-image:url('${imgUrl}'); color:transparent; border:none;`;
        
        // クリックイベント: toggleHunterSelect(要素, タイプ, インデックス)
        return `<div class="card ${c.type} hunter-item" id="hunter-${type}-${i}" 
                    data-idx="${i}" data-type="${type}"
                    style="${style}" 
                    onclick="toggleHunterSelect(this)">
                    ${c.val}
                </div>`;
    };

    // 1. 手札リスト (記号のみ)
    let handHtml = "";
    hand.forEach((c, i) => {
        if (c.type === 'sym') handHtml += createCardDiv(c, i, 'hand');
    });
    document.getElementById("hunter-hand-list").innerHTML = handHtml;

    // 2. 山札リスト (すべて)
    let deckHtml = "";
    deckSym.forEach((c, i) => {
        deckHtml += createCardDiv(c, i, 'deck');
    });
    document.getElementById("hunter-deck-list").innerHTML = deckHtml;
}

// カード選択の切り替え & チェック
function toggleHunterSelect(el) {
    // クラス "selected-hunter" をつけ外しする
    if (el.classList.contains('selected-hunter')) {
        el.classList.remove('selected-hunter');
        el.style.border = el.style.backgroundImage ? "none" : "1px solid #999";
        el.style.transform = "scale(1)";
        el.style.boxShadow = "none";
    } else {
        el.classList.add('selected-hunter');
        // 選択時の見た目 (オレンジ色の太枠 + 少し拡大)
        el.style.border = "3px solid #ff9800";
        el.style.transform = "scale(1.1)";
        el.style.boxShadow = "0 0 5px rgba(255, 152, 0, 0.8)";
    }
    
    checkHunterCount(); // ボタン状態更新
}

// 枚数チェック関数
function checkHunterCount() {
    // クラス名で選択されている要素を数える
    let handSel = document.querySelectorAll('#hunter-hand-list .selected-hunter').length;
    let deckSel = document.querySelectorAll('#hunter-deck-list .selected-hunter').length;
    
    let btn = document.getElementById('btn-hunter-exec');
    let msg = document.getElementById('hunter-msg');

    if (handSel > 0 && handSel === deckSel) {
        btn.disabled = false;
        btn.style.background = "#e65100"; // 狩人っぽいオレンジ
        msg.innerText = `OK! (${handSel}枚交換)`;
        msg.style.color = "#e65100";
    } else {
        btn.disabled = true;
        btn.style.background = "#ccc";
        if (handSel === 0 && deckSel === 0) {
            msg.innerText = "交換するカードを選んでください";
        } else {
            msg.innerText = `枚数が一致していません (手札:${handSel} vs 山札:${deckSel})`;
        }
        msg.style.color = "#d32f2f";
    }
}

// 実行処理（山札循環・シャッフル追加版）
async function execHunterSwap(isSkip = false) {
    closeModal();
    
    let updates = {};
    let actList = {...(gameState.activatedList || {})};

    if (!isSkip) {
        // 選択された要素を取得
        let handEls = document.querySelectorAll('#hunter-hand-list .selected-hunter');
        let deckEls = document.querySelectorAll('#hunter-deck-list .selected-hunter');

        // インデックスを取り出して降順ソート
        let handIndices = Array.from(handEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);
        let deckIndices = Array.from(deckEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);

        let hand = sortCards(deepCopy(gameState.hands[myId]));
        let deckSym = [...(gameState.deckSym || [])];
        let excl = [...(gameState.exclusion || [])]; // 今回は使いませんが念のため

        let outNames = [];
        let inNames = [];

        // 1. 手札から出す（山札に戻す）
        handIndices.forEach(idx => {
            let c = hand.splice(idx, 1)[0];
            // excl.push(c); // ← 元の「除外」処理
            deckSym.push(c); // ★変更: 記号山札に追加！
            outNames.push(c.val);
        });

        // 2. 山札から取る
        deckIndices.forEach(idx => {
            let c = deckSym.splice(idx, 1)[0];
            hand.push(c);
            inNames.push(c.val);
        });
        
        // ★追加: 山札の中身が変わったのでシャッフルする
        // (これをしないと、戻したカードが一番下や上に固まってしまうため)
        shuffle(deckSym);

        // 手札を整理
        hand = sortCards(hand);

        updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
        updates[`rooms/${currentRoom}/deckSym`] = deckSym; 
        // updates[`rooms/${currentRoom}/exclusion`] = excl; // 除外場は変わらないので更新不要（またはそのまま更新してもOK）
        
        await pushLog(`${myName}が[狩人]を発動！手札 ${handIndices.length} 枚を記号山札と交換しました。`, 'public');
        await pushLog(`【狩りの成果】<br>使用武器(山札へ): ${outNames.join(', ')}<br>獲物: ${inNames.join(', ')}`, 'private', myId);

    } else {
        await pushLog(`${myName}が[狩人]を発動！交換せずに終了しました。`, 'public');
        await pushLog(`【狩りの成果】<br>なし`, 'private', myId);
    }

    // 共通処理
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    //playSoundEffect('SKILL');
    await db.ref().update(updates);
}

/* --- GAMBLER (賭博師) の実装 --- */
// 効果: 山札の数字を予想し、結果に応じて手札破棄・除外・獲得を行う。

// 1. 予想を選択する画面
function activateGambler() {
    let deck = gameState.deckNum || [];
    if (deck.length === 0) return showInfoModal("エラー", "数字山札がありません");

    let html = `
        <p>数字山札の一番上を予想してください。<br>
        <span style="font-size:12px; color:#666;">※実行すると全員に通知されます</span>
        </p>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <button onclick="execGamblerGuess('A')" style="padding:15px; background:#4fc3f7; color:#01579b; font-weight:bold; border-radius:8px;">
                A: 小さい (1, 2, 3, 4)<br>
                <span style="font-size:10px;">的中: 手札1枚捨て / 外れ: ターン終了</span>
            </button>
            <button onclick="execGamblerGuess('B')" style="padding:15px; background:#ffb74d; color:#e65100; font-weight:bold; border-radius:8px;">
                B: 大きい (6, 7, 8, 9)<br>
                <span style="font-size:10px;">的中: 手札1枚捨て / 外れ: ターン終了</span>
            </button>
            <button onclick="execGamblerGuess('C')" style="padding:15px; background:#ba68c8; color:#4a148c; font-weight:bold; border-radius:8px;">
                C: 命知らず (0, 5)<br>
                <span style="font-size:10px;">的中: 手札2枚捨て / 外れ: カードを獲得しターン終了</span>
            </button>
        </div>
    `;
    openModal("賭博師: 運命の選択", html);
}

// --- 賭博師：送信処理（スクイーズ対応版） ---
async function execGamblerGuess(type) {
    closeModal();
    let updates = {};
    let deck = [...(gameState.deckNum || [])];
    let excl = [...(gameState.exclusion || [])];
    
    let card = deck.pop(); 
    if (!card) return showInfoModal("エラー", "数字山札が空になりました。");
    let val = card.val;
    let win = false;

    // 判定
    let guessText = "";
    if (type === 'A') {
        if ([1,2,3,4].includes(val)) win = true;
        guessText = "小さい [1-4]";
    } else if (type === 'B') {
        if ([6,7,8,9].includes(val)) win = true;
        guessText = "大きい [6-9]";
    } else if (type === 'C') {
        if ([0,5].includes(val)) win = true;
        guessText = "命知らず [0, 5]";
    }

    // --- ★演出データ送信 ---
    updates[`rooms/${currentRoom}/effect`] = {
        guessTitle: guessText,
        cardVal: val,
        sub: win ? "WIN!!" : "LOSE...",
        color: win ? "#d50000" : "#333",
        isWin: win,
        guessType: type, // ★追加: これで「大当たり」かどうか判定する
        timestamp: firebase.database.ServerValue.TIMESTAMP
    };
    // ------------------------

    await pushLog(`${myName}が[賭博師]を発動！: ${guessText} -> 結果は...?`, 'public');

    // データ更新
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/deckNum`] = deck;
    if (win || type !== 'C') {
        excl.push(card);
        updates[`rooms/${currentRoom}/exclusion`] = excl;
    }

    //playSoundEffect('SKILL'); // 演出開始の合図音

    // DB更新（これで全員の画面で演出が始まる）
    await db.ref().update(updates);

    // 結果処理の分岐（演出時間の5秒+余韻3秒 = 8秒待ってから画面を出す）
    if (win) {
        let discardCount = (type === 'C') ? 2 : 1;
        setTimeout(() => {
            gamblerSelectDiscard(discardCount);
        }, 6000); // 結果スタンプが出た1秒後くらいに操作画面へ

    } else {
        // ハズレ処理
        let hand = null;
        if (type === 'C') {
            hand = sortCards(deepCopy(gameState.hands[myId]));
            hand.push(card);
            hand = sortCards(hand);
        }
        
        // 遅延更新
        setTimeout(async () => {
            let finalUpdates = {};
            if (type === 'C') {
                finalUpdates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            }
            finalUpdates[`rooms/${currentRoom}/passCount`] = 0;
            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            finalUpdates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
            
            await db.ref().update(finalUpdates);
            if (type === 'C') {
                await pushLog(`結果: [${val}] でした。開いたカードを手札に加えました。`, 'public');
            } else {
                await pushLog(`結果: [${val}] でした。開いたカードは除外されました。`, 'public');
            }
        }, 6000);
    }
}

// 3. (勝利時) 捨てるカードを選ぶ画面
function gamblerSelectDiscard(count) {
    let hand = sortCards(deepCopy(gameState.hands[myId] || []));
    
    // 捨てる枚数が手札より多い場合のケア
    if (hand.length < count) count = hand.length;

    let html = `
        <p style="font-size:14px; font-weight:bold; color:#2e7d32;">
            おめでとうございます！<br>
            手札から <span style="font-size:18px;">${count}枚</span> 選んで捨ててください。
        </p>
        
        <div id="gambler-hand-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>

        <div style="margin-top:15px; text-align:center;">
             <p id="gambler-msg" style="font-size:12px;">あと ${count} 枚選んでください</p>
            <button onclick="execGamblerDiscard(${count})" id="btn-gambler-exec" disabled 
                style="background:#ccc; color:#fff; padding:10px 30px; border-radius:20px;">決定</button>
        </div>
    `;

    openModal("賭博師: 勝利の報酬", html);
    document.getElementById("modal-footer").innerHTML = ""; 

    // カードリスト生成 (狩人と同じUIを使用)
    let handHtml = "";
    hand.forEach((c, i) => {
        let imgUrl = CARD_IMAGES[c.val];
        let style = "width:40px; height:60px; font-size:10px; cursor:pointer; transition:transform 0.1s; border:1px solid #999;";
        if (imgUrl) style += `background-image:url('${imgUrl}'); color:transparent; border:none;`;

        handHtml += `<div class="card ${c.type} gambler-item" data-idx="${i}" 
                    style="${style}" 
                    onclick="toggleGamblerSelect(this, ${count})">
                    ${c.val}
                </div>`;
    });
    document.getElementById("gambler-hand-list").innerHTML = handHtml;
}

// 選択切り替え処理
function toggleGamblerSelect(el, maxCount) {
    if (el.classList.contains('selected-gambler')) {
        el.classList.remove('selected-gambler');
        el.style.border = (el.style.backgroundImage) ? "none" : (el.innerText=="0" ? "2px solid #ab47bc" : "1px solid #999");
        el.style.transform = "scale(1)";
    } else {
        // 選択可能枚数チェック
        let currentSel = document.querySelectorAll('.selected-gambler').length;
        if (currentSel >= maxCount) return; // これ以上選べない

        el.classList.add('selected-gambler');
        el.style.border = "3px solid #2e7d32"; // 緑枠
        el.style.transform = "scale(1.1)";
    }

    // ボタン制御
    let selCount = document.querySelectorAll('.selected-gambler').length;
    let btn = document.getElementById('btn-gambler-exec');
    let msg = document.getElementById('gambler-msg');

    if (selCount === maxCount) {
        btn.disabled = false;
        btn.style.background = "#2e7d32";
        msg.innerText = "OK!";
        msg.style.color = "#2e7d32";
    } else {
        btn.disabled = true;
        btn.style.background = "#ccc";
        msg.innerText = `あと ${maxCount - selCount} 枚選んでください`;
        msg.style.color = "#333";
    }
}

// 4. (勝利時) 捨てる実行処理
// ↓↓↓ execGamblerDiscard関数を丸ごとこれに置き換えてください ↓↓↓
        async function execGamblerDiscard(count) {
            closeModal();
            let updates = {};
            
            let handEls = document.querySelectorAll('.selected-gambler');
            let indices = Array.from(handEls).map(el => parseInt(el.dataset.idx)).sort((a,b)=>b-a);
            
            let hand = sortCards(deepCopy(gameState.hands[myId]));
            let graveNum = [...(gameState.graveNum || [])];
            let graveSym = [...(gameState.graveSym || [])];
            
            let discardedNames = [];

            // 手札から捨てて、それぞれの墓地へ
            indices.forEach(idx => {
                let c = hand.splice(idx, 1)[0];
                discardedNames.push(c.val);
                
                if (c.type === 'num') graveNum.push({...c, owner:myId});
                else graveSym.push(c);
            });

            hand = sortCards(hand);

            updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
            updates[`rooms/${currentRoom}/graveNum`] = graveNum;
            updates[`rooms/${currentRoom}/graveSym`] = graveSym;
            updates[`rooms/${currentRoom}/passCount`] = 0;

            let tempRankings = {...(gameState.rankings || {})};
            if (hand.length === 0) tempRankings[myId] = 99; 

            let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
            updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

            await pushLog(`${myName}が[賭博師]の報酬で [${discardedNames.join(', ')}] を捨てました！`, 'public');
            
            // ★重複エラー対策 & 同時再生対応
            let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
            let nextTotal = hand.length + myHackedCount;

            let soundList = ['DISCARD'];
            if (nextTotal === 1) soundList.push('UNO');
            else if (nextTotal === 2) soundList.push('DOS');

            updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

            // あがり判定
            if (hand.length === 0 && myHackedCount === 0) {
                let currentRank = Object.keys(gameState.rankings || {}).length + 1;
                updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
                await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');
                
                // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
                updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
                updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
                // ▲▲▲ 追加ここまで ▲▲▲
                
                let totalPlayers = gameState.playerOrder.length;
                if (currentRank >= totalPlayers - 1) {
                         updates[`rooms/${currentRoom}/status`] = "finished";

                        // 敗者（最後の一人）を特定
                        let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！！最下位 ${lName} の残り手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！！`, 'public');
                        }
                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                }
            }

            await db.ref().update(updates);
        }


/* --- バカラ風スクイーズ演出 --- */
function showVisualEffect(data) {
    let overlay = document.getElementById('visual-overlay');
    let guessDiv = document.getElementById('squeeze-guess');
    let contentDiv = document.getElementById('squeeze-content');
    let coverDiv = document.getElementById('squeeze-cover');
    let resultDiv = document.getElementById('squeeze-result');

    // 初期化
    guessDiv.innerHTML = `賭博師の予想: <br><span style="font-size:32px;">${data.guessTitle}</span>`;
    contentDiv.innerText = data.cardVal;
    
    coverDiv.style.transition = "none";
    coverDiv.style.top = "0%";
    
    resultDiv.style.transform = "translate(-50%, -50%) scale(0)";
    resultDiv.style.opacity = "0";
    resultDiv.innerText = data.sub;
    resultDiv.style.color = data.color;
    resultDiv.style.border = `4px solid ${data.color}`;
    resultDiv.style.padding = "10px 40px";
    resultDiv.style.borderRadius = "10px";
    resultDiv.style.background = "rgba(255,255,255,0.9)";

    // 表示
    overlay.style.display = "flex";
    
    // アニメーション開始
    setTimeout(() => {
        // ★追加: ここでドラムロール開始！
        playSoundEffect('DRUM');

        coverDiv.style.transition = "top 5s ease-in-out"; 
        coverDiv.style.top = "100%";
    }, 500);

    // 結果ドン！
    setTimeout(() => {
        resultDiv.style.opacity = "1";
        resultDiv.style.transform = "translate(-50%, -50%) scale(1)";
        
        // ★追加: 結果に応じた音を鳴らす
        if (data.isWin) {
            // C(0,5)なら大当たり、それ以外なら普通当たり
            if (data.guessType === 'C') {
                playSoundEffect('WIN_BIG'); 
            } else {
                playSoundEffect('WIN_NORMAL');
            }
        } else {
            playSoundEffect('LOSE');
        }

    }, 5000); // 5秒後 (ドラムロールが終わる頃)

    // 終了
    setTimeout(() => {
        overlay.style.display = "none";
    }, 8000);
}

/* --- CROWN (ピエロ) の実装 --- */
// 概要: パネル自体を「REVERSE」「TRADE」「DIG UP」のいずれかとして使う

// 1. 発動：効果を選択する
function activateMagician() {
    let html = `
        <p>どのサプライズを行いますか？<br>
        <span style="font-size:12px; color:#888;">※手札のカードは消費しません（コストとして必要な場合を除く）</span>
        </p>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <button onclick="execMagicianReverse()" style="padding:15px; background:#e91e63; color:white; font-weight:bold; border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span style="font-size:18px;">🔄 REVERSE</span>
                <span style="font-size:11px; margin-top:4px;">強弱をひっくり返す！</span>
            </button>
            <button onclick="activateMagicianTrade()" style="padding:15px; background:#ffb74d; color:#e65100; font-weight:bold; border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span style="font-size:18px;">🤝 TRADE</span>
                <span style="font-size:11px; margin-top:4px;">こっそりカードを交換する！</span>
            </button>
            <button onclick="activateMagicianDigUp()" style="padding:15px; background:#8d6e63; color:white; font-weight:bold; border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span style="font-size:18px;">⛏ DIG UP</span>
                <span style="font-size:11px; margin-top:4px;">カードを拾ってすり替える！</span>
            </button>
        </div>
    `;
    openModal("ピエロ: サプライズ選択", html);
}

// --- A: REVERSE (革命) ---
async function execMagicianReverse() {
    closeModal();
    let updates = {};
    
    // 革命フラグ反転
    updates[`rooms/${currentRoom}/isReverse`] = !gameState.isReverse;
    
    // ★ポイント: 使用済みリストに「何を使ったか」を書き込む
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "REVERSE"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ログなど
    await pushLog(`${myName}が[ピエロ]で[REVERSE] を使用して強弱を逆転させました`, 'public');
    //playSoundEffect('SKILL');
    //playSoundEffect('REVERSE');
    
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'REVERSE', id: Date.now() };
    // ターン進行
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

// --- B: TRADE (交換) ---
/* --- 修正版: ピエロ (ハッカー & 公開対応) --- */

// B: TRADE (交換) - 相手選択
function activateMagicianTrade() {
    let hand = gameState.hands[myId] || [];
    // 自分の手札が全てハッキングされていたら交換に出せるカードがない
    let availableHand = hand.filter(c => !c.isHacked);
    let canUseTarget = false;
    
    if (hand.length === 0) return showInfoModal("エラー", "手札がありません");
    if (availableHand.length === 0) return showInfoModal("ロック中", "ハッキングされていない手札がありません");

    let html = `<p>トレード相手を選んでください。</p>`;
    gameState.playerOrder.forEach(pid => {
        if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
        let p = gameState.players[pid];
        let count = gameState.hands[pid] ? gameState.hands[pid].length : 0;
        
        // ★変更: 次は「奪うカード選択 (magicianSelectTake)」へ
        if (count > 0) {
            if (isPoliticianShieldActive(pid)) {
                html += `<button class="modal-btn is-disabled" disabled>${p.name} (政治家で対象外)</button>`;
            } else {
                canUseTarget = true;
                html += `<button class="modal-btn" onclick="magicianSelectTake('${pid}')">${p.name} (手札${count})</button>`;
            }
        }
    });
    if (!canUseTarget) html += `<p class="modal-note">対象にできるプレイヤーがいません。</p>`;
    openModal("ピエロ(TRADE): 相手選択", html);
}

// ★新設: 奪うカード選択 (ハッカー & 公開対応)
function magicianSelectTake(targetId) {
    if (!canTargetByHandInterference(targetId)) return;
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p>相手の手札から<strong>奪うカード</strong>を選んでください。<br>
                <span style="font-size:11px;">(公開カードは見えます)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "?";
        let style = "cursor:pointer; background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        let cssClass = "card"; 
        let onClick = `onclick="magicianSelectGive('${targetId}', ${c.originalIndex})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            style = "cursor:not-allowed; border:1px solid #555; background:#333;";
            content = "🔒"; 
            onClick = "";
        }
        // ★公開対応
        else if (c.isOpen) {
            cssClass = `card ${c.type}`;
            content = c.val;
            style = "cursor:pointer; ";
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });

    html += `</div>`;
    openModal("ピエロ(TRADE): 略奪選択", html);
}

// 渡すカード選択 (名前変更: SelectTradeCard -> SelectGive)
function magicianSelectGive(targetId, takeIdx) {
    if (!canTargetByHandInterference(targetId)) return;
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>相手に渡すカードを選んでください。<br><span style="font-size:11px;">(ピエロの効果なのでTRADEカード自体は不要です)</span></p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execMagicianTrade('${targetId}', ${i}, ${takeIdx})"`;

        // ★ハッカー対応
        if (c.isHacked) {
            cssClass += " hacked";
            onClick = "";
        }
        
        html += `<div class="${cssClass}" style="${style}" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;
    openModal("ピエロ(TRADE): 譲渡選択", html);
}

// 実行処理 (引数 takeIdx を追加)
async function execMagicianTrade(targetId, giveIdx, takeIdx) {
    closeModal();
    if (!canTargetByHandInterference(targetId)) return;
    let updates = {};
    let myHand = sortCards(deepCopy(gameState.hands[myId]));
    let targetHand = sortCards(deepCopy(gameState.hands[targetId]));

    // 交換処理
    let giveCard = myHand.splice(giveIdx, 1)[0]; // 自分のカード
    // ★変更: 指定したカードを奪う
    let receiveCard = targetHand.splice(takeIdx, 1)[0]; // 相手のカード
    
    myHand.push(receiveCard);
    targetHand.push(giveCard);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);

    // 使用済み記録: TRADE
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "TRADE"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'TRADE', id: Date.now() };

    const targetName = gameState.players[targetId].name;

    await pushLog(`${myName}が[ピエロ]で[TRADE]を使用して${targetName} とカードを交換しました`, 'public');
    await pushLog(`[ピエロ]で${targetName}から [${receiveCard.val}] を奪い、[${giveCard.val}] を渡しました。`, 'private', myId);
    await pushLog(`[ピエロ]の${gameState.players[myId].name}に [${receiveCard.val}] を奪われ、 [${giveCard.val}] を渡されました。`, 'private', targetId);

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(ピエロ)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };
    
    await db.ref().update(updates);
}

// --- C: DIG UP (発掘) ---
function activateMagicianDigUp() {
    let gn = gameState.graveNum || [];
    if (gn.length === 0) return showInfoModal("エラー", "数字墓地がないため拾えません");

    let hand = gameState.hands[myId] || [];
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("エラー", "埋めるための数字カードが手札にありません");

    // 埋めるカードを選ぶ
    let html = `<p>墓地の一番上を拾います。<br>代わりに埋めるカード(数字)を選んでください。</p><div class="modal-list">`;
    hand.forEach((c, i) => {
        if (c.type !== 'num') return; // 数字以外は埋められないルール
        let style = '';
        html += `<div class="card ${c.type}" style="${style}" onclick="execMagicianDigUp(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("ピエロ(DIG UP): 埋葬選択", html);
}

async function execMagicianDigUp(buryIdx) {
    closeModal();
    let updates = {};
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let gn = [...(gameState.graveNum || [])];
    
    // 処理: 墓地トップ取得 → 手札埋め → 手札入れ替え
    let top = gn.pop(); 
    let buryCard = hand.splice(buryIdx, 1)[0];
    hand.push(top);
    gn.push({...buryCard, owner:myId});

    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(hand);
    updates[`rooms/${currentRoom}/graveNum`] = gn;

    // ★使用済み記録: DIG UP
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = "DIG UP"; 
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'DIG UP', id: Date.now() };

    await pushLog(`${myName}が[ピエロ]の[DIG UP] を使用して [${top.val}] を回収し、[${buryCard.val}] を埋めました。`, 'public');
    //playSoundEffect('SKILL');
    //playSoundEffect('DIG UP');

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- MILLIONAIRE (富豪) の実装 --- */
function activateMillionaire() {
    let hand = gameState.hands[myId] || [];
    let deckSym = gameState.deckSym || [];

    // 除外できる数字カードがあるかチェック
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("エラー", "除外できる数字カードがありません");
    
    if (deckSym.length === 0) return showInfoModal("エラー", "記号山札が空です");

    let html = `<p>コストとして除外する数字カードを選んでください。<br><span style="font-size:11px;">(記号山札から1枚引きます)</span></p><div class="modal-list">`;
    hand.forEach((c, i) => {
        if (c.type !== 'num') return; 
        
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" onclick="execMillionaire(${i})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("富豪: 資産運用", html);
}

async function execMillionaire(excludeIdx) {
    closeModal();
    let updates = {};
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deckSym = [...(gameState.deckSym || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 1. 手札を除外
    let excludedCard = hand.splice(excludeIdx, 1)[0];
    excl.push(excludedCard);
    
    // 音シグナル送信 (PUT音)
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'PUT', id: Date.now() };

    // 2. 記号山札からドロー
    let drawnCard = deckSym.pop();
    hand.push(drawnCard);
    hand = sortCards(hand);

    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckSym`] = deckSym;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await pushLog(`${myName}が[富豪]を発動！手札の [${excludedCard.val}] を支払って記号カードを買いました`, 'public');
    await pushLog(`【富豪の買い物】買ったカード: [${drawnCard.val}]`, 'private', myId);

    await db.ref().update(updates);
}

/* --- EMPEROR (皇帝) の実装 --- */

// 1. スキル発動：全カード回収＆選択画面
function activateEmperor() {
    // 全員の手札を回収して、ソートして表示する
    let allCards = [];
    let pIds = gameState.playerOrder;
    const protectedPids = pIds.filter(pid => isPoliticianShieldActive(pid));
    const targetPids = pIds.filter(pid => !isPoliticianShieldActive(pid));
    
    // 全回収（政治家の保護対象は除外）
    targetPids.forEach(pid => {
        let h = gameState.hands[pid] || [];
        allCards = allCards.concat(h);
    });

    if (allCards.length === 0) return showInfoModal("使用不可", "政治家の保護により対象にできる手札がありません。");

    // ★ご希望のソート処理
    // 数字は小さい順、記号は名前順
    allCards.sort((a, b) => {
        // タイプが違うなら数字が先
        if (a.type !== b.type) return a.type === 'num' ? -1 : 1;
        
        // 数字同士なら値の小さい順
        if (a.type === 'num') return a.val - b.val;
        
        // 記号同士なら名前順 (DIG UP, DISCARD, REVERSE, TRADE)
        return a.val.localeCompare(b.val);
    });

    // モーダル表示
    let html = `
        <p style="font-size:14px;">
            市民の手札をすべて回収しました。<br>
            <strong>あなたが望む「1枚」を選んでください。</strong><br>
            <span style="font-size:11px; color:#888;">残りは自動的に再分配されます。</span>
        </p>
        <div class="modal-list">
    `;

    if (protectedPids.length > 0) {
        const protectedNames = protectedPids.map(pid => gameState.players[pid]?.name || pid).join("、");
        html += `<p style="font-size:11px; color:#d32f2f; width:100%;">※ ${protectedNames} は[政治家]の効果で対象外です</p>`;
    }

    allCards.forEach((c, i) => {
        // 通常のカードスタイル生成
        let style = "";
        
        // 画像があるなら背景にセット
        let cImg = CARD_IMAGES[c.val];
        if (cImg) {
            style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        }
        
        // クリックで実行（インデックスを渡す）
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                      onclick="execEmperorSelect(${i})">
                      ${c.val}
                 </div>`;
    });

    html += `</div>`;
    openModal("皇帝: 徴収と選定", html);
    document.getElementById("modal-footer").innerHTML = ""; // 戻るボタンなし
}

// 2. 選択実行＆再分配
async function execEmperorSelect(selectedIdx) {
    closeModal();
    let updates = {};

    // 1. もう一度全カードを回収・ソート（選択されたカードを特定するため）
    let pIds = gameState.playerOrder;
    const protectedPids = pIds.filter(pid => isPoliticianShieldActive(pid));
    const targetPids = pIds.filter(pid => !isPoliticianShieldActive(pid));
    let handCounts = {}; // 元の枚数を記録
    let allCards = [];
    
    targetPids.forEach(pid => {
        let h = gameState.hands[pid] || [];
        handCounts[pid] = h.length;
        allCards = allCards.concat(h);
    });

    if (allCards.length === 0) return showInfoModal("使用不可", "政治家の保護により対象にできる手札がありません。");
    if (selectedIdx < 0 || selectedIdx >= allCards.length) return showInfoModal("エラー", "選択カードが不正です。");

    // ソート（activateと同じロジック）
    allCards.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'num' ? -1 : 1;
        if (a.type === 'num') return a.val - b.val;
        return a.val.localeCompare(b.val);
    });

    // 2. 皇帝が選んだカードを確保
    let emperorCard = allCards.splice(selectedIdx, 1)[0];

    // 3. 残りをシャッフル
    shuffle(allCards);

    // 4. 再分配 (皇帝の次の人から配る)
    // まず皇帝に選んだ1枚を持たせる
    let newHands = {};
    pIds.forEach(pid => {
        if (isPoliticianShieldActive(pid)) newHands[pid] = sortCards(deepCopy(gameState.hands[pid] || []));
        else newHands[pid] = [];
    });
    newHands[myId].push(emperorCard);
    
    // 現在の皇帝のインデックス（保護対象を除いた並び）
    let myTurnIdx = targetPids.indexOf(myId);
    if (myTurnIdx === -1) return showInfoModal("エラー", "皇帝の配布対象が不正です。");
    let totalPlayers = targetPids.length;
    
    // カードを配るポインタ
    let cardPtr = 0;
    
    // 「皇帝の次の人」から順に、元の枚数になるまで配る
    // ループは最大でも (人数 * 最大手札枚数) 回程度なので安全
    for (let i = 1; i <= totalPlayers; i++) {
        let targetIdx = (myTurnIdx + i) % totalPlayers;
        let targetPid = targetPids[targetIdx];
        
        // その人が本来持つべき枚数になるまで山から補充
        while (newHands[targetPid].length < handCounts[targetPid] && cardPtr < allCards.length) {
            newHands[targetPid].push(allCards[cardPtr]);
            cardPtr++;
        }
    }

    // 5. 手札をソートしてセット
    pIds.forEach(pid => {
        newHands[pid] = sortCards(newHands[pid]);
        updates[`rooms/${currentRoom}/hands/${pid}`] = newHands[pid];
    });

    // 6. ログと演出
    await pushLog(`${myName}が[皇帝]を発動！市民の手札を全て回収し、再分配しました。`, 'public');
    if (protectedPids.length > 0) {
        const protectedNames = protectedPids.map(pid => gameState.players[pid]?.name || pid).join("、");
        await pushLog(`[政治家]保護により ${protectedNames} の手札は[皇帝]の対象外でした。`, 'public');
    }


    // 7. ターン終了
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    // 使用済みにする
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    await db.ref().update(updates);
}

/* --- POLICE OFFICER (警察官) 完成版 --- */
// 1. 全員の手札を1枚ずつ公開 (即座にカットイン) -> 3秒待機 -> 2. 強制トレード

// ステップ1: 一斉捜査
async function activatePoliceOfficer() {
    let updates = {};
    let logs = [];
    let protectedNames = [];
    
    // ★修正1: 発動した瞬間に「使用済み」にする
    // これにより、render関数が反応して「カットイン」と「音」が自動で流れます
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // 全員の手札をチェックして公開フラグを立てる
    gameState.playerOrder.forEach(pid => {
        if (pid === myId) return; 
        if (gameState.rankings && gameState.rankings[pid]) return; 
        if (isPoliticianShieldActive(pid)) {
            protectedNames.push(gameState.players[pid].name);
            return;
        }

        let hand = deepCopy(gameState.hands[pid] || []);
        let hiddenIndices = [];
        hand.forEach((c, i) => { if (!c.isOpen) hiddenIndices.push(i); });

        if (hiddenIndices.length > 0) {
            let rand = Math.floor(Math.random() * hiddenIndices.length);
            let targetIdx = hiddenIndices[rand];
            
            hand[targetIdx].isOpen = true; // 公開！
            updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
            
            let pName = gameState.players[pid].name;
            logs.push(`${pName}の[${hand[targetIdx].val}]`);
        }
    });

    if (logs.length > 0) {
        await pushLog(`${myName}が[警察官]で一斉捜査！ ${logs.join('、')} を公開させました！`, 'public');
        // 音はrender関数が「activatedList」の変化を検知して鳴らすので、ここでは鳴らしません（二重再生防止）
    } else {
        await pushLog(`${myName}が[警察官]を発動しましたが、新たな証拠は見つかりませんでした。`, 'public');
    }
    if (protectedNames.length > 0) {
        await pushLog(`[政治家]保護により ${protectedNames.join("、")} は[警察官]の公開対象外でした。`, 'public');
    }

    await db.ref().update(updates);

    // ★修正2: カットイン演出の余韻（3秒）を待ってから、強制的にトレード画面へ
    setTimeout(() => {
        policeTradeStart();
    }, 3000); 
}

/* --- 警察官のトレード改修 (狙い撃ち対応) --- */

// ステップ2: トレード相手選択
function policeTradeStart() {
    let html = `
        <p><strong>【捜査協力の要請】</strong><br>続けてトレード(交換)を行いますか？<br>
        <span style="font-size:11px; color:#666;">(任意: 行わない場合は下のボタンで終了)</span>
        </p>

        <p style="margin-top:10px;">相手を選んでください</p>
    `;
    let canUseTarget = false;

    // 相手リスト生成
    gameState.playerOrder.forEach(pid => {
        if (pid === myId || (gameState.rankings && gameState.rankings[pid])) return;
        let p = gameState.players[pid];
        let hand = gameState.hands[pid] || [];
        let count = hand.length;
        
        // 公開情報の表示
        let revealed = hand.filter(c => c.isOpen).map(c => c.val).join(", ");
        let revealedInfo = revealed ? `<br><span style="font-size:11px; color:#000000;">(公開: ${revealed})</span>` : "";

        if (count > 0) {
            if (isPoliticianShieldActive(pid)) {
                html += `<button class="modal-btn is-disabled" disabled>
                            ${p.name} (政治家で対象外)
                         </button>`;
            } else {
                canUseTarget = true;
                html += `<button class="modal-btn" onclick="policeSelectTake('${pid}')">
                            ${p.name} (手札${count})${revealedInfo}
                         </button>`;
            }
        }
    });
    if (!canUseTarget) html += `<p class="modal-note">対象にできるプレイヤーがいません。</p>`;
    
    // ▼▼▼ キャンセルボタン（トレードしない）を追加 ▼▼▼
    html += `
        <div style="margin-top:20px; border-top:1px solid #ccc; padding-top:10px;">
            <button onclick="endPoliceTurn()" style="background:#78909c; color:white; padding:10px 20px; border-radius:20px;">
                捜査を終了する (トレードしない)
            </button>
        </div>
    `;

    openModal("警察官: 捜査対象の選択", html);
    document.getElementById("modal-footer").innerHTML = ""; // 標準の閉じるボタンは消し、自前の終了ボタンを使わせる
}

// ★追加: トレードせずに終了する関数
async function endPoliceTurn() {
    closeModal();
    let updates = {};

    // ログ
    await pushLog(`${myName}がトレードなしで[警察官]の捜査を終了しました。`, 'public');

    // ターン終了処理
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- 修正版: policeSelectTake (フォントバレ防止) --- */
/* --- 修正版: 警察官 (ハッカー対応) --- */

// 奪うカード選択
function policeSelectTake(targetId) {
    if (!canTargetByHandInterference(targetId)) return;
    let targetHand = deepCopy(gameState.hands[targetId] || []);
    targetHand.forEach((c, i) => c.originalIndex = i);
    shuffle(targetHand);

    let html = `<p><strong>押収するカード</strong>を選んでください。<br>
                <span style="font-size:11px;">(公開カードは見えます)</span></p>
                <div class="modal-list">`;

    targetHand.forEach(c => {
        let content = "";
        let style = "cursor:pointer; ";
        let cssClass = "card"; 
        let onClick = `onclick="policeSelectGive('${targetId}', ${c.originalIndex})"`;

        if (c.isOpen) {
            cssClass = `card ${c.type}`; 
            content = c.val;
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        } else {
            content = "?";
            style += "background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
        }

        html += `<div class="${cssClass}" style="${style}" ${onClick}>${content}</div>`;
    });

    html += `</div>`;
    openModal("警察官: 押収品選択", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// 渡すカード選択
function policeSelectGive(targetId, takeIdx) {
    if (!canTargetByHandInterference(targetId)) return;
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>相手に渡すカードを選んでください。</p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        let cssClass = `card ${c.type}`;
        let onClick = `onclick="execPoliceTrade('${targetId}', ${i}, ${takeIdx})"`;

        html += `<div class="${cssClass}" style="${style} cursor:pointer;" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;
    openModal("警察官: 提出", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// ステップ3: 自分のカード選択 (引数に takeIdx を追加)
function policeSelectGive(targetId, takeIdx) {
    if (!canTargetByHandInterference(targetId)) return;
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let html = `<p>相手に渡すカードを選んでください。</p><div class="modal-list">`;
    
    hand.forEach((c, i) => {
        let style = '';
        let cImg = CARD_IMAGES[c.val];
        if(cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
        
        // execPoliceTrade に takeIdx も渡す
        html += `<div class="card ${c.type}" style="${style} cursor:pointer;" 
                  onclick="execPoliceTrade('${targetId}', ${i}, ${takeIdx})">${c.val}</div>`;
    });
    html += `</div>`;
    openModal("警察官: 提出", html);
    document.getElementById("modal-footer").innerHTML = "";
}

// ステップ4: トレード実行 (ランダムではなく指定インデックスで交換)
async function execPoliceTrade(targetId, giveIdx, takeIdx) {
    closeModal();
    if (!canTargetByHandInterference(targetId)) return;
    let updates = {};
    let myHand = sortCards(deepCopy(gameState.hands[myId]));
    let targetHand = sortCards(deepCopy(gameState.hands[targetId])); // 相手の手札はソート済みの状態から取る

    // 交換実行
    let giveCard = myHand.splice(giveIdx, 1)[0];
    // ★変更: ランダムではなく、指定された takeIdx のカードを奪う
    let receiveCard = targetHand.splice(takeIdx, 1)[0];
    const targetName = gameState.players[targetId].name;
    
    myHand.push(receiveCard);
    targetHand.push(giveCard);
    
    updates[`rooms/${currentRoom}/hands/${myId}`] = sortCards(myHand);
    updates[`rooms/${currentRoom}/hands/${targetId}`] = sortCards(targetHand);

    updates[`rooms/${currentRoom}/lastSound`] = { type: 'TRADE', id: Date.now() };
    await pushLog(`${myName}が[警察官]として${targetName}とトレードを実行しました。`, 'public');
    await pushLog(`${targetName}から [${receiveCard.val}] を押収し、[${giveCard.val}] を渡しました。`, 'private', myId);
    await pushLog(`${myName}に [${receiveCard.val}] を押収され、[${giveCard.val}] を渡されました。`, 'private', targetId);
    
    updates[`rooms/${currentRoom}/players/${targetId}/notification`] = {
        fromName: myName + "(警察官)",
        lostVal: receiveCard.val,
        gotVal: giveCard.val
    };

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
}

/* --- HACKER (ハッカー) Ver 4.0 [隔離リスト方式] --- */

let hackerTargets = {}; 

// 1. 発動画面
function activateHacker() {
    hackerTargets = {}; 
    renderHackerUI();
}

function renderHackerUI() {
    let pIds = gameState.playerOrder;
    // ターゲット候補: 手札がある人
    let targets = pIds.filter(pid => 
        pid !== myId && 
        !gameState.rankings?.[pid] && 
        !isPoliticianShieldActive(pid) &&
        (gameState.hands[pid] || []).length > 0
    );
    let blockedTargets = pIds.filter(pid =>
        pid !== myId &&
        !gameState.rankings?.[pid] &&
        isPoliticianShieldActive(pid) &&
        (gameState.hands[pid] || []).length > 0
    );
    Object.keys(hackerTargets).forEach(pid => {
        if (!targets.includes(pid)) delete hackerTargets[pid];
    });

    let html = `
        <p><strong>システムへの侵入を開始します...</strong><br>
        対象プレイヤーの手札から<span style="color:#ef5350; font-weight:bold;">1枚ずつ</span>選び、
        ウイルス(ロック)を仕込んでください。
        </p>
        <div id="hacker-ui-container" style="text-align:left; max-height:300px; overflow-y:auto;">`;

    if (targets.length === 0) {
        html += `<p style="text-align:center; color:#ccc;">ハッキング可能な相手がいません。</p>`;
    }
    if (blockedTargets.length > 0) {
        html += `<p class="seki-disabled-note" style="text-align:center;">※政治家の保護中プレイヤーは対象外です</p>`;
        blockedTargets.forEach(pid => {
            const p = gameState.players[pid];
            html += `<button class="modal-btn is-disabled" style="width:100%; margin:4px 0;" disabled>${p.name} (政治家で対象外)</button>`;
        });
    }

    targets.forEach(pid => {
        let p = gameState.players[pid];
        let hand = gameState.hands[pid] || [];
        
        let selectedIdx = hackerTargets[pid]; 

        html += `<div style="margin-bottom:10px; background:rgba(0,0,0,0.05); padding:8px; border-radius:5px;">
                    <div style="font-weight:bold; font-size:12px; margin-bottom:5px; color:#333;">
                        ${p.name} <span style="font-size:10px; color:#666;">(手札:${hand.length})</span>
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:4px;">`;
        
        hand.forEach((c, i) => {
            let isSel = (selectedIdx === i);
            let cssClass = `card ${c.type}`;
            if (isSel) cssClass += " target-hack";
            
            let style = "width:36px; height:54px; font-size:12px; cursor:pointer; transition:0.1s;";
            let content = "?";

            if (c.isOpen) {
                content = c.val;
                let cImg = CARD_IMAGES[c.val];
                if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:none;`;
            } else {
                style += "background:#455a64; color:#cfd8dc; border:1px solid #78909c;";
            }

            if (isSel) {
                style += "border:2px solid #ef5350 !important; transform:scale(1.1); box-shadow:0 0 8px #ef5350; opacity:1;";
            }

            html += `<div class="${cssClass}" style="${style}" onclick="selectHackerTarget('${pid}', ${i})">
                        ${content}
                     </div>`;
        });
        html += `</div></div>`;
    });

    html += `</div>`;
    
    let currentSelectCount = Object.keys(hackerTargets).length;
    let requiredCount = targets.length;
    let canExec = (currentSelectCount === requiredCount && requiredCount > 0);

    html += `<div style="text-align:center; margin-top:10px;">
                <p style="font-size:10px; color:${canExec ? '#2e7d32' : '#d32f2f'}; margin-bottom:5px;">
                    選択状況: ${currentSelectCount} / ${requiredCount} 人
                </p>
                <button onclick="execHacker()" ${canExec ? '' : 'disabled'} 
                style="background:${canExec ? '#d32f2f' : '#ccc'}; color:white; padding:10px 30px; font-weight:bold; border-radius:20px; transition:0.3s;">
                ウイルス送信
                </button>
             </div>`;

    openModal("ハッカー: 標的選択", html);
    document.getElementById("modal-footer").innerHTML = `<button onclick="closeModal()">キャンセル</button>`;
}

function selectHackerTarget(targetId, idx) {
    hackerTargets[targetId] = idx;
    renderHackerUI();
}

// 3. 実行処理 (手札からhackedHandsへ移動)
async function execHacker() {
    const blockedId = Object.keys(hackerTargets).find(pid => isPoliticianShieldActive(pid));
    if (blockedId) return;
    closeModal();
    let updates = {};
    
    // 現在の隔離リストを取得
    let currentHackedHands = deepCopy(gameState.hackedHands || {});

    Object.keys(hackerTargets).forEach(pid => {
        let idx = hackerTargets[pid];
        let hand = deepCopy(gameState.hands[pid] || []);
        
        if (hand[idx]) {
            // 1. 手札から抜く
            let targetCard = hand.splice(idx, 1)[0];
            
            // 2. IDを刻印
            targetCard.hackedBy = myId;
            
            // ★修正: 番号ではなく「時間」を記録する
            targetCard.hackedAt = Date.now();
            
            // 3. 隔離リストへ追加
            if (!currentHackedHands[pid]) currentHackedHands[pid] = [];
            currentHackedHands[pid].push(targetCard);
            
            // 4. DB更新準備
            updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
        }
    });

    updates[`rooms/${currentRoom}/hackedHands`] = currentHackedHands;

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    
    updates[`rooms/${currentRoom}/lastSound`] = { type: 'SKILL_HACKER', id: Date.now() };
    await pushLog(`${myName}が[ハッカー]を発動！システムをハッキングしました`, 'public');

    // ★削除: 以下の3行を削除（またはコメントアウト）してください！
    // ハッカーは能力使用後も自分のターンが続くルールです。
    /*
    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, gameState.rankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;
    */

    await db.ref().update(updates);
}

async function checkHackerCleanup() {
    if (!gameState || !gameState.hackedHands) return;
    
    // 自分のターンが来た時のみチェック
    if (isMyTurn()) {
        let updates = {};
        let needsUpdate = false;
        let currentHackedHands = deepCopy(gameState.hackedHands);

        // ★追加: 最後の「ゲームの動き(publicログ)」があった時間を取得
        let lastLogTime = 0;
        if (gameState.logs) {
            for (let i = gameState.logs.length - 1; i >= 0; i--) {
                if (gameState.logs[i].type === 'public') {
                    lastLogTime = gameState.logs[i].timestamp || 0;
                    break;
                }
            }
        }
        
        Object.keys(currentHackedHands).forEach(pid => {
            if (!gameState.players[pid]) {
                delete currentHackedHands[pid];
                needsUpdate = true;
                return;
            }

            let lockedCards = currentHackedHands[pid] || [];
            let remainingLocked = [];
            let returningCards = [];
            
            lockedCards.forEach(c => {
                // ハックした時間（なければ0）
                let hackTime = c.hackedAt || 0;
                
                // ★判定ロジック修正:
                // 1. 自分がかけたロックである (c.hackedBy === myId)
                // 2. 最後のログの時間より、ハックした時間が「2秒以上」古い
                //    (今ハックしたばかりなら、時間はほぼ同じなので解除されません)
                //    (一周回ってきたなら、ログの時間はもっと進んでいるので解除されます)
                if (c.hackedBy === myId && (lastLogTime - hackTime > 2000)) {
                    let newC = {...c};
                    delete newC.hackedBy;
                    delete newC.hackedAt; // 時間記録も消す
                    returningCards.push(newC);
                } else {
                    remainingLocked.push(c);
                }
            });
            
            if (returningCards.length > 0) {
                let hand = deepCopy(gameState.hands[pid] || []);
                hand = hand.concat(returningCards);
                hand = sortCards(hand);
                
                updates[`rooms/${currentRoom}/hands/${pid}`] = hand;
                currentHackedHands[pid] = remainingLocked;
                needsUpdate = true;
            }
        });

        if (needsUpdate) {
            updates[`rooms/${currentRoom}/hackedHands`] = currentHackedHands;
            await pushLog(`${myName}のウイルス効果が切れ、ロックが解除されました。`, 'public');
            await db.ref().update(updates);
        }
    }
}

/* --- ALCHEMIST (錬金術師) 修正版 [UI改善 & 判定強化] --- */

let alchemyDrawnCard = null; 
let alchemyHandIdx = -1;     

// 発動
async function activateAlchemist() {
    let deck = gameState.deckNum || [];
    if (deck.length === 0) return showInfoModal("錬金失敗", "数字山札が尽きているため、素材を調達できません。");

    let hand = gameState.hands[myId] || [];
    let hasNum = hand.some(c => c.type === 'num');
    if (!hasNum) return showInfoModal("錬金失敗", "手札に触媒となる数字カードがありません。");

    // 仮引き
    let tempDeck = [...deck];
    alchemyDrawnCard = tempDeck.pop();
    
    alchemyHandIdx = -1;
    renderAlchemistUI();
}

// UI表示
/* --- 修正版: 場の確認機能 & ボタン改善 --- */
/* --- ALCHEMIST (錬金術師) UI修正版 --- */
function renderAlchemistUI() {
    let hand = sortCards(deepCopy(gameState.hands[myId] || []));
    
    // ▼ 場の状況（トップカードとルール）を取得
    let top = getTop(gameState.graveNum);
    let topVal = top ? top.val : "なし (何でも出せます)";
    let isRev = gameState.isReverse;
    let ruleText = isRev ? "▼ 逆行 (弱い方が強い)" : "▲ 順行 (強い方が強い)";
    
    // ▼ 修正: 場札のHTML生成 (実際のカードと同じクラス・スタイルを使用)
    let topCardHtml = "";
    if (top) {
        let style = "margin-right:15px; cursor:default; transform:scale(0.9);"; // 少しだけ小さくしてレイアウトに合わせる
        let cssClass = `card ${top.type}`;
        
        // 画像対応
        let imgUrl = CARD_IMAGES[top.val];
        if (imgUrl) {
            style += `background-image:url('${imgUrl}'); color:transparent; border:2px solid #fff;`;
        }
        
        // 実際のカードと同じHTML構造
        topCardHtml = `<div class="${cssClass}" style="${style}" ${Number(top.val)===0 ? 'data-val="0"':''}>${top.val}</div>`;
    } else {
        // 場が空の場合のプレースホルダー
        topCardHtml = `<div class="card" style="border:2px dashed #999; background:rgba(0,0,0,0.2); color:#ccc; margin-right:15px; display:flex; align-items:center; justify-content:center; transform:scale(0.9);">?</div>`;
    }

    // 引いたカードの表示スタイル
    let drawImg = CARD_IMAGES[alchemyDrawnCard.val];
    let drawStyle = "border:3px solid #7b1fa2; box-shadow:0 0 10px #7b1fa2; transform:scale(1.1);";
    if (drawImg) drawStyle += `background-image:url('${drawImg}'); color:transparent;`;

    // HTML組み立て
    let html = `
        <div style="background:#37474f; color:white; padding:10px 15px; border-radius:8px; margin-bottom:15px; text-align:left; font-size:12px; display:flex; align-items:center; justify-content:center; box-shadow:inset 0 0 10px rgba(0,0,0,0.5);">
            ${topCardHtml}
            <div>
                <div style="font-size:10px; opacity:0.8;">現在の場</div>
                <div style="font-size:18px; font-weight:bold; margin:2px 0;">${topVal}</div>
                <div style="color:#ffb74d; font-weight:bold; border:1px solid #ffb74d; padding:2px 6px; border-radius:4px; display:inline-block; font-size:11px;">${ruleText}</div>
            </div>
        </div>

        <div style="display:flex; justify-content:space-around; align-items:center; margin-bottom:10px; background:#f3e5f5; padding:10px; border-radius:8px;">
            <div style="text-align:center;">
                <div style="font-size:10px; color:#4a148c; font-weight:bold; margin-bottom:5px;">素材A (ドロー)</div>
                <div class="card num" style="${drawStyle} margin:0 auto;">${alchemyDrawnCard.val}</div>
            </div>
            <div style="font-size:20px; color:#aaa;">+</div>
            <div style="text-align:center;">
                <div style="font-size:10px; color:#4a148c; font-weight:bold; margin-bottom:5px;">素材B (手札)</div>
                <div id="alchemy-hand-preview" style="width:54px; height:86px; border:2px dashed #ccc; border-radius:6px; line-height:86px; color:#ccc;">?</div>
            </div>
        </div>

        <p>手札から<strong>素材にする数字カード</strong>を選んでください。</p>
        <div class="modal-list">`;

    // 手札リスト (変更なし)
    hand.forEach((c, i) => {
        let isNum = (c.type === 'num');
        let isSelected = (alchemyHandIdx === i);
        let style = "transition: transform 0.2s; ";
        let onClick = "";

        if (isNum) {
            style += "cursor:pointer; ";
            if (isSelected) style += "border:3px solid #7b1fa2; transform:scale(1.1); box-shadow:0 0 10px #7b1fa2;";
            
            if (c.isHacked) {
                style += "cursor:not-allowed; filter:grayscale(100%); border:1px solid #555; background:#333;";
                onClick = `onclick="showInfoModal('ロック', 'ハッキングされているカードは素材にできません')"`;
            } else {
                onClick = `onclick="selectAlchemistHand(${i})"`;
            }
        } else {
            style += "opacity:0.4; cursor:default; border:1px dashed #999;";
        }
        
        let cImg = CARD_IMAGES[c.val];
        if (cImg) style += `background-image:url('${cImg}'); color:transparent;`;

        html += `<div class="card ${c.type}" style="${style}" ${onClick}>${c.val}</div>`;
    });
    html += `</div>`;

    // 錬金実行ボタンエリア (ロジック変更なし)
    if (alchemyHandIdx !== -1) {
        let val1 = Number(alchemyDrawnCard.val);
        let val2 = Number(hand[alchemyHandIdx].val);

        let sumVal = (val1 + val2) % 10;
        let diffVal = Math.abs(val1 - val2);

        // 3. 積 (×)
        let prodVal = val1 * val2 % 10; // そのまま掛ける

        // 4. 商 (÷)
        // 大きい方を小さい方で割る
        let big = Math.max(val1, val2);
        let small = Math.min(val1, val2);
        let divVal = null;
        let divValid = false;

        // 0除算防止のみ (割り切れなくても切り捨てて商とする)
        if (small !== 0) {
            divVal = Math.floor(big / small); // ★ Math.floor() で切り捨て
            divValid = true;
        }

        // 判定
        let canSum = canPlay({type:'num', val:sumVal}, top, gameState.isReverse);
        let canDiff = canPlay({type:'num', val:diffVal}, top, gameState.isReverse);
        let canProd = canPlay({type:'num', val:prodVal}, top, gameState.isReverse);
        
        let canDiv = false;
        if (divValid) {
            canDiv = canPlay({type:'num', val:divVal}, top, gameState.isReverse);
        }

        const makeBtn = (label, val, can, isInvalidCalc) => {
            let bg = can ? "#7b1fa2" : "#e0e0e0"; 
            let color = can ? "white" : "#999";
            let cursor = can ? "pointer" : "not-allowed"; // カーソルを禁止マークに
            
            // 出せる時だけクリックイベントを設定
            let onClick = can ? `onclick="execAlchemist(${val})"` : "";
            // 出せない時は disabled 属性をつける
            let disabledAttr = can ? "" : "disabled";
            
            // 計算不能(0除算など)の場合の注記
            let note = "";
            if (!can) {
                if (isInvalidCalc) {
                    note = "<br><span style='font-size:10px; opacity:0.8;'>(不可)</span>";
                } else {
                    note = "<br><span style='font-size:10px; opacity:0.8;'>(ルール違反)</span>";
                }
            }

            // 表示値がnullの場合は "?" と表示
            let dispVal = (val !== null) ? val : "?";

            return `<button ${onClick} ${disabledAttr} style="background:${bg}; color:${color}; padding:10px 5px; border-radius:8px; cursor:${cursor}; width:48%; font-weight:bold; border:none; box-shadow:0 2px 4px rgba(0,0,0,0.2);">
                        ${label} <span style="font-size:18px;">[${dispVal}]</span>${note}
                    </button>`;
        };

        html += `
            <div style="margin-top:15px; padding:10px; background:#fff; border:1px solid #eee; border-radius:8px;">
                <p style="margin:0 0 10px 0; font-weight:bold; color:#333; font-size:12px;">錬成結果 (場の強弱に従う)</p>
                <div style="display:flex; justify-content:space-between; gap:5px;">
                    ${makeBtn("和 (+)", sumVal, canSum)}
                    ${makeBtn("差 (-)", diffVal, canDiff)}
                    ${makeBtn("積 (×)", prodVal, canProd, false)}
                    ${makeBtn("商 (÷)", divVal, canDiv, !divValid)}
                </div>
            </div>
        `;
    }

    // 中止ボタン
    let footerHtml = `<button onclick="execAlchemistKeep()" class="modal-btn" style="background:#78909c; margin-top:10px; width:100%;">
                        錬金失敗 (ドロー素材を除外する)
                      </button>`;

    openModal("錬金術師: 素材融合", html);
    document.getElementById("modal-footer").innerHTML = footerHtml;
    
    // プレビュー更新
    if (alchemyHandIdx !== -1) {
        let c = hand[alchemyHandIdx];
        let prev = document.getElementById("alchemy-hand-preview");
        if(prev) {
            prev.innerText = c.val;
            prev.style.border = "2px solid #7b1fa2";
            prev.style.color = "#7b1fa2";
            prev.style.fontWeight = "bold";
            prev.style.fontSize = "22px";
        }
    }
}

function selectAlchemistHand(idx) {
    alchemyHandIdx = idx;
    renderAlchemistUI();
}

// 実行: 成功（場に出す）
// ↓↓↓ execAlchemist関数を丸ごとこれに置き換えてください ↓↓↓
async function execAlchemist(resultVal) {
    closeModal();
    let updates = {};
    
    // 整合性チェック
    let hand = sortCards(deepCopy(gameState.hands[myId]));
    let deck = [...(gameState.deckNum || [])];
    let gn = [...(gameState.graveNum || [])];
    let excl = [...(gameState.exclusion || [])];
    
    // 山札チェック
    let realDrawn = deck[deck.length - 1]; 
    if (!realDrawn || Number(realDrawn.val) !== Number(alchemyDrawnCard.val)) {
        return showInfoModal("錬金失敗", "詠唱中に山札が変動しました。やり直してください。");
    }
    
    // 手札チェック
    if (!hand[alchemyHandIdx] || hand[alchemyHandIdx].isHacked) {
        return showInfoModal("錬金失敗", "選択した手札がロックされたか、失われました。");
    }

    // 処理実行
    deck.pop(); 
    let realHandCard = hand.splice(alchemyHandIdx, 1)[0];
    
    excl.push(realDrawn);
    excl.push(realHandCard);

    // 生成カードを場に出す
    let createdCard = { type: 'num', val: Number(resultVal), owner: myId, isAlchemy: true };
    gn.push(createdCard);
    
    hand = sortCards(hand);
    updates[`rooms/${currentRoom}/hands/${myId}`] = hand;
    updates[`rooms/${currentRoom}/deckNum`] = deck;
    updates[`rooms/${currentRoom}/exclusion`] = excl;
    updates[`rooms/${currentRoom}/graveNum`] = gn;

    await pushLog(`${myName}が錬金成功！ [${realDrawn.val}] (ドロー)と [${realHandCard.val}] (手札)を融合し [${resultVal}] を出しました。`, 'public');
    
    // ★1. ハッキング枚数と合計枚数の計算
    let myHackedCount = (gameState.hackedHands && gameState.hackedHands[myId]) ? gameState.hackedHands[myId].length : 0;
    let nextTotal = hand.length + myHackedCount;

    // ★2. 音の決定（スキル音 + UNO/DOS）
    let baseSound = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_ALCHEMIST']) ? 'SKILL_ALCHEMIST' : 'SKILL';
    let soundList = [baseSound];

    if (nextTotal === 1) soundList.push('UNO');
    else if (nextTotal === 2) soundList.push('DOS');

    // 音情報を送信
    updates[`rooms/${currentRoom}/lastSound`] = { type: soundList, id: Date.now() };

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ★3. あがり判定（計算済みの myHackedCount を使う）
    if (hand.length === 0 && myHackedCount === 0) {
        let currentRank = Object.keys(gameState.rankings || {}).length + 1;
        updates[`rooms/${currentRoom}/rankings/${myId}`] = currentRank;
        await pushLog(`${myName}が ${currentRank}位 であがりました！`, 'public');
        
        // ▼▼▼ 追加: 勝利者IDと、あがった時刻を記録 ▼▼▼
        updates[`rooms/${currentRoom}/lastWinnerId`] = myId;
        updates[`rooms/${currentRoom}/lastWinnerTime`] = Date.now();
        // ▲▲▲ 追加ここまで ▲▲▲
        
        let totalPlayers = gameState.playerOrder.length;
        if (currentRank >= totalPlayers - 1) {
             updates[`rooms/${currentRoom}/status`] = "finished";

            // 敗者（最後の一人）を特定
            let loserId = gameState.playerOrder.find(pid => !gameState.rankings?.[pid] && pid !== myId);
                     
                        if(loserId) {
                            // 敗者の順位を確定
                            updates[`rooms/${currentRoom}/rankings/${loserId}`] = totalPlayers;
                            
                            // 敗者の手札（通常手札 + ハッキング中の手札）を取得
                            let lHand = gameState.hands[loserId] || [];
                            let lHacked = (gameState.hackedHands && gameState.hackedHands[loserId]) ? gameState.hackedHands[loserId] : [];
                            let allL = [...lHand, ...lHacked];
                            
                            // カード名を文字列化
                            let lText = allL.map(c => c.val).join(", ") || "なし";
                            let lName = gameState.players[loserId].name;
                            
                            // 全員に見えるログとして送信
                            await pushLog(`全順位確定！！最下位 ${lName} の残りの手札: [${lText}]`, 'public');
                        } else {
                            await pushLog(`全順位が確定しました！！`, 'public');
                        }
                        // スコア更新を実行 (finalRankingsを組み立てて渡す)
                        let finalRankings = {...(gameState.rankings || {})};
                        finalRankings[myId] = currentRank; // 自分の順位
                        loserId = gameState.playerOrder.find(pid => !finalRankings[pid]);
                        if(loserId) finalRankings[loserId] = totalPlayers; // 敗者の順位
                        
                        updateFinalScores(finalRankings, gameState.playerOrder);
                    }           
    }
    
    let tempRankings = {...(gameState.rankings || {})};
    if (hand.length === 0) tempRankings[myId] = 99;

    updates[`rooms/${currentRoom}/passCount`] = 0;
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
    
    alchemyDrawnCard = null;
    alchemyHandIdx = -1;
}

// 実行: 中止（ドロー素材を除外）
async function execAlchemistKeep() {
    closeModal();
    let updates = {};
    
    let deck = [...(gameState.deckNum || [])];
    let excl = [...(gameState.exclusion || [])];
    
    // 山札チェック
    let realDrawn = deck[deck.length - 1]; 
    if (!realDrawn || Number(realDrawn.val) !== Number(alchemyDrawnCard.val)) {
        return showInfoModal("エラー", "山札の不整合が発生しました。");
    }
    
    // 除外する
    deck.pop(); 
    excl.push(realDrawn);
    
    updates[`rooms/${currentRoom}/deckNum`] = deck;
    updates[`rooms/${currentRoom}/exclusion`] = excl;

    await pushLog(`${myName}の錬金は失敗し、ドロー素材 [${realDrawn.val}] を除外しました。`, 'public');

    // スキル使用済み & パスカウントリセット
    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;
    updates[`rooms/${currentRoom}/passCount`] = 0;

    let tempRankings = {...(gameState.rankings || {})};
    let nextIdx = getNextActivePlayerIndex(gameState.turnIdx, gameState.playerOrder, tempRankings);
    updates[`rooms/${currentRoom}/turnIdx`] = nextIdx;

    await db.ref().update(updates);
    
    alchemyDrawnCard = null;
    alchemyHandIdx = -1;
}

/* --- NECROMANCER (ネクロマンサー) の実装 --- */

// 1. 発動確認
function activateNecromancer() {
    let gn = gameState.graveNum || [];
    let gs = gameState.graveSym || [];

    // 墓地チェック
    if (gn.length === 0 && gs.length === 0) {
        return showInfoModal("発動不可", "数字墓地・記号墓地ともにカードがないため、除外できません。");
    }

    necromancerTargetType = null;
    necromancerTargetIdx = -1;

    let html = `
        <p>除外するカードを1枚選んでください。<br>
        <span style="font-size:12px; color:#ef5350;">※除外した後、あなたのターンが続きます。</span>
        </p>

        <div style="margin-top:10px; text-align:left;"><strong>数字墓地</strong></div>
        <div class="modal-list" style="justify-content:flex-start;">
    `;

    if (gn.length > 0) {
        for (let i = gn.length - 1; i >= 0; i--) {
            let c = gn[i];
            let style = "";
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;

            if (i === gn.length - 1) {
                html += `
                    <div style="position:relative; display:inline-block;">
                        <div class="card num necromancer-item" data-card-val="${c.val}" style="${style}" onclick="selectNecromancerTarget('num', ${i}, this)">${c.val}</div>
                        <span style="position:absolute; top:-8px; right:-6px; background:#ffca28; color:#3e2723; font-size:9px; font-weight:bold; padding:1px 5px; border-radius:10px; border:1px solid #fff;">TOP</span>
                    </div>
                `;
            } else {
                html += `<div class="card num necromancer-item" data-card-val="${c.val}" style="${style}" onclick="selectNecromancerTarget('num', ${i}, this)">${c.val}</div>`;
            }
        }
        html += `<div class="modal-note warn" style="width:100%; margin-top:2px;">※TOP が数字墓地の一番上です</div>`;
    } else {
        html += `<button class="modal-btn is-disabled" disabled>数字墓地は空です</button>`;
        html += `<span class="modal-note">※記号墓地から選んでください。</span>`;
    }
    html += `</div>`;

    html += `
        <div style="margin-top:10px; text-align:left;"><strong>記号墓地</strong></div>
        <div class="modal-list" style="justify-content:flex-start;">
    `;

    if (gs.length > 0) {
        for (let i = gs.length - 1; i >= 0; i--) {
            let c = gs[i];
            let style = "";
            let cImg = CARD_IMAGES[c.val];
            if (cImg) style += `background-image:url('${cImg}'); color:transparent; border:2px solid #fff;`;
            html += `<div class="card sym necromancer-item" data-card-val="${c.val}" style="${style}" onclick="selectNecromancerTarget('sym', ${i}, this)">${c.val}</div>`;
        }
    } else {
        html += `<button class="modal-btn is-disabled" disabled>記号墓地は空です</button>`;
        html += `<span class="modal-note">※数字墓地から選んでください。</span>`;
    }
    html += `</div>`;

    html += `
        <div style="margin-top:12px; text-align:center;">
            <p id="necromancer-msg" style="font-size:12px; color:#666; margin:0 0 8px;">カードを1枚選択してください</p>
            <button id="btn-necromancer-exec" onclick="execNecromancer()" disabled style="background:#ccc; color:#fff; padding:10px 30px; font-weight:bold; border-radius:20px; border:none; cursor:not-allowed;">
                除外を実行
            </button>
        </div>
        <p style="font-size:11px; color:#666; margin-top:10px;">※選択後に「除外を実行」を押してください。</p>
    `;

    openModal("ネクロマンサー: 死者蘇生", html);
}

function selectNecromancerTarget(targetType, targetIdx, el) {
    if (targetType !== 'num' && targetType !== 'sym') return;
    if (!Number.isInteger(targetIdx) || targetIdx < 0) return;

    let items = document.querySelectorAll('#modal-content .necromancer-item');
    items.forEach(item => item.classList.remove('selected'));
    if (el && el.classList) el.classList.add('selected');

    necromancerTargetType = targetType;
    necromancerTargetIdx = targetIdx;

    let msg = document.getElementById('necromancer-msg');
    if (msg) {
        let zone = (targetType === 'num') ? '数字墓地' : '記号墓地';
        let val = (el && el.dataset && el.dataset.cardVal !== undefined) ? el.dataset.cardVal : '?';
        msg.innerText = `選択中: ${zone} [${val}]`;
        msg.style.color = '#4a148c';
    }

    let btn = document.getElementById('btn-necromancer-exec');
    if (btn) {
        btn.disabled = false;
        btn.style.background = '#4a148c';
        btn.style.color = '#fff';
        btn.style.cursor = 'pointer';
    }
}

// 2. 実行処理
async function execNecromancer() {
    let targetType = necromancerTargetType;
    let targetIdx = necromancerTargetIdx;

    if (targetType !== 'num' && targetType !== 'sym') {
        return showInfoModal("エラー", "除外するカードを選択してください。");
    }
    if (!Number.isInteger(targetIdx) || targetIdx < 0) {
        return showInfoModal("エラー", "除外するカードを選択してください。");
    }

    closeModal();
    let updates = {};

    // 最新の墓地データを取得
    let gn = [...(gameState.graveNum || [])];
    let gs = [...(gameState.graveSym || [])];
    let excl = [...(gameState.exclusion || [])];
    let actList = {...(gameState.activatedList || {})};

    // 念のため再チェック（UIすり抜け防止）
    if (targetType !== 'num' && targetType !== 'sym') {
        return showInfoModal("エラー", "除外対象の種類が不正です。");
    }
    if (!Number.isInteger(targetIdx) || targetIdx < 0) {
        return showInfoModal("エラー", "除外対象の指定が不正です。");
    }

    let removedCard = null;
    let fromLabel = "";
    if (targetType === 'num') {
        if (targetIdx >= gn.length) return showInfoModal("エラー", "選択したカードが見つかりません。再度選択してください。");
        removedCard = gn.splice(targetIdx, 1)[0];
        updates[`rooms/${currentRoom}/graveNum`] = gn;
        fromLabel = "数字墓地";
    } else {
        if (targetIdx >= gs.length) return showInfoModal("エラー", "選択したカードが見つかりません。再度選択してください。");
        removedCard = gs.splice(targetIdx, 1)[0];
        updates[`rooms/${currentRoom}/graveSym`] = gs;
        fromLabel = "記号墓地";
    }

    // 除外場へ
    excl.push(removedCard);

    // データ更新
    updates[`rooms/${currentRoom}/exclusion`] = excl;

    // スキル使用済みにする
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    // ログ＆音
    await pushLog(`${myName}が[ネクロマンサー]を発動！${fromLabel}の [${removedCard.val}] を蘇生して除外しました`, 'public');
    
    // 音の再生（スキル音があればそれ、なければDISCARD音などを代用）
    let soundType = (typeof SOUND_FILES !== 'undefined' && SOUND_FILES['SKILL_NECROMANCER']) ? 'SKILL_NECROMANCER' : 'DISCARD';
    updates[`rooms/${currentRoom}/lastSound`] = { type: soundType, id: Date.now() };

    /* ★重要: ターンを進める処理（turnIdxの更新）は書きません。
       これにより、まだ自分のターン（playCardができる状態）が維持されます。
    */

    await db.ref().update(updates);
    necromancerTargetType = null;
    necromancerTargetIdx = -1;
}

/* --- AGENT (工作員) の実装 --- */

// 1. 1人目選択
function activateAgent() {
    const pIds = gameState.playerOrder || [];
    const candidates = pIds.filter(pid => (gameState.hands[pid] || []).length > 0 && !isPoliticianShieldActive(pid));
    const blockedCandidates = pIds.filter(pid => (gameState.hands[pid] || []).length > 0 && isPoliticianShieldActive(pid));

    if (candidates.length < 2) {
        return showInfoModal("発動不可", "政治家の保護を除くと、交換対象が2人未満です。");
    }

    let html = `<p>ランダム交換する<strong>1人目（対象A）</strong>を選んでください。<br>
        <span class="modal-note">※このあと2人目（対象B）を選びます。</span>
    </p>`;

    candidates.forEach(pid => {
        const p = gameState.players[pid];
        const handCount = (gameState.hands[pid] || []).length;
        const selfLabel = (pid === myId) ? " (あなた)" : "";
        html += `<button class="modal-btn" onclick="agentSelectSecondTarget('${pid}')">${p.name}${selfLabel} (手札${handCount})</button>`;
    });
    if (blockedCandidates.length > 0) {
        html += `<p class="seki-disabled-note">※政治家の保護中プレイヤーは対象外です</p>`;
        blockedCandidates.forEach(pid => {
            const p = gameState.players[pid];
            html += `<button class="modal-btn is-disabled" disabled>${p.name} (政治家で対象外)</button>`;
        });
    }

    openModal("工作員: 対象A選択", html);
    if (document.getElementById("modal-footer")) {
        document.getElementById("modal-footer").innerHTML = "";
    }
}

// 2. 2人目選択
function agentSelectSecondTarget(firstId) {
    const pIds = gameState.playerOrder || [];
    const candidates = pIds.filter(pid =>
        pid !== firstId &&
        !isPoliticianShieldActive(pid) &&
        (gameState.hands[pid] || []).length > 0
    );
    const blockedCandidates = pIds.filter(pid =>
        pid !== firstId &&
        isPoliticianShieldActive(pid) &&
        (gameState.hands[pid] || []).length > 0
    );

    if (candidates.length === 0) {
        return showInfoModal("発動不可", "2人目の候補がいません。");
    }

    const firstName = gameState.players[firstId] ? gameState.players[firstId].name : "不明";
    let html = `<p><strong>2人目</strong>を選んでください。<br>
        <span class="modal-note">選択済み: ${firstName}</span>
    </p>`;

    candidates.forEach(pid => {
        const p = gameState.players[pid];
        const handCount = (gameState.hands[pid] || []).length;
        const selfLabel = (pid === myId) ? " (あなた)" : "";
        html += `<button class="modal-btn" onclick="execAgentSwap('${firstId}', '${pid}')">${p.name}${selfLabel} (手札${handCount})</button>`;
    });
    if (blockedCandidates.length > 0) {
        html += `<p class="seki-disabled-note">※政治家の保護中プレイヤーは対象外です</p>`;
        blockedCandidates.forEach(pid => {
            const p = gameState.players[pid];
            html += `<button class="modal-btn is-disabled" disabled>${p.name} (政治家で対象外)</button>`;
        });
    }

    openModal("工作員: 対象B選択", html);
    if (document.getElementById("modal-footer")) {
        document.getElementById("modal-footer").innerHTML = "";
    }
}

// 3. 実行処理（ランダム1枚交換）
async function execAgentSwap(pidA, pidB) {
    closeModal();
    if (!canTargetByHandInterference(pidA) || !canTargetByHandInterference(pidB)) return;

    let handA = deepCopy(gameState.hands[pidA] || []);
    let handB = deepCopy(gameState.hands[pidB] || []);

    if (handA.length === 0 || handB.length === 0) {
        return showInfoModal("エラー", "対象プレイヤーの手札が不足しています。");
    }

    const idxA = Math.floor(Math.random() * handA.length);
    const idxB = Math.floor(Math.random() * handB.length);

    const cardA = handA.splice(idxA, 1)[0];
    const cardB = handB.splice(idxB, 1)[0];
    handA.push(cardB);
    handB.push(cardA);

    const updates = {};
    updates[`rooms/${currentRoom}/hands/${pidA}`] = sortCards(handA);
    updates[`rooms/${currentRoom}/hands/${pidB}`] = sortCards(handB);

    let actList = {...(gameState.activatedList || {})};
    actList[myId] = true;
    updates[`rooms/${currentRoom}/activatedList`] = actList;

    const nameA = gameState.players[pidA] ? gameState.players[pidA].name : "不明";
    const nameB = gameState.players[pidB] ? gameState.players[pidB].name : "不明";

    await pushLog(`${myName}が[工作員]を発動！${nameA}と${nameB}の手札をランダムに1枚交換しました。`, 'public');
    await pushLog(`【工作員の策略】${nameA}:[${cardA.val}] ↔ ${nameB}:[${cardB.val}]`, 'private', pidA);
    await pushLog(`【工作員の策略】${nameA}:[${cardA.val}] ↔ ${nameB}:[${cardB.val}]`, 'private', pidB);

    if (pidA !== myId) {
        updates[`rooms/${currentRoom}/players/${pidA}/notification`] = {
            fromName: `${myName}(工作員)`,
            lostVal: cardA.val,
            gotVal: cardB.val
        };
    }
    if (pidB !== myId) {
        updates[`rooms/${currentRoom}/players/${pidB}/notification`] = {
            fromName: `${myName}(工作員)`,
            lostVal: cardB.val,
            gotVal: cardA.val
        };
    }

    // ターンは進めない（このあと自分のターンを継続）
    await db.ref().update(updates);
}

// カットイン再生関数（画像対応版）
function playCutInAnimation(roleKey, roleNameJp, playerName) {
    const overlay = document.getElementById("cut-in-overlay");
    const roleDiv = document.getElementById("cut-in-role");
    const playerDiv = document.getElementById("cut-in-player");
    
    // 画像があるかチェック
    const imgUrl = ROLE_IMAGES[roleKey];
    
    // 画像があれば背景にセット、なければ黒背景
    if (imgUrl) {
        // 画像を暗くして表示（文字を目立たせるため linear-gradient を被せる）
        overlay.style.background = `
            linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)),
            url('${imgUrl}') no-repeat center center / cover
        `;
    } else {
        overlay.style.background = "rgba(0, 0, 0, 0.8)";
    }
        
    // テキストセット
    roleDiv.innerText = roleNameJp; 
    playerDiv.innerText = playerName;

    overlay.classList.remove("hidden");
    overlay.classList.remove("animate-cut-in");
        
    void overlay.offsetWidth; // リフロー発生（アニメーション再始動のおまじない）
    overlay.classList.add("animate-cut-in");

    setTimeout(() => {
        overlay.classList.add("hidden");
        overlay.classList.remove("animate-cut-in");
        // 終わったら背景をリセットしておく
        overlay.style.background = "";
    }, 2500);
}

/* --- ★追加: 演出受信リスナー --- */
function setupEffectListener() {
    // DBの 'effect' ノードを監視
    db.ref(`rooms/${currentRoom}/effect`).on('value', (snapshot) => {
        let data = snapshot.val();
        if (!data) return;

        // タイムスタンプが古すぎる(5秒以上前)なら無視 (リロード時の暴発防止)
        if (Date.now() - data.timestamp > 5000) return;

        // 演出実行
        showVisualEffect(data);
    });
}
// ★新設: ホスト設定メニューを開く
        // ↓↓↓ openHostSettings関数をこれに置き換えてください ↓↓↓
        function openHostSettings() {
            let check6 = (lastHostHandMode === 6) ? "checked" : "";
            let check4 = (lastHostHandMode === 4) ? "checked" : "";

            let html = `
                <div class="seki-host-settings">
                    <div class="seki-host-mode-box">
                        <label class="seki-host-mode-item">
                            <input type="radio" name="handMode" value="6" ${check6}>
                            <div>
                                <span class="seki-host-mode-title">通常モード (6枚)</span>
                                <span class="seki-host-mode-meta">― 数字6 + 記号2</span>
                            </div>
                        </label>
                        <label class="seki-host-mode-item">
                            <input type="radio" name="handMode" value="4" ${check4}>
                            <div>
                                <span class="seki-host-mode-title hot">短期決戦 (4枚)</span>
                                <span class="seki-host-mode-meta">― 数字4 + 記号2</span>
                            </div>
                        </label>
                    </div>
                    
                    <div class="seki-host-actions">
                        <button onclick="confirmInitGameWithSettings()" class="modal-btn primary">
                            開始 / リセット
                        </button>
                        <button onclick="confirmCloseRoom()" class="modal-btn danger">
                            解散
                        </button>
                    </div>
                </div>
            `;
            openModal("ホスト設定", html, { tone: "guide" });
        }

        // ★新設: 設定値を読み取って開始確認へ
        function confirmInitGameWithSettings() {
            const modeEls = document.getElementsByName('handMode');
            for(let el of modeEls) { if(el.checked) lastHostHandMode = parseInt(el.value); }

            // 確認画面へ切り替え
            els.mTitle.innerText = "開始確認";
            els.mContent.innerHTML = `<p><strong>${lastHostHandMode}枚モード</strong> で<br>ゲームを開始（リセット）しますか？</p>`;
            els.mFooter.innerHTML = `
                ${renderModalButton("はい", `closeModal(); execInitGame(${lastHostHandMode})`, "primary")}
                ${renderModalButton("戻る", "openHostSettings()", "ghost")}
            `;
        }

        /* ===============================================
           iPhone対策: タブ切り替え後のオーディオ復活処理
           =============================================== */
        
        // 1. ページが再び「見える状態」になったら起こす
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                checkAndResumeAudio();
            }
        });

        // 2. 画面をタッチしたときも念のため起こす
        document.addEventListener('touchstart', function() {
            checkAndResumeAudio();
        }, { passive: true }); // passive: true はスクロール性能への配慮

        // オーディオの状態を確認して、死んでたら再開させる関数
        function checkAndResumeAudio() {
            if (!audioCtx) return;

            // 'suspended' (一時停止) や 'interrupted' (割り込み停止) なら再開
            if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
                audioCtx.resume().then(() => {
                    console.log("AudioContext Resumed by User Action/Visibility");
                }).catch(e => {
                    console.log("AudioContext Resume Failed", e);
                });
            }
        }

        function buildRoleGuideHtml() {
            let html = '<div class="font-readable seki-guide-root">';

            Object.keys(ROLE_INFO).forEach(key => {
                const info = ROLE_INFO[key];
                let imgHtml = "";
                if (typeof ROLE_IMAGES !== 'undefined' && ROLE_IMAGES[key]) {
                    imgHtml = `<img src="${ROLE_IMAGES[key]}" class="seki-guide-role-img">`;
                }

                html += `
                    <details class="seki-guide-role-item">
                        <summary class="seki-guide-summary">
                            ${imgHtml}
                            <div class="seki-guide-role-main">
                                <div class="seki-guide-role-jp">
                                    ${info.jp}
                                    <span class="seki-guide-role-en">${key}</span>
                                </div>
                                <div class="seki-guide-role-summary">
                                    <div>${info.summary}</div>
                                    <span class="seki-guide-hint">▼詳細</span>
                                </div>
                            </div>
                        </summary>
                        <div class="seki-guide-role-detail">${info.desc}</div>
                    </details>`;
            });

            html += "</div>";
            return html;
        }

        function buildRuleGuideHtml() {
            return `
                <div class="font-readable seki-rule-root">
                    <h4 class="seki-rule-heading">基本ルール</h4>
                    <p class="seki-rule-paragraph">・順に回ってくるターンで、手札を先に0枚にした人が勝ち！<br />・自分のターンでは以下から<strong>1つ</strong>の行動ができる<br />　　1. 手札から<span style="color: #3598db;"><strong>数字カード</strong></span>を数字墓地に出す（前の人より<strong>強いカード</strong>を出せる）<br />　　2. 手札から<span style="color: #e03e2d;"><strong>記号カード</strong></span>を使う<br />　　3. 一度きりの<span style="color: #843fa1;"><strong>役職能力</strong></span>を使う（詳しい説明は<strong><span style="color: #843fa1;">【役職】</span></strong>を参照）<br />　　4. <span style="color: #e67e23;"><strong>パス</strong></span>をして自分のターンを流す（パスの詳細は下部へ）</p>
                    <p class="seki-rule-paragraph">&nbsp;</p>
                    <h4 class="seki-rule-heading danger">記号カード</h4>
                    <ul class="seki-rule-list">
                    <li><strong>REVERSE</strong>（4枚）: <strong><span style="color: #3598db;">数字カード</span></strong>の強弱を逆転させる</li>
                    <li><strong>TRADE</strong>（4枚）: 好きな手札1枚を他のプレイヤーと交換する</li>
                    <li><strong>DIG UP</strong>（4枚）: 数字墓地の1番上のカードと、手札の<strong><span style="color: #3598db;">数字カード</span></strong>を交換する</li>
                    <li><strong>DISCARD</strong>（<strong><span style="color: #e03e2d;">1</span>枚</strong>）: 好きな<strong><span style="color: #3598db;">数字カード</span></strong>を1枚捨てる</li>
                    </ul>
                    <p>&nbsp;</p>
                    <h4 class="seki-rule-heading info">数字カード</h4>
                    <p class="seki-rule-paragraph">・数字カードは0~9まで各4枚ずつ<br /><strong>・「0」はいつでも出せるが、その上に何でも出せる！</strong><br /><strong>　🔵 順行🐘 (通常):</strong><br />　　0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9<br /><strong>　🔴 逆行🐁 (REVERSE中):</strong><br />　　0 &lt; 9 &lt; 8 &lt; 7 &lt; 6 &lt; 5 &lt; 4 &lt; 3 &lt; 2 &lt; 1</p>
                    <p class="seki-rule-paragraph">&nbsp;</p>
                    <h4 class="seki-rule-heading warn">パスとリセット</h4>
                    <p class="seki-rule-paragraph">・<strong>パス</strong>では、数字カードを1枚引いても良い<br />　&rArr;その際、出せるなら出しても良い！</p>
                    <p class="seki-rule-paragraph"><strong>【リセットとは】</strong></p>
                    <ul class="seki-rule-list">
                    <li>数字墓地の一番上のカードを出したプレイヤーは<strong>リセット権</strong>を持つ<br />
                    <li><strong>リセット権</strong>を持っているプレイヤーがパスすると、数字墓地のカードが全て除外され、何でも出せる<br />
                    <li><strong>リセット権</strong>は、<strong>👑RESET</strong>で表示されている</li>
                    <li><strong>リセット権</strong>を持ったプレイヤーがあがった場合、<span style="text-decoration: underline;">数字墓地の一番上のカードが変わらない限り、一周後に次のプレイヤーに移動する</span></li>
                    </ul>
                    <p class="seki-rule-paragraph">&nbsp;</p>
                    <h4 class="seki-rule-heading danger">🚫禁止事項🚫</h4>
                    <ul class="seki-rule-list">
                    <li><strong>記号あがり</strong>: 手札の最後の1枚が記号カードのとき、それを使って0枚にはできない</li>
                    </ul>
                    <ul class="seki-rule-list">
                    <li><strong>0あがり</strong>: 手札の最後の1枚が0のとき、0を出して0枚にすることはできない</li>
                    </ul>
                </div>
            `;
        }

        function openGuide(kind, surface = "main") {
            let title = "";
            let html = "";

            if (kind === "role") {
                title = "👥役職一覧";
                html = buildRoleGuideHtml();
            } else if (kind === "rule") {
                title = "📖ルール";
                html = buildRuleGuideHtml();
            } else {
                return;
            }

            if (surface === "sub" && typeof openSubModal === "function") {
                openSubModal(title, html);
                return;
            }

            openModal(title, html, { size: "wide", tone: "guide" });
        }

        function showRoleList() { openGuide("role", "main"); }
        function showRule() { openGuide("rule", "main"); }

        // --- ★追加: プレイヤー別ログ表示機能 ---
        function showPlayerLogs(targetId) {
            if (!gameState || !gameState.logs) return showInfoModal("履歴なし", "まだ記録がありません。");
            if (!gameState.players[targetId]) return;

            const targetName = gameState.players[targetId].name;
            const logs = gameState.logs;
            
            // フィルタリング: typeがpublicで、テキストにその人の名前が含まれるもの
            const filtered = logs.filter(l => 
                l.type === 'public' && l.text.includes(targetName)
            );

            if (filtered.length === 0) return showInfoModal(targetName + "の履歴", "表示できる行動履歴がありません。");

            let html = `<div class="seki-scroll-panel">`;
            
            // 新しい順に表示
            [...filtered].reverse().forEach(l => {
                let time = new Date(l.timestamp).toLocaleTimeString('ja-JP', {hour:'2-digit', minute:'2-digit'});
                html += `
                    <div class="seki-log-line">
                        <span class="seki-log-time">${time}</span>
                        <span class="seki-log-text">${l.text}</span>
                    </div>
                `;
            });
            
            html += `</div>`;
            openModal(`${targetName} の行動履歴`, html, { size: "default", tone: "guide" });
        }

        // --- スコア更新関数 ---
        async function updateFinalScores(finalRankings, playerOrder) {
            let currentScores = gameState.scores || {};
            let totalPlayers = playerOrder.length;
            let updates = {};

            playerOrder.forEach(pid => {
                let rank = finalRankings[pid];
                if (rank) {
                    // スコア計算式: 2 * (人数 - 順位) + 1
                    let roundPoint = 2 * (totalPlayers - rank) + 1;
                    let oldScore = currentScores[pid] || 0;
                    updates[`rooms/${currentRoom}/scores/${pid}`] = oldScore + roundPoint;
                }
            });
            await db.ref().update(updates);
        }

        // --- スコアボード表示関数 ---
        function showScoreboard() {
            if (!gameState) return;
            let scores = gameState.scores || {};
            let players = gameState.players || {};

            // 現在の参加人数を取得（ゲーム開始前なら現在のプレイヤー数を使用）
            let playerOrder = gameState.playerOrder || Object.keys(players);
            let totalPlayers = playerOrder.length;

            // 1. 点数配分のテキストを作成
            let distributionText = "";
            if (totalPlayers >= 2) {
                let distArray = [];
                for (let r = 1; r <= totalPlayers; r++) {
                    let pts = 2 * (totalPlayers - r) + 1;
                    distArray.push(`${r}位:${pts}pt`);
                }
                distributionText = `<div class="score-dist">
                    現在の配分 (${totalPlayers}人戦): ${distArray.join(' / ')}
                </div>`;
            }

            // スコア順にソート
            let sortedPids = Object.keys(scores).sort((a, b) => scores[b] - scores[a]);

            // 2. HTMLの組み立て
            let html = distributionText; // タイトルのすぐ下に配分を表示

            html += `<table class="score-table">
                        <tr class="score-head">
                            <th>名 前</th>
                            <th>合計点数</th>
                        </tr>`;

            if (sortedPids.length === 0) {
                html += `<tr><td colspan="2" class="score-empty">まだ記録がありません</td></tr>`;
            }

            sortedPids.forEach(pid => {
                let pName = players[pid] ? players[pid].name : "不明なユーザー";
                let score = scores[pid];
                let rowClass = (pid === myId) ? "score-row me" : "score-row";
                html += `<tr class="${rowClass}">
                            <td class="score-name-cell">${pName}</td>
                            <td class="score-point-cell">${score} pt</td>
                        </tr>`;
            });
            html += `</table>`;
            
            // ホストのみスコアリセットボタンを表示
            let hostId = getEffectiveHostId(gameState);

            if (myId === hostId) {
                html += `<div class="score-reset-wrap">
                            <button onclick="confirmResetScores()" class="score-reset-btn">スコアを全てリセット</button>
                        </div>`;
            }

            openModal("🏆 総合ランキング", html, { tone: "guide" });
        }

        // スコアリセット用（ホスト用）
        function confirmResetScores() {
            showConfirmModal("スコアリセット", "部屋全体の累積スコアを消去しますか？", "db.ref(`rooms/${currentRoom}/scores`).remove()");
        }

        // 1. 共通のホスト判定関数（これを一度作っておけば、どこでも使えます）
    function getEffectiveHostId(data) {
        if (!data) return null;
        let pIds = data.playerOrder || getSortedPlayerIds(data.players || {});
        let hostId = (pIds.length > 0) ? pIds[0] : null;

        // ゲーム終了時は最下位（敗者）にホスト権限を移す
        if (data.status === "finished" && data.rankings) {
            let loserId = Object.keys(data.rankings).reduce((a, b) => 
                data.rankings[a] > data.rankings[b] ? a : b
            , null);
            if (loserId && data.players[loserId]) {
                hostId = loserId;
            }
        }
        return hostId;
    }
        

    
        // Global exports
        window.joinGame = joinGame;
        window.playCard = playCard;
        window.passTurn = passTurn;
        window.initGame = confirmInitGame; 
        window.viewGrave = viewGrave;
        window.closeModal = closeModal;
        window.execDigUp = execDigUp;
        window.tradeStep2 = tradeStep2;
        window.tradeStep3 = tradeStep3; // ★追加: 奪うカード選択
        window.execTrade = execTrade;
        window.execDiscard = execDiscard;
        window.execPassDraw = execPassDraw;
        window.execPassNoDraw = execPassNoDraw;
        window.execPassPlay = execPassPlay;
        window.execPassKeep = execPassKeep;
        window.execPassReset = execPassReset;
        window.closeRoom = confirmCloseRoom;
        window.execInitGame = execInitGame;
        window.execCloseRoom = execCloseRoom;
        window.showLogHistory = showLogHistory;
        window.sendChat = sendChat;
        window.playCutInAnimation = playCutInAnimation;
        window.openHostSettings = openHostSettings;
        window.confirmInitGameWithSettings = confirmInitGameWithSettings;
        window.showRoleList = showRoleList;
        window.showRule = showRule;
        window.leaveRoom = leaveRoom; // これを追加
        // windowオブジェクトに登録してHTMLから呼べるようにする
        window.showPlayerLogs = showPlayerLogs;
        // 釣り人
        window.activateAngler = activateAngler;
        window.anglerStep2 = anglerStep2;
        window.execAngler = execAngler;
        // 占い師
        window.activateFortuneTeller = activateFortuneTeller;
        // 天文学者
        window.activateAstronomer = activateAstronomer;
        window.execAstronomerObserve = execAstronomerObserve;
        window.showAstronomerInvalidSelection = showAstronomerInvalidSelection;
        // 盗賊
        window.activateThief = activateThief;
        window.thiefSelectTake = thiefSelectTake; // ★追加
        window.thiefSelectGive = thiefSelectGive; // ★追加(名前変更)
        window.execThiefTrade = execThiefTrade;
        window.endThiefTurn = endThiefTurn;
        // 狩人
        window.activateHunter = activateHunter;
        window.toggleHunterSelect = toggleHunterSelect; // 新しい関数
        window.checkHunterCount = checkHunterCount;     // 新しい関数
        window.execHunterSwap = execHunterSwap;
        // 賭博師
        window.activateGambler = activateGambler;
        window.execGamblerGuess = execGamblerGuess;
        window.gamblerSelectDiscard = gamblerSelectDiscard;
        window.toggleGamblerSelect = toggleGamblerSelect;
        window.execGamblerDiscard = execGamblerDiscard;
        // 手品師
        window.activateMagician = activateMagician;
        window.execMagicianReverse = execMagicianReverse;
        window.activateMagicianTrade = activateMagicianTrade;
        window.magicianSelectTake = magicianSelectTake; // ★新設
        window.magicianSelectGive = magicianSelectGive; // ★名前変更
        window.activateMagicianDigUp = activateMagicianDigUp;
        window.execMagicianDigUp = execMagicianDigUp;
        // 富豪
        window.activateMillionaire = activateMillionaire;
        window.execMillionaire = execMillionaire;
        // 政治家
        window.activatePolitician = activatePolitician;
        // 皇帝
        window.activateEmperor = activateEmperor;
        window.execEmperorSelect = execEmperorSelect;
        // 警察官
        window.activatePoliceOfficer = activatePoliceOfficer;
        window.policeTradeStart = policeTradeStart;
        window.endPoliceTurn = endPoliceTurn;
        window.policeSelectTake = policeSelectTake; // ★追加: 奪うカード選択
        window.policeSelectGive = policeSelectGive;
        window.execPoliceTrade = execPoliceTrade;
        // ハッカー
        window.activateHacker = activateHacker;
        window.selectHackerTarget = selectHackerTarget;
        window.execHacker = execHacker;
        window.checkHackerCleanup = checkHackerCleanup;
        // 錬金術師
        window.activateAlchemist = activateAlchemist;
        window.selectAlchemistHand = selectAlchemistHand;
        window.execAlchemist = execAlchemist;
        window.execAlchemistKeep = execAlchemistKeep; // ★名前変更 (Keep)
        // ネクロマンサー
        window.activateNecromancer = activateNecromancer; // ★追加
        window.selectNecromancerTarget = selectNecromancerTarget; // ★追加
        window.execNecromancer = execNecromancer;         // ★追加
        // 工作員
        window.activateAgent = activateAgent;
        window.agentSelectSecondTarget = agentSelectSecondTarget;
        window.execAgentSwap = execAgentSwap;


    </script>
    <div id="counter-hud-wrapper" class="hidden">
    <div id="counter-toggle-btn" onclick="toggleCounterHUD()">
        📊
    </div>

    <div id="counter-panel">
        <div class="hud-header">
            <span>CARD COUNTER</span>
            <span class="close-btn" onclick="toggleCounterHUD()">×</span>
        </div>
        
        <div class="hud-section-title">NUMBER (残/全4)</div>
        <div class="hud-grid" id="hud-grid-num">
            <div class="hud-loading">Loading...</div>
        </div>

        <div class="hud-section-title">SYMBOL</div>
        <div class="hud-grid-sym" id="hud-grid-sym">
            <div class="hud-loading">Loading...</div>
        </div>
        
        <div class="hud-footnote">
            ※山札 + 相手の手札にある数
        </div>
    </div>
</div>

<style>
    /* --- カウンティングHUDのスタイル --- */
    #counter-hud-wrapper {
        font-family: var(--font-ui);
        user-select: none;
        z-index: 9999; /* 最前面に */
    }

    /* 1. 開閉ボタン（スマホで邪魔にならないサイズ） */
    #counter-toggle-btn {
        position: fixed;
        top: 60px;       /* ヘッダーの下あたり */
        right: 15px;     /* 右端に配置 */
        z-index: 2000;   
        
        width: 44px; height: 44px;
        background: rgba(4, 11, 23, 0.8);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(0, 216, 255, 0.62);
        border-radius: 50%;
        
        display: flex; justify-content: center; align-items: center;
        color: #dff6ff;
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5), 0 0 12px rgba(0, 216, 255, 0.2);
        transition: transform 0.2s, background 0.2s, border-color 0.2s, box-shadow 0.2s;
    }
    #counter-toggle-btn:hover {
        border-color: rgba(0, 216, 255, 0.82);
        box-shadow: 0 6px 14px rgba(0,0,0,0.55), 0 0 16px rgba(0, 216, 255, 0.3);
    }
    #counter-toggle-btn:active { transform: scale(0.9); background: rgba(2, 8, 16, 0.92); }

    /* 2. パネル本体（グラスモーフィズム） */
    #counter-panel {
        position: fixed;
        top: 115px;
        right: 15px;
        z-index: 1999;
        
        width: 240px;    /* スマホでも見やすい幅 */
        background: linear-gradient(155deg, rgba(6, 16, 32, 0.9), rgba(4, 11, 23, 0.86));
        backdrop-filter: blur(15px);
        border: 1px solid rgba(0, 216, 255, 0.34);
        border-radius: 12px;
        padding: 12px;
        
        /* アニメーション（右上から展開） */
        transform-origin: top right;
        transform: scale(0);
        opacity: 0;
        transition: all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: none;
        
        box-shadow: 0 10px 30px rgba(0,0,0,0.8), 0 0 22px rgba(0, 216, 255, 0.18);
    }
    /* 開いた状態 */
    #counter-panel.active {
        transform: scale(1);
        opacity: 1;
        pointer-events: auto;
    }

    /* 内部レイアウト */
    .hud-header {
        display: flex; justify-content: space-between; align-items: center;
        font-size: 12px; font-weight: bold; color: #a8e9ff;
        border-bottom: 1px solid rgba(0, 216, 255, 0.28);
        padding-bottom: 5px; margin-bottom: 8px;
    }
    .close-btn { cursor: pointer; padding: 0 5px; font-size: 16px; color: #fff; }

    .hud-section-title {
        font-size: 10px; color: #b9cde4; margin-bottom: 4px; letter-spacing: 1px;
    }

    .hud-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr); /* 5列 (0-4, 5-9) */
        gap: 4px;
        margin-bottom: 12px;
    }
    .hud-grid-sym {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* 記号は2列 */
        gap: 4px;
    }

    .hud-item {
        background: rgba(255,255,255,0.05);
        border-radius: 6px;
        padding: 4px 0;
        text-align: center;
        border: 1px solid rgba(163, 196, 231, 0.16);
    }
    /* 残り0枚になったら暗くする */
    .hud-item.zero { opacity: 0.3; background: transparent; border: 1px dashed #444; }
    /* 残り枚数が多いときは強調 */
    .hud-item.rich { border-color: rgba(0, 216, 255, 0.36); background: rgba(0, 216, 255, 0.08); }

    .hud-val { font-size: 11px; font-weight: bold; color: #ccc; display: block; line-height: 1; margin-bottom: 2px; }
    .hud-count { font-size: 15px; font-weight: 800; color: #fff; display: block; line-height: 1; }
    .hud-loading {
        grid-column: 1/-1;
        text-align: center;
        color: #8ca2bd;
        font-size: 10px;
    }
    .hud-footnote {
        font-size: 10px;
        color: #9cb3c9;
        margin-top: 5px;
        text-align: center;
    }
    
    /* 記号ごとの色分け */
    .hud-item.sym-rev .hud-val { color: #e91e63; } /* REVERSE: 赤 */
    .hud-item.sym-tra .hud-val { color: #ff9800; } /* TRADE: オレンジ */
    .hud-item.sym-dig .hud-val { color: #795548; } /* DIG UP: 茶 */
    .hud-item.sym-dis .hud-val { color: #9e9e9e; } /* DISCARD: グレー */

</style>

<script>
    /* --- カウンティングロジック (改修版) --- */
    
    // カードの初期枚数定義
    const INITIAL_COUNTS = {
        // 数字 (各4枚)
        0:4, 1:4, 2:4, 3:4, 4:4, 5:4, 6:4, 7:4, 8:4, 9:4,
        // 記号
        "REVERSE": 4,
        "TRADE": 4,
        "DIG UP": 4,
        "DISCARD": 1
    };

    // パネル開閉関数
    window.toggleCounterHUD = function() {
        const panel = document.getElementById("counter-panel");
        if(panel) {
            panel.classList.toggle("active");
            updateCounterHUD(); // 開いた瞬間に更新
        }
    };

    // カウント更新関数（メインロジック）
    function updateCounterHUD() {
        const wrapper = document.getElementById("counter-hud-wrapper");
        
        // ★重要: ゲームに参加していない（ログイン画面）ときは隠す
        // gameStateがない、または myId がない場合は非表示にして終了
        if (typeof gameState === 'undefined' || !gameState || typeof myId === 'undefined' || !myId) {
            if(wrapper) wrapper.classList.add("hidden");
            return;
        }

        // ゲーム中なら表示する
        if(wrapper && wrapper.classList.contains("hidden")) {
            wrapper.classList.remove("hidden");
        }

        // ★修正ポイント: 手札の取得方法を変更
        // 以前の currentHand は更新されていない場合があるため、
        // 確実な gameState.hands[myId] から取得します。
        let myHandRef = [];
        // myId が定義されているか念のためチェック
        if (typeof myId !== 'undefined' && gameState.hands && gameState.hands[myId]) {
            myHandRef = gameState.hands[myId];
        }

        // 1. カウント用オブジェクトを初期化（コピー）
        let remaining = Object.assign({}, INITIAL_COUNTS);

        // 2. 「見えているカード」を減算するヘルパー関数
        const subtractVisible = (cardList) => {
            if (!cardList || !Array.isArray(cardList)) return;
            cardList.forEach(c => {
                if (!c || c.val === undefined) return;

                // ★重要: 錬金術師によって生成されたカード(isAlchemy=true)は
                // 「本来の山札の枚数」ではないため、カウントから除外しない（無視する）。
                if (c.isAlchemy) return;

                if (remaining[c.val] !== undefined) {
                    remaining[c.val]--;
                }
            });
        };

        // 3. 各場所から減算 (gameStateのキー名に注意)
        subtractVisible(myHandRef);                // 自分の手札（これで正しく引かれます！）
        subtractVisible(gameState.graveNum);       // 数字墓地
        subtractVisible(gameState.graveSym);       // 記号墓地
        
        // ★除外エリアの対応
        // コード解析の結果、gameState.exclusion に格納されていることが判明
        if (gameState.exclusion) subtractVisible(gameState.exclusion);
        
        // 念のため removed もチェック (古いバージョン対策)
        if (gameState.removed) subtractVisible(gameState.removed);


        // 4. HTMLへの描画（数字）
        const gridNum = document.getElementById("hud-grid-num");
        if(gridNum) {
            let html = "";
            for (let i = 0; i <= 9; i++) {
                let count = remaining[i];
                if (count < 0) count = 0; // エラー防止
                let cls = count === 0 ? "zero" : (count >= 3 ? "rich" : "");
                html += `
                    <div class="hud-item ${cls}">
                        <span class="hud-val">${i}</span>
                        <span class="hud-count" style="color:${getColorForCount(count)}">${count}</span>
                    </div>
                `;
            }
            gridNum.innerHTML = html;
        }

        // 5. HTMLへの描画（記号）
        const gridSym = document.getElementById("hud-grid-sym");
        if(gridSym) {
            const syms = [
                {k: "REVERSE", l:"REV", c:"sym-rev"}, 
                {k: "TRADE",   l:"TRA", c:"sym-tra"}, 
                {k: "DIG UP",  l:"DIG", c:"sym-dig"}, 
                {k: "DISCARD", l:"DIS", c:"sym-dis"}
            ];
            let html = "";
            syms.forEach(s => {
                let count = remaining[s.k];
                if (count < 0) count = 0;
                let cls = count === 0 ? "zero" : "";
                html += `
                    <div class="hud-item ${s.c} ${cls}">
                        <span class="hud-val">${s.l}</span>
                        <span class="hud-count">${count}</span>
                    </div>
                `;
            });
            gridSym.innerHTML = html;
        }
    }

    // カウントの色分け（多いと緑、少ないと赤）
    function getColorForCount(n) {
        if (n === 0) return "#555";
        if (n === 1) return "#ff5252"; // 赤
        if (n === 2) return "#ffeb3b"; // 黄
        return "#69f0ae"; // 緑
    }

    // 6. 定期実行（0.5秒ごとに更新）
    // ゲーム開始前などでエラーが出ないよう try-catch で囲む
    setInterval(() => {
        try {
            updateCounterHUD();
        } catch(e) {
            // エラーは無視（コンソールを汚さない）
        }
    }, 500);

</script>
<div id="sub-modal-overlay" class="hidden" onclick="closeSubModal()">
    <div id="sub-modal-box" onclick="event.stopPropagation()">
        <span class="close-btn" onclick="closeSubModal()">×</span>
        <h3 id="sub-modal-title">タイトル</h3>
        <div id="sub-modal-body"></div>
    </div>
</div>

<style>
    /* メインのモーダルより上に表示 */
    #sub-modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(2, 7, 15, 0.72);
        z-index: 9999;
        display: flex; justify-content: center; align-items: center;
        backdrop-filter: blur(5px);
        transition: opacity 0.2s;
    }
    #sub-modal-overlay.hidden { display: none !important; opacity: 0; }

    #sub-modal-box {
        background:
            linear-gradient(155deg, rgba(6, 16, 32, 0.9), rgba(4, 11, 23, 0.84)),
            radial-gradient(circle at 14% 16%, rgba(0, 216, 255, 0.11), transparent 36%);
        color: var(--seki-text-main);
        width: 90%; max-width: 600px;
        max-height: 80vh;
        border-radius: 14px;
        padding: 20px;
        position: relative;
        font-family: var(--font-readable);
        box-shadow: var(--seki-shadow-panel), 0 0 24px rgba(0, 216, 255, 0.18);
        border: 1px solid rgba(0, 216, 255, 0.36);
        display: flex; flex-direction: column;
        animation: subPopIn 0.2s ease-out;
    }
    @keyframes subPopIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    #sub-modal-title { margin: 0 0 10px 0; border-bottom: 2px solid rgba(0, 216, 255, 0.56); padding-bottom: 5px; color: #9ce8ff; }
    #sub-modal-body { overflow-y: auto; flex: 1; text-align: left; font-size: 14px; line-height: 1.6; }

    #sub-modal-box .close-btn {
        position: absolute; top: 10px; right: 15px;
        font-size: 24px; cursor: pointer; color: #a8c7e4;
    }

    /* メインモーダルに追加する共通ボタン */
    #modal-board-toggle {
        position: absolute; top: 10px; right: 10px;
        border: 1px solid rgba(122, 168, 218, 0.6);
        border-radius: 16px;
        background: rgba(7, 22, 42, 0.92);
        color: #e6f6ff;
        padding: 3px 10px; font-size: 12px; cursor: pointer;
        line-height: 1.2; z-index: 100;
        transition: transform var(--seki-transition-fast), border-color var(--seki-transition-fast), box-shadow var(--seki-transition-fast);
    }
    #modal-board-toggle:hover {
        border-color: rgba(0, 216, 255, 0.78);
        box-shadow: 0 0 10px rgba(0, 216, 255, 0.28);
        transform: translateY(-1px);
    }
    #modal-board-toggle.active {
        background: linear-gradient(135deg, #0f314d, #166d98 46%, #00d8ff);
        border-color: rgba(0, 216, 255, 0.88);
        color: #fff;
    }

    #modal-help-btns {
        position: absolute; top: 10px; left: 10px;
        display: flex; gap: 5px; z-index: 100;
    }
    .help-icon-btn {
        background: none;
        border: 1px solid rgba(122, 168, 218, 0.6);
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        padding: 2px 6px;
        color: #e6f6ff;
        background: rgba(7, 22, 42, 0.92);
        transition: transform var(--seki-transition-fast), border-color var(--seki-transition-fast), box-shadow var(--seki-transition-fast);
    }
    .help-icon-btn:hover {
        transform: scale(1.06);
        border-color: rgba(0, 216, 255, 0.8);
        box-shadow: 0 2px 9px rgba(0,0,0,0.2), 0 0 10px rgba(0, 216, 255, 0.28);
    }
</style>

<script>
    /* --- 1. 既存モーダルに共通補助ボタンを注入 --- */
    if (!window._origOpenModal) window._origOpenModal = window.openModal;
    if (!window._origCloseModal) window._origCloseModal = window.closeModal;

    let mainModalBoardMode = false;

    function setMainModalBoardMode(enabled) {
        mainModalBoardMode = !!enabled;
        const overlay = document.getElementById("modal-overlay");
        const toggleBtn = document.getElementById("modal-board-toggle");

        if (overlay) overlay.classList.toggle("board-visible", mainModalBoardMode);
        if (toggleBtn) {
            toggleBtn.classList.toggle("active", mainModalBoardMode);
            toggleBtn.textContent = mainModalBoardMode ? "👁 盤面ON" : "👁 盤面OFF";
        }
    }

    function toggleMainModalBoardMode() {
        setMainModalBoardMode(!mainModalBoardMode);
    }

    function ensureMainModalTools() {
        const box = document.getElementById("modal-box");
        if (!box) return;

        if (getComputedStyle(box).position === "static") box.style.position = "relative";

        let btnDiv = document.getElementById("modal-help-btns");
        if (!btnDiv) {
            btnDiv = document.createElement("div");
            btnDiv.id = "modal-help-btns";
            btnDiv.innerHTML = `
                <button class="help-icon-btn" onclick="showRuleSub()" title="ルール">📖</button>
                <button class="help-icon-btn" onclick="showRoleSub()" title="役職一覧">👥</button>
            `;
            box.appendChild(btnDiv);
        }

        let boardBtn = document.getElementById("modal-board-toggle");
        if (!boardBtn) {
            boardBtn = document.createElement("button");
            boardBtn.id = "modal-board-toggle";
            boardBtn.type = "button";
            boardBtn.setAttribute("onclick", "toggleMainModalBoardMode()");
            boardBtn.title = "盤面確認";
            box.appendChild(boardBtn);
        }
    }

    window.openModal = function(title, html, options = {}) {
        window._origOpenModal(title, html, options);
        ensureMainModalTools();
        setMainModalBoardMode(false);
    };

    window.closeModal = function() {
        setMainModalBoardMode(false);
        window._origCloseModal();
    };

    const modalOverlay = document.getElementById("modal-overlay");
    if (modalOverlay && !window._modalBoardObserverAttached) {
        window._modalBoardObserverAttached = true;
        let lastMainModalHiddenState = modalOverlay.classList.contains("hidden");
        const observer = new MutationObserver(() => {
            const isHidden = modalOverlay.classList.contains("hidden");
            if (lastMainModalHiddenState && !isHidden) {
                ensureMainModalTools();
                setMainModalBoardMode(false);
            }
            lastMainModalHiddenState = isHidden;
        });
        observer.observe(modalOverlay, { attributes: true, attributeFilter: ["class"] });
        if (!modalOverlay.classList.contains("hidden")) {
            ensureMainModalTools();
            setMainModalBoardMode(false);
        }
    }

    /* --- 2. サブモーダル制御 --- */
    function openSubModal(title, html) {
        document.getElementById("sub-modal-title").innerText = title;
        document.getElementById("sub-modal-body").innerHTML = html;
        document.getElementById("sub-modal-overlay").classList.remove("hidden");
    }

    function closeSubModal() {
        document.getElementById("sub-modal-overlay").classList.add("hidden");
    }

    /* --- 3. 共通ガイド表示 --- */
    function showRuleSub() {
        openGuide("rule", "sub");
    }

    function showRoleSub() {
        openGuide("role", "sub");
    }

    window.closeSubModal = closeSubModal;
    window.toggleMainModalBoardMode = toggleMainModalBoardMode;
    window.showRuleSub = showRuleSub;
    window.showRoleSub = showRoleSub;
</script>

</body>
</html>

